/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * Represents a Backend Service resource.
 * A backend service defines how Google Cloud load balancers distribute traffic. The backend service configuration contains a set of values, such as the protocol used to connect to backends, various distribution and session settings, health checks, and timeouts. These settings provide fine-grained control over how your load balancer behaves. Most of the settings have default values that allow for easy configuration if you need to get started quickly.
 * Backend services in Google Compute Engine can be either regionally or globally scoped.
 * * [Global](/compute/docs/reference/rest/{$api_version}/backendServices) * [Regional](/compute/docs/reference/rest/{$api_version}/regionBackendServices)
 * For more information, see Backend Services.
 * (== resource_for {$api_version}.backendService ==)
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.BackendService}
 */
public final class BackendService extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.BackendService)
    BackendServiceOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use BackendService.newBuilder() to construct.
  private BackendService(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private BackendService() {
    backends_ = java.util.Collections.emptyList();
    creationTimestamp_ = "";
    customRequestHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    customResponseHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    description_ = "";
    fingerprint_ = "";
    healthChecks_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    id_ = "";
    kind_ = "";
    loadBalancingScheme_ = 0;
    localityLbPolicy_ = 0;
    name_ = "";
    network_ = "";
    portName_ = "";
    protocol_ = 0;
    region_ = "";
    securityPolicy_ = "";
    selfLink_ = "";
    sessionAffinity_ = 0;
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new BackendService();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private BackendService(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 26842:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000800;
              id_ = s;
              break;
            }
          case 832194:
            {
              com.google.cloud.compute.v1.BackendServiceIAP.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) != 0)) {
                subBuilder = iap_.toBuilder();
              }
              iap_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.BackendServiceIAP.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(iap_);
                iap_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
          case 7247066:
            {
              com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder subBuilder =
                  null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = consistentHash_.toBuilder();
              }
              consistentHash_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(consistentHash_);
                consistentHash_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
          case 26336418:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00001000;
              kind_ = s;
              break;
            }
          case 26989658:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00010000;
              name_ = s;
              break;
            }
          case 27575304:
            {
              bitField0_ |= 0x00080000;
              port_ = input.readInt32();
              break;
            }
          case 223823938:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                customRequestHeaders_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000080;
              }
              customRequestHeaders_.add(s);
              break;
            }
          case 244202930:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000020;
              creationTimestamp_ = s;
              break;
            }
          case 332274762:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00100000;
              portName_ = s;
              break;
            }
          case 639959960:
            {
              bitField0_ |= 0x08000000;
              timeoutSec_ = input.readInt32();
              break;
            }
          case 676623552:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00200000;
              protocol_ = rawValue;
              break;
            }
          case 845269242:
            {
              com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = failoverPolicy_.toBuilder();
              }
              failoverPolicy_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.BackendServiceFailoverPolicy.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(failoverPolicy_);
                failoverPolicy_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
          case 1051451896:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00004000;
              localityLbPolicy_ = rawValue;
              break;
            }
          case 1111570338:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00400000;
              region_ = s;
              break;
            }
          case 1368660106:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00800000;
              securityPolicy_ = s;
              break;
            }
          case 1711811618:
            {
              com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) != 0)) {
                subBuilder = cdnPolicy_.toBuilder();
              }
              cdnPolicy_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.BackendServiceCdnPolicy.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(cdnPolicy_);
                cdnPolicy_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
          case 1862979954:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00020000;
              network_ = s;
              break;
            }
          case 1877428002:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000200;
              fingerprint_ = s;
              break;
            }
          case 2005867992:
            {
              bitField0_ |= 0x00000080;
              enableCDN_ = input.readBool();
              break;
            }
          case -1484569366:
            {
              com.google.cloud.compute.v1.BackendServiceLogConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00008000) != 0)) {
                subBuilder = logConfig_.toBuilder();
              }
              logConfig_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.BackendServiceLogConfig.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(logConfig_);
                logConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00008000;
              break;
            }
          case -1457966606:
            {
              com.google.cloud.compute.v1.OutlierDetection.Builder subBuilder = null;
              if (((bitField0_ & 0x00040000) != 0)) {
                subBuilder = outlierDetection_.toBuilder();
              }
              outlierDetection_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.OutlierDetection.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(outlierDetection_);
                outlierDetection_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00040000;
              break;
            }
          case -1383845344:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00002000;
              loadBalancingScheme_ = rawValue;
              break;
            }
          case -1334991664:
            {
              bitField0_ |= 0x00000001;
              affinityCookieTtlSec_ = input.readInt32();
              break;
            }
          case -1194654542:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                customResponseHeaders_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000100;
              }
              customResponseHeaders_.add(s);
              break;
            }
          case -924246806:
            {
              com.google.cloud.compute.v1.CircuitBreakers.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = circuitBreakers_.toBuilder();
              }
              circuitBreakers_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.CircuitBreakers.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(circuitBreakers_);
                circuitBreakers_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
          case -911466526:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000040;
              description_ = s;
              break;
            }
          case -708002446:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00002000) != 0)) {
                healthChecks_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00002000;
              }
              healthChecks_.add(s);
              break;
            }
          case -645248918:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x02000000;
              selfLink_ = s;
              break;
            }
          case -606193318:
            {
              com.google.cloud.compute.v1.ConnectionDraining.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = connectionDraining_.toBuilder();
              }
              connectionDraining_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.ConnectionDraining.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(connectionDraining_);
                connectionDraining_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
          case -583858808:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x04000000;
              sessionAffinity_ = rawValue;
              break;
            }
          case -465767918:
            {
              com.google.cloud.compute.v1.SecuritySettings.Builder subBuilder = null;
              if (((bitField0_ & 0x01000000) != 0)) {
                subBuilder = securitySettings_.toBuilder();
              }
              securitySettings_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.SecuritySettings.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(securitySettings_);
                securitySettings_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x01000000;
              break;
            }
          case -208248070:
            {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                backends_ = new java.util.ArrayList<com.google.cloud.compute.v1.Backend>();
                mutable_bitField0_ |= 0x00000002;
              }
              backends_.add(
                  input.readMessage(
                      com.google.cloud.compute.v1.Backend.parser(), extensionRegistry));
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000080) != 0)) {
        customRequestHeaders_ = customRequestHeaders_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000100) != 0)) {
        customResponseHeaders_ = customResponseHeaders_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00002000) != 0)) {
        healthChecks_ = healthChecks_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        backends_ = java.util.Collections.unmodifiableList(backends_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_BackendService_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_BackendService_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.BackendService.class,
            com.google.cloud.compute.v1.BackendService.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.BackendService.LoadBalancingScheme}
   */
  public enum LoadBalancingScheme implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOAD_BALANCING_SCHEME = 0;</code>
     */
    UNDEFINED_LOAD_BALANCING_SCHEME(0),
    /** <code>EXTERNAL = 35607499;</code> */
    EXTERNAL(35607499),
    /** <code>INTERNAL = 279295677;</code> */
    INTERNAL(279295677),
    /** <code>INTERNAL_MANAGED = 37350397;</code> */
    INTERNAL_MANAGED(37350397),
    /** <code>INTERNAL_SELF_MANAGED = 236211150;</code> */
    INTERNAL_SELF_MANAGED(236211150),
    /** <code>INVALID_LOAD_BALANCING_SCHEME = 275352060;</code> */
    INVALID_LOAD_BALANCING_SCHEME(275352060),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOAD_BALANCING_SCHEME = 0;</code>
     */
    public static final int UNDEFINED_LOAD_BALANCING_SCHEME_VALUE = 0;
    /** <code>EXTERNAL = 35607499;</code> */
    public static final int EXTERNAL_VALUE = 35607499;
    /** <code>INTERNAL = 279295677;</code> */
    public static final int INTERNAL_VALUE = 279295677;
    /** <code>INTERNAL_MANAGED = 37350397;</code> */
    public static final int INTERNAL_MANAGED_VALUE = 37350397;
    /** <code>INTERNAL_SELF_MANAGED = 236211150;</code> */
    public static final int INTERNAL_SELF_MANAGED_VALUE = 236211150;
    /** <code>INVALID_LOAD_BALANCING_SCHEME = 275352060;</code> */
    public static final int INVALID_LOAD_BALANCING_SCHEME_VALUE = 275352060;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LoadBalancingScheme valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LoadBalancingScheme forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_LOAD_BALANCING_SCHEME;
        case 35607499:
          return EXTERNAL;
        case 279295677:
          return INTERNAL;
        case 37350397:
          return INTERNAL_MANAGED;
        case 236211150:
          return INTERNAL_SELF_MANAGED;
        case 275352060:
          return INVALID_LOAD_BALANCING_SCHEME;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>() {
              public LoadBalancingScheme findValueByNumber(int number) {
                return LoadBalancingScheme.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.BackendService.getDescriptor().getEnumTypes().get(0);
    }

    private static final LoadBalancingScheme[] VALUES = values();

    public static LoadBalancingScheme valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LoadBalancingScheme(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.BackendService.LoadBalancingScheme)
  }

  /**
   *
   *
   * <pre>
   * The load balancing algorithm used within the scope of the locality. The possible values are:
   * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
   * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
   * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
   * - RANDOM: The load balancer selects a random healthy host.
   * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
   * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
   * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.BackendService.LocalityLbPolicy}
   */
  public enum LocalityLbPolicy implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOCALITY_LB_POLICY = 0;</code>
     */
    UNDEFINED_LOCALITY_LB_POLICY(0),
    /** <code>INVALID_LB_POLICY = 323318707;</code> */
    INVALID_LB_POLICY(323318707),
    /** <code>LEAST_REQUEST = 46604921;</code> */
    LEAST_REQUEST(46604921),
    /** <code>MAGLEV = 119180266;</code> */
    MAGLEV(119180266),
    /** <code>ORIGINAL_DESTINATION = 166297216;</code> */
    ORIGINAL_DESTINATION(166297216),
    /** <code>RANDOM = 262527171;</code> */
    RANDOM(262527171),
    /** <code>RING_HASH = 432795069;</code> */
    RING_HASH(432795069),
    /** <code>ROUND_ROBIN = 153895801;</code> */
    ROUND_ROBIN(153895801),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOCALITY_LB_POLICY = 0;</code>
     */
    public static final int UNDEFINED_LOCALITY_LB_POLICY_VALUE = 0;
    /** <code>INVALID_LB_POLICY = 323318707;</code> */
    public static final int INVALID_LB_POLICY_VALUE = 323318707;
    /** <code>LEAST_REQUEST = 46604921;</code> */
    public static final int LEAST_REQUEST_VALUE = 46604921;
    /** <code>MAGLEV = 119180266;</code> */
    public static final int MAGLEV_VALUE = 119180266;
    /** <code>ORIGINAL_DESTINATION = 166297216;</code> */
    public static final int ORIGINAL_DESTINATION_VALUE = 166297216;
    /** <code>RANDOM = 262527171;</code> */
    public static final int RANDOM_VALUE = 262527171;
    /** <code>RING_HASH = 432795069;</code> */
    public static final int RING_HASH_VALUE = 432795069;
    /** <code>ROUND_ROBIN = 153895801;</code> */
    public static final int ROUND_ROBIN_VALUE = 153895801;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LocalityLbPolicy valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LocalityLbPolicy forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_LOCALITY_LB_POLICY;
        case 323318707:
          return INVALID_LB_POLICY;
        case 46604921:
          return LEAST_REQUEST;
        case 119180266:
          return MAGLEV;
        case 166297216:
          return ORIGINAL_DESTINATION;
        case 262527171:
          return RANDOM;
        case 432795069:
          return RING_HASH;
        case 153895801:
          return ROUND_ROBIN;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LocalityLbPolicy> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<LocalityLbPolicy>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LocalityLbPolicy>() {
              public LocalityLbPolicy findValueByNumber(int number) {
                return LocalityLbPolicy.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.BackendService.getDescriptor().getEnumTypes().get(1);
    }

    private static final LocalityLbPolicy[] VALUES = values();

    public static LocalityLbPolicy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LocalityLbPolicy(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.BackendService.LocalityLbPolicy)
  }

  /**
   *
   *
   * <pre>
   * The protocol this BackendService uses to communicate with backends.
   * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
   * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.BackendService.Protocol}
   */
  public enum Protocol implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_PROTOCOL = 0;</code>
     */
    UNDEFINED_PROTOCOL(0),
    /** <code>GRPC = 2196510;</code> */
    GRPC(2196510),
    /** <code>HTTP = 2228360;</code> */
    HTTP(2228360),
    /** <code>HTTP2 = 69079210;</code> */
    HTTP2(69079210),
    /** <code>HTTPS = 69079243;</code> */
    HTTPS(69079243),
    /** <code>SSL = 82412;</code> */
    SSL(82412),
    /** <code>TCP = 82881;</code> */
    TCP(82881),
    /** <code>UDP = 83873;</code> */
    UDP(83873),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_PROTOCOL = 0;</code>
     */
    public static final int UNDEFINED_PROTOCOL_VALUE = 0;
    /** <code>GRPC = 2196510;</code> */
    public static final int GRPC_VALUE = 2196510;
    /** <code>HTTP = 2228360;</code> */
    public static final int HTTP_VALUE = 2228360;
    /** <code>HTTP2 = 69079210;</code> */
    public static final int HTTP2_VALUE = 69079210;
    /** <code>HTTPS = 69079243;</code> */
    public static final int HTTPS_VALUE = 69079243;
    /** <code>SSL = 82412;</code> */
    public static final int SSL_VALUE = 82412;
    /** <code>TCP = 82881;</code> */
    public static final int TCP_VALUE = 82881;
    /** <code>UDP = 83873;</code> */
    public static final int UDP_VALUE = 83873;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Protocol valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Protocol forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_PROTOCOL;
        case 2196510:
          return GRPC;
        case 2228360:
          return HTTP;
        case 69079210:
          return HTTP2;
        case 69079243:
          return HTTPS;
        case 82412:
          return SSL;
        case 82881:
          return TCP;
        case 83873:
          return UDP;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Protocol> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Protocol> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Protocol>() {
          public Protocol findValueByNumber(int number) {
            return Protocol.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.BackendService.getDescriptor().getEnumTypes().get(2);
    }

    private static final Protocol[] VALUES = values();

    public static Protocol valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Protocol(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.BackendService.Protocol)
  }

  /**
   *
   *
   * <pre>
   * Type of session affinity to use. The default is NONE.
   * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
   * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
   * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.BackendService.SessionAffinity}
   */
  public enum SessionAffinity implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SESSION_AFFINITY = 0;</code>
     */
    UNDEFINED_SESSION_AFFINITY(0),
    /** <code>CLIENT_IP = 345665051;</code> */
    CLIENT_IP(345665051),
    /** <code>CLIENT_IP_PORT_PROTO = 221722926;</code> */
    CLIENT_IP_PORT_PROTO(221722926),
    /** <code>CLIENT_IP_PROTO = 25322148;</code> */
    CLIENT_IP_PROTO(25322148),
    /** <code>GENERATED_COOKIE = 370321204;</code> */
    GENERATED_COOKIE(370321204),
    /** <code>HEADER_FIELD = 200737960;</code> */
    HEADER_FIELD(200737960),
    /** <code>HTTP_COOKIE = 494981627;</code> */
    HTTP_COOKIE(494981627),
    /** <code>NONE = 2402104;</code> */
    NONE(2402104),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SESSION_AFFINITY = 0;</code>
     */
    public static final int UNDEFINED_SESSION_AFFINITY_VALUE = 0;
    /** <code>CLIENT_IP = 345665051;</code> */
    public static final int CLIENT_IP_VALUE = 345665051;
    /** <code>CLIENT_IP_PORT_PROTO = 221722926;</code> */
    public static final int CLIENT_IP_PORT_PROTO_VALUE = 221722926;
    /** <code>CLIENT_IP_PROTO = 25322148;</code> */
    public static final int CLIENT_IP_PROTO_VALUE = 25322148;
    /** <code>GENERATED_COOKIE = 370321204;</code> */
    public static final int GENERATED_COOKIE_VALUE = 370321204;
    /** <code>HEADER_FIELD = 200737960;</code> */
    public static final int HEADER_FIELD_VALUE = 200737960;
    /** <code>HTTP_COOKIE = 494981627;</code> */
    public static final int HTTP_COOKIE_VALUE = 494981627;
    /** <code>NONE = 2402104;</code> */
    public static final int NONE_VALUE = 2402104;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SessionAffinity valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SessionAffinity forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SESSION_AFFINITY;
        case 345665051:
          return CLIENT_IP;
        case 221722926:
          return CLIENT_IP_PORT_PROTO;
        case 25322148:
          return CLIENT_IP_PROTO;
        case 370321204:
          return GENERATED_COOKIE;
        case 200737960:
          return HEADER_FIELD;
        case 494981627:
          return HTTP_COOKIE;
        case 2402104:
          return NONE;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SessionAffinity> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SessionAffinity>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionAffinity>() {
              public SessionAffinity findValueByNumber(int number) {
                return SessionAffinity.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.BackendService.getDescriptor().getEnumTypes().get(3);
    }

    private static final SessionAffinity[] VALUES = values();

    public static SessionAffinity valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SessionAffinity(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.BackendService.SessionAffinity)
  }

  private int bitField0_;
  public static final int AFFINITY_COOKIE_TTL_SEC_FIELD_NUMBER = 369996954;
  private int affinityCookieTtlSec_;
  /**
   *
   *
   * <pre>
   * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
   * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
   *
   * @return Whether the affinityCookieTtlSec field is set.
   */
  @java.lang.Override
  public boolean hasAffinityCookieTtlSec() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   *
   *
   * <pre>
   * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
   * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
   *
   * @return The affinityCookieTtlSec.
   */
  @java.lang.Override
  public int getAffinityCookieTtlSec() {
    return affinityCookieTtlSec_;
  }

  public static final int BACKENDS_FIELD_NUMBER = 510839903;
  private java.util.List<com.google.cloud.compute.v1.Backend> backends_;
  /**
   *
   *
   * <pre>
   * The list of backends that serve this BackendService.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.cloud.compute.v1.Backend> getBackendsList() {
    return backends_;
  }
  /**
   *
   *
   * <pre>
   * The list of backends that serve this BackendService.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.cloud.compute.v1.BackendOrBuilder>
      getBackendsOrBuilderList() {
    return backends_;
  }
  /**
   *
   *
   * <pre>
   * The list of backends that serve this BackendService.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
   */
  @java.lang.Override
  public int getBackendsCount() {
    return backends_.size();
  }
  /**
   *
   *
   * <pre>
   * The list of backends that serve this BackendService.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.Backend getBackends(int index) {
    return backends_.get(index);
  }
  /**
   *
   *
   * <pre>
   * The list of backends that serve this BackendService.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendOrBuilder getBackendsOrBuilder(int index) {
    return backends_.get(index);
  }

  public static final int CDN_POLICY_FIELD_NUMBER = 213976452;
  private com.google.cloud.compute.v1.BackendServiceCdnPolicy cdnPolicy_;
  /**
   *
   *
   * <pre>
   * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
   *
   * @return Whether the cdnPolicy field is set.
   */
  @java.lang.Override
  public boolean hasCdnPolicy() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   *
   *
   * <pre>
   * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
   *
   * @return The cdnPolicy.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceCdnPolicy getCdnPolicy() {
    return cdnPolicy_ == null
        ? com.google.cloud.compute.v1.BackendServiceCdnPolicy.getDefaultInstance()
        : cdnPolicy_;
  }
  /**
   *
   *
   * <pre>
   * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceCdnPolicyOrBuilder getCdnPolicyOrBuilder() {
    return cdnPolicy_ == null
        ? com.google.cloud.compute.v1.BackendServiceCdnPolicy.getDefaultInstance()
        : cdnPolicy_;
  }

  public static final int CIRCUIT_BREAKERS_FIELD_NUMBER = 421340061;
  private com.google.cloud.compute.v1.CircuitBreakers circuitBreakers_;
  /**
   *
   *
   * <pre>
   * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
   *
   * @return Whether the circuitBreakers field is set.
   */
  @java.lang.Override
  public boolean hasCircuitBreakers() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   *
   *
   * <pre>
   * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
   *
   * @return The circuitBreakers.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.CircuitBreakers getCircuitBreakers() {
    return circuitBreakers_ == null
        ? com.google.cloud.compute.v1.CircuitBreakers.getDefaultInstance()
        : circuitBreakers_;
  }
  /**
   *
   *
   * <pre>
   * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
    return circuitBreakers_ == null
        ? com.google.cloud.compute.v1.CircuitBreakers.getDefaultInstance()
        : circuitBreakers_;
  }

  public static final int CONNECTION_DRAINING_FIELD_NUMBER = 461096747;
  private com.google.cloud.compute.v1.ConnectionDraining connectionDraining_;
  /**
   * <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code>
   *
   * @return Whether the connectionDraining field is set.
   */
  @java.lang.Override
  public boolean hasConnectionDraining() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code>
   *
   * @return The connectionDraining.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ConnectionDraining getConnectionDraining() {
    return connectionDraining_ == null
        ? com.google.cloud.compute.v1.ConnectionDraining.getDefaultInstance()
        : connectionDraining_;
  }
  /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
  @java.lang.Override
  public com.google.cloud.compute.v1.ConnectionDrainingOrBuilder getConnectionDrainingOrBuilder() {
    return connectionDraining_ == null
        ? com.google.cloud.compute.v1.ConnectionDraining.getDefaultInstance()
        : connectionDraining_;
  }

  public static final int CONSISTENT_HASH_FIELD_NUMBER = 905883;
  private com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistentHash_;
  /**
   *
   *
   * <pre>
   * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
   * </code>
   *
   * @return Whether the consistentHash field is set.
   */
  @java.lang.Override
  public boolean hasConsistentHash() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   *
   *
   * <pre>
   * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
   * </code>
   *
   * @return The consistentHash.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings getConsistentHash() {
    return consistentHash_ == null
        ? com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.getDefaultInstance()
        : consistentHash_;
  }
  /**
   *
   *
   * <pre>
   * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
   * </code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettingsOrBuilder
      getConsistentHashOrBuilder() {
    return consistentHash_ == null
        ? com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.getDefaultInstance()
        : consistentHash_;
  }

  public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 30525366;
  private volatile java.lang.Object creationTimestamp_;
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return Whether the creationTimestamp field is set.
   */
  @java.lang.Override
  public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The creationTimestamp.
   */
  @java.lang.Override
  public java.lang.String getCreationTimestamp() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      creationTimestamp_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The bytes for creationTimestamp.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getCreationTimestampBytes() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      creationTimestamp_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int CUSTOM_REQUEST_HEADERS_FIELD_NUMBER = 27977992;
  private com.google.protobuf.LazyStringList customRequestHeaders_;
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied requests.
   * </pre>
   *
   * <code>repeated string custom_request_headers = 27977992;</code>
   *
   * @return A list containing the customRequestHeaders.
   */
  public com.google.protobuf.ProtocolStringList getCustomRequestHeadersList() {
    return customRequestHeaders_;
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied requests.
   * </pre>
   *
   * <code>repeated string custom_request_headers = 27977992;</code>
   *
   * @return The count of customRequestHeaders.
   */
  public int getCustomRequestHeadersCount() {
    return customRequestHeaders_.size();
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied requests.
   * </pre>
   *
   * <code>repeated string custom_request_headers = 27977992;</code>
   *
   * @param index The index of the element to return.
   * @return The customRequestHeaders at the given index.
   */
  public java.lang.String getCustomRequestHeaders(int index) {
    return customRequestHeaders_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied requests.
   * </pre>
   *
   * <code>repeated string custom_request_headers = 27977992;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the customRequestHeaders at the given index.
   */
  public com.google.protobuf.ByteString getCustomRequestHeadersBytes(int index) {
    return customRequestHeaders_.getByteString(index);
  }

  public static final int CUSTOM_RESPONSE_HEADERS_FIELD_NUMBER = 387539094;
  private com.google.protobuf.LazyStringList customResponseHeaders_;
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied responses.
   * </pre>
   *
   * <code>repeated string custom_response_headers = 387539094;</code>
   *
   * @return A list containing the customResponseHeaders.
   */
  public com.google.protobuf.ProtocolStringList getCustomResponseHeadersList() {
    return customResponseHeaders_;
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied responses.
   * </pre>
   *
   * <code>repeated string custom_response_headers = 387539094;</code>
   *
   * @return The count of customResponseHeaders.
   */
  public int getCustomResponseHeadersCount() {
    return customResponseHeaders_.size();
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied responses.
   * </pre>
   *
   * <code>repeated string custom_response_headers = 387539094;</code>
   *
   * @param index The index of the element to return.
   * @return The customResponseHeaders at the given index.
   */
  public java.lang.String getCustomResponseHeaders(int index) {
    return customResponseHeaders_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Headers that the HTTP/S load balancer should add to proxied responses.
   * </pre>
   *
   * <code>repeated string custom_response_headers = 387539094;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the customResponseHeaders at the given index.
   */
  public com.google.protobuf.ByteString getCustomResponseHeadersBytes(int index) {
    return customResponseHeaders_.getByteString(index);
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 422937596;
  private volatile java.lang.Object description_;
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return Whether the description field is set.
   */
  @java.lang.Override
  public boolean hasDescription() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The description.
   */
  @java.lang.Override
  public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      description_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The bytes for description.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      description_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ENABLE_C_D_N_FIELD_NUMBER = 250733499;
  private boolean enableCDN_;
  /**
   *
   *
   * <pre>
   * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
   * </pre>
   *
   * <code>bool enable_c_d_n = 250733499;</code>
   *
   * @return Whether the enableCDN field is set.
   */
  @java.lang.Override
  public boolean hasEnableCDN() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   *
   *
   * <pre>
   * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
   * </pre>
   *
   * <code>bool enable_c_d_n = 250733499;</code>
   *
   * @return The enableCDN.
   */
  @java.lang.Override
  public boolean getEnableCDN() {
    return enableCDN_;
  }

  public static final int FAILOVER_POLICY_FIELD_NUMBER = 105658655;
  private com.google.cloud.compute.v1.BackendServiceFailoverPolicy failoverPolicy_;
  /**
   *
   *
   * <pre>
   * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;</code>
   *
   * @return Whether the failoverPolicy field is set.
   */
  @java.lang.Override
  public boolean hasFailoverPolicy() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   *
   *
   * <pre>
   * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;</code>
   *
   * @return The failoverPolicy.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceFailoverPolicy getFailoverPolicy() {
    return failoverPolicy_ == null
        ? com.google.cloud.compute.v1.BackendServiceFailoverPolicy.getDefaultInstance()
        : failoverPolicy_;
  }
  /**
   *
   *
   * <pre>
   * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceFailoverPolicyOrBuilder
      getFailoverPolicyOrBuilder() {
    return failoverPolicy_ == null
        ? com.google.cloud.compute.v1.BackendServiceFailoverPolicy.getDefaultInstance()
        : failoverPolicy_;
  }

  public static final int FINGERPRINT_FIELD_NUMBER = 234678500;
  private volatile java.lang.Object fingerprint_;
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
   * To see the latest fingerprint, make a get() request to retrieve a BackendService.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return Whether the fingerprint field is set.
   */
  @java.lang.Override
  public boolean hasFingerprint() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
   * To see the latest fingerprint, make a get() request to retrieve a BackendService.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return The fingerprint.
   */
  @java.lang.Override
  public java.lang.String getFingerprint() {
    java.lang.Object ref = fingerprint_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      fingerprint_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
   * To see the latest fingerprint, make a get() request to retrieve a BackendService.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return The bytes for fingerprint.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getFingerprintBytes() {
    java.lang.Object ref = fingerprint_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      fingerprint_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int HEALTH_CHECKS_FIELD_NUMBER = 448370606;
  private com.google.protobuf.LazyStringList healthChecks_;
  /**
   *
   *
   * <pre>
   * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
   * </pre>
   *
   * <code>repeated string health_checks = 448370606;</code>
   *
   * @return A list containing the healthChecks.
   */
  public com.google.protobuf.ProtocolStringList getHealthChecksList() {
    return healthChecks_;
  }
  /**
   *
   *
   * <pre>
   * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
   * </pre>
   *
   * <code>repeated string health_checks = 448370606;</code>
   *
   * @return The count of healthChecks.
   */
  public int getHealthChecksCount() {
    return healthChecks_.size();
  }
  /**
   *
   *
   * <pre>
   * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
   * </pre>
   *
   * <code>repeated string health_checks = 448370606;</code>
   *
   * @param index The index of the element to return.
   * @return The healthChecks at the given index.
   */
  public java.lang.String getHealthChecks(int index) {
    return healthChecks_.get(index);
  }
  /**
   *
   *
   * <pre>
   * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
   * </pre>
   *
   * <code>repeated string health_checks = 448370606;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the healthChecks at the given index.
   */
  public com.google.protobuf.ByteString getHealthChecksBytes(int index) {
    return healthChecks_.getByteString(index);
  }

  public static final int IAP_FIELD_NUMBER = 104024;
  private com.google.cloud.compute.v1.BackendServiceIAP iap_;
  /**
   *
   *
   * <pre>
   * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
   *
   * @return Whether the iap field is set.
   */
  @java.lang.Override
  public boolean hasIap() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   *
   *
   * <pre>
   * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
   *
   * @return The iap.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceIAP getIap() {
    return iap_ == null ? com.google.cloud.compute.v1.BackendServiceIAP.getDefaultInstance() : iap_;
  }
  /**
   *
   *
   * <pre>
   * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceIAPOrBuilder getIapOrBuilder() {
    return iap_ == null ? com.google.cloud.compute.v1.BackendServiceIAP.getDefaultInstance() : iap_;
  }

  public static final int ID_FIELD_NUMBER = 3355;
  private volatile java.lang.Object id_;
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return Whether the id field is set.
   */
  @java.lang.Override
  public boolean hasId() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The id.
   */
  @java.lang.Override
  public java.lang.String getId() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      id_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The bytes for id.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getIdBytes() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      id_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int KIND_FIELD_NUMBER = 3292052;
  private volatile java.lang.Object kind_;
  /**
   *
   *
   * <pre>
   * [Output Only] Type of resource. Always compute#backendService for backend services.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return Whether the kind field is set.
   */
  @java.lang.Override
  public boolean hasKind() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of resource. Always compute#backendService for backend services.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The kind.
   */
  @java.lang.Override
  public java.lang.String getKind() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      kind_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of resource. Always compute#backendService for backend services.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The bytes for kind.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getKindBytes() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      kind_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int LOAD_BALANCING_SCHEME_FIELD_NUMBER = 363890244;
  private int loadBalancingScheme_;
  /**
   *
   *
   * <pre>
   * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return Whether the loadBalancingScheme field is set.
   */
  @java.lang.Override
  public boolean hasLoadBalancingScheme() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return The enum numeric value on the wire for loadBalancingScheme.
   */
  @java.lang.Override
  public int getLoadBalancingSchemeValue() {
    return loadBalancingScheme_;
  }
  /**
   *
   *
   * <pre>
   * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return The loadBalancingScheme.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendService.LoadBalancingScheme getLoadBalancingScheme() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.BackendService.LoadBalancingScheme result =
        com.google.cloud.compute.v1.BackendService.LoadBalancingScheme.valueOf(
            loadBalancingScheme_);
    return result == null
        ? com.google.cloud.compute.v1.BackendService.LoadBalancingScheme.UNRECOGNIZED
        : result;
  }

  public static final int LOCALITY_LB_POLICY_FIELD_NUMBER = 131431487;
  private int localityLbPolicy_;
  /**
   *
   *
   * <pre>
   * The load balancing algorithm used within the scope of the locality. The possible values are:
   * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
   * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
   * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
   * - RANDOM: The load balancer selects a random healthy host.
   * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
   * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
   * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
   * </code>
   *
   * @return Whether the localityLbPolicy field is set.
   */
  @java.lang.Override
  public boolean hasLocalityLbPolicy() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The load balancing algorithm used within the scope of the locality. The possible values are:
   * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
   * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
   * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
   * - RANDOM: The load balancer selects a random healthy host.
   * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
   * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
   * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
   * </code>
   *
   * @return The enum numeric value on the wire for localityLbPolicy.
   */
  @java.lang.Override
  public int getLocalityLbPolicyValue() {
    return localityLbPolicy_;
  }
  /**
   *
   *
   * <pre>
   * The load balancing algorithm used within the scope of the locality. The possible values are:
   * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
   * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
   * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
   * - RANDOM: The load balancer selects a random healthy host.
   * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
   * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
   * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
   * </code>
   *
   * @return The localityLbPolicy.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendService.LocalityLbPolicy getLocalityLbPolicy() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.BackendService.LocalityLbPolicy result =
        com.google.cloud.compute.v1.BackendService.LocalityLbPolicy.valueOf(localityLbPolicy_);
    return result == null
        ? com.google.cloud.compute.v1.BackendService.LocalityLbPolicy.UNRECOGNIZED
        : result;
  }

  public static final int LOG_CONFIG_FIELD_NUMBER = 351299741;
  private com.google.cloud.compute.v1.BackendServiceLogConfig logConfig_;
  /**
   *
   *
   * <pre>
   * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
   *
   * @return Whether the logConfig field is set.
   */
  @java.lang.Override
  public boolean hasLogConfig() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
   *
   * @return The logConfig.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceLogConfig getLogConfig() {
    return logConfig_ == null
        ? com.google.cloud.compute.v1.BackendServiceLogConfig.getDefaultInstance()
        : logConfig_;
  }
  /**
   *
   *
   * <pre>
   * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendServiceLogConfigOrBuilder getLogConfigOrBuilder() {
    return logConfig_ == null
        ? com.google.cloud.compute.v1.BackendServiceLogConfig.getDefaultInstance()
        : logConfig_;
  }

  public static final int NAME_FIELD_NUMBER = 3373707;
  private volatile java.lang.Object name_;
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return Whether the name field is set.
   */
  @java.lang.Override
  public boolean hasName() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NETWORK_FIELD_NUMBER = 232872494;
  private volatile java.lang.Object network_;
  /**
   *
   *
   * <pre>
   * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return Whether the network field is set.
   */
  @java.lang.Override
  public boolean hasNetwork() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The network.
   */
  @java.lang.Override
  public java.lang.String getNetwork() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      network_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The bytes for network.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNetworkBytes() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      network_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int OUTLIER_DETECTION_FIELD_NUMBER = 354625086;
  private com.google.cloud.compute.v1.OutlierDetection outlierDetection_;
  /**
   *
   *
   * <pre>
   * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
   *
   * @return Whether the outlierDetection field is set.
   */
  @java.lang.Override
  public boolean hasOutlierDetection() {
    return ((bitField0_ & 0x00040000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
   *
   * @return The outlierDetection.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.OutlierDetection getOutlierDetection() {
    return outlierDetection_ == null
        ? com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()
        : outlierDetection_;
  }
  /**
   *
   *
   * <pre>
   * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
   * This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
    return outlierDetection_ == null
        ? com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()
        : outlierDetection_;
  }

  public static final int PORT_FIELD_NUMBER = 3446913;
  private int port_;
  /**
   *
   *
   * <pre>
   * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
   * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
   * </pre>
   *
   * <code>int32 port = 3446913;</code>
   *
   * @return Whether the port field is set.
   */
  @java.lang.Override
  public boolean hasPort() {
    return ((bitField0_ & 0x00080000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
   * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
   * </pre>
   *
   * <code>int32 port = 3446913;</code>
   *
   * @return The port.
   */
  @java.lang.Override
  public int getPort() {
    return port_;
  }

  public static final int PORT_NAME_FIELD_NUMBER = 41534345;
  private volatile java.lang.Object portName_;
  /**
   *
   *
   * <pre>
   * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
   * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
   * </pre>
   *
   * <code>string port_name = 41534345;</code>
   *
   * @return Whether the portName field is set.
   */
  @java.lang.Override
  public boolean hasPortName() {
    return ((bitField0_ & 0x00100000) != 0);
  }
  /**
   *
   *
   * <pre>
   * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
   * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
   * </pre>
   *
   * <code>string port_name = 41534345;</code>
   *
   * @return The portName.
   */
  @java.lang.Override
  public java.lang.String getPortName() {
    java.lang.Object ref = portName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      portName_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
   * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
   * </pre>
   *
   * <code>string port_name = 41534345;</code>
   *
   * @return The bytes for portName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getPortNameBytes() {
    java.lang.Object ref = portName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      portName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PROTOCOL_FIELD_NUMBER = 84577944;
  private int protocol_;
  /**
   *
   *
   * <pre>
   * The protocol this BackendService uses to communicate with backends.
   * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
   * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
   *
   * @return Whether the protocol field is set.
   */
  @java.lang.Override
  public boolean hasProtocol() {
    return ((bitField0_ & 0x00200000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The protocol this BackendService uses to communicate with backends.
   * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
   * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
   *
   * @return The enum numeric value on the wire for protocol.
   */
  @java.lang.Override
  public int getProtocolValue() {
    return protocol_;
  }
  /**
   *
   *
   * <pre>
   * The protocol this BackendService uses to communicate with backends.
   * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
   * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
   *
   * @return The protocol.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendService.Protocol getProtocol() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.BackendService.Protocol result =
        com.google.cloud.compute.v1.BackendService.Protocol.valueOf(protocol_);
    return result == null
        ? com.google.cloud.compute.v1.BackendService.Protocol.UNRECOGNIZED
        : result;
  }

  public static final int REGION_FIELD_NUMBER = 138946292;
  private volatile java.lang.Object region_;
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return Whether the region field is set.
   */
  @java.lang.Override
  public boolean hasRegion() {
    return ((bitField0_ & 0x00400000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The region.
   */
  @java.lang.Override
  public java.lang.String getRegion() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      region_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The bytes for region.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getRegionBytes() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      region_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SECURITY_POLICY_FIELD_NUMBER = 171082513;
  private volatile java.lang.Object securityPolicy_;
  /**
   *
   *
   * <pre>
   * [Output Only] The resource URL for the security policy associated with this backend service.
   * </pre>
   *
   * <code>string security_policy = 171082513;</code>
   *
   * @return Whether the securityPolicy field is set.
   */
  @java.lang.Override
  public boolean hasSecurityPolicy() {
    return ((bitField0_ & 0x00800000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The resource URL for the security policy associated with this backend service.
   * </pre>
   *
   * <code>string security_policy = 171082513;</code>
   *
   * @return The securityPolicy.
   */
  @java.lang.Override
  public java.lang.String getSecurityPolicy() {
    java.lang.Object ref = securityPolicy_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      securityPolicy_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The resource URL for the security policy associated with this backend service.
   * </pre>
   *
   * <code>string security_policy = 171082513;</code>
   *
   * @return The bytes for securityPolicy.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getSecurityPolicyBytes() {
    java.lang.Object ref = securityPolicy_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      securityPolicy_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SECURITY_SETTINGS_FIELD_NUMBER = 478649922;
  private com.google.cloud.compute.v1.SecuritySettings securitySettings_;
  /**
   *
   *
   * <pre>
   * This field specifies the security policy that applies to this backend service. This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
   *
   * @return Whether the securitySettings field is set.
   */
  @java.lang.Override
  public boolean hasSecuritySettings() {
    return ((bitField0_ & 0x01000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field specifies the security policy that applies to this backend service. This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
   *
   * @return The securitySettings.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.SecuritySettings getSecuritySettings() {
    return securitySettings_ == null
        ? com.google.cloud.compute.v1.SecuritySettings.getDefaultInstance()
        : securitySettings_;
  }
  /**
   *
   *
   * <pre>
   * This field specifies the security policy that applies to this backend service. This field is applicable to either:
   * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
   * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.SecuritySettingsOrBuilder getSecuritySettingsOrBuilder() {
    return securitySettings_ == null
        ? com.google.cloud.compute.v1.SecuritySettings.getDefaultInstance()
        : securitySettings_;
  }

  public static final int SELF_LINK_FIELD_NUMBER = 456214797;
  private volatile java.lang.Object selfLink_;
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return Whether the selfLink field is set.
   */
  @java.lang.Override
  public boolean hasSelfLink() {
    return ((bitField0_ & 0x02000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The selfLink.
   */
  @java.lang.Override
  public java.lang.String getSelfLink() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      selfLink_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The bytes for selfLink.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getSelfLinkBytes() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      selfLink_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SESSION_AFFINITY_FIELD_NUMBER = 463888561;
  private int sessionAffinity_;
  /**
   *
   *
   * <pre>
   * Type of session affinity to use. The default is NONE.
   * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
   * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
   * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
   * </code>
   *
   * @return Whether the sessionAffinity field is set.
   */
  @java.lang.Override
  public boolean hasSessionAffinity() {
    return ((bitField0_ & 0x04000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Type of session affinity to use. The default is NONE.
   * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
   * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
   * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
   * </code>
   *
   * @return The enum numeric value on the wire for sessionAffinity.
   */
  @java.lang.Override
  public int getSessionAffinityValue() {
    return sessionAffinity_;
  }
  /**
   *
   *
   * <pre>
   * Type of session affinity to use. The default is NONE.
   * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
   * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
   * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
   * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
   * </code>
   *
   * @return The sessionAffinity.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.BackendService.SessionAffinity getSessionAffinity() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.BackendService.SessionAffinity result =
        com.google.cloud.compute.v1.BackendService.SessionAffinity.valueOf(sessionAffinity_);
    return result == null
        ? com.google.cloud.compute.v1.BackendService.SessionAffinity.UNRECOGNIZED
        : result;
  }

  public static final int TIMEOUT_SEC_FIELD_NUMBER = 79994995;
  private int timeoutSec_;
  /**
   *
   *
   * <pre>
   * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
   * </pre>
   *
   * <code>int32 timeout_sec = 79994995;</code>
   *
   * @return Whether the timeoutSec field is set.
   */
  @java.lang.Override
  public boolean hasTimeoutSec() {
    return ((bitField0_ & 0x08000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
   * </pre>
   *
   * <code>int32 timeout_sec = 79994995;</code>
   *
   * @return The timeoutSec.
   */
  @java.lang.Override
  public int getTimeoutSec() {
    return timeoutSec_;
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000800) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3355, id_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      output.writeMessage(104024, getIap());
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      output.writeMessage(905883, getConsistentHash());
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3292052, kind_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3373707, name_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      output.writeInt32(3446913, port_);
    }
    for (int i = 0; i < customRequestHeaders_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 27977992, customRequestHeaders_.getRaw(i));
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 41534345, portName_);
    }
    if (((bitField0_ & 0x08000000) != 0)) {
      output.writeInt32(79994995, timeoutSec_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      output.writeEnum(84577944, protocol_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      output.writeMessage(105658655, getFailoverPolicy());
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      output.writeEnum(131431487, localityLbPolicy_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 138946292, region_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 171082513, securityPolicy_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeMessage(213976452, getCdnPolicy());
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 232872494, network_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 234678500, fingerprint_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      output.writeBool(250733499, enableCDN_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      output.writeMessage(351299741, getLogConfig());
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      output.writeMessage(354625086, getOutlierDetection());
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      output.writeEnum(363890244, loadBalancingScheme_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeInt32(369996954, affinityCookieTtlSec_);
    }
    for (int i = 0; i < customResponseHeaders_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 387539094, customResponseHeaders_.getRaw(i));
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      output.writeMessage(421340061, getCircuitBreakers());
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 422937596, description_);
    }
    for (int i = 0; i < healthChecks_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 448370606, healthChecks_.getRaw(i));
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 456214797, selfLink_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      output.writeMessage(461096747, getConnectionDraining());
    }
    if (((bitField0_ & 0x04000000) != 0)) {
      output.writeEnum(463888561, sessionAffinity_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      output.writeMessage(478649922, getSecuritySettings());
    }
    for (int i = 0; i < backends_.size(); i++) {
      output.writeMessage(510839903, backends_.get(i));
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000800) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3355, id_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(104024, getIap());
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(905883, getConsistentHash());
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3292052, kind_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3373707, name_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(3446913, port_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < customRequestHeaders_.size(); i++) {
        dataSize += computeStringSizeNoTag(customRequestHeaders_.getRaw(i));
      }
      size += dataSize;
      size += 4 * getCustomRequestHeadersList().size();
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(41534345, portName_);
    }
    if (((bitField0_ & 0x08000000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(79994995, timeoutSec_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(84577944, protocol_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(105658655, getFailoverPolicy());
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(131431487, localityLbPolicy_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(138946292, region_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(171082513, securityPolicy_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(213976452, getCdnPolicy());
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(232872494, network_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(234678500, fingerprint_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(250733499, enableCDN_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(351299741, getLogConfig());
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              354625086, getOutlierDetection());
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeEnumSize(363890244, loadBalancingScheme_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(369996954, affinityCookieTtlSec_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < customResponseHeaders_.size(); i++) {
        dataSize += computeStringSizeNoTag(customResponseHeaders_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getCustomResponseHeadersList().size();
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(421340061, getCircuitBreakers());
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(422937596, description_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < healthChecks_.size(); i++) {
        dataSize += computeStringSizeNoTag(healthChecks_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getHealthChecksList().size();
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(456214797, selfLink_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              461096747, getConnectionDraining());
    }
    if (((bitField0_ & 0x04000000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(463888561, sessionAffinity_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              478649922, getSecuritySettings());
    }
    for (int i = 0; i < backends_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(510839903, backends_.get(i));
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.BackendService)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.BackendService other =
        (com.google.cloud.compute.v1.BackendService) obj;

    if (hasAffinityCookieTtlSec() != other.hasAffinityCookieTtlSec()) return false;
    if (hasAffinityCookieTtlSec()) {
      if (getAffinityCookieTtlSec() != other.getAffinityCookieTtlSec()) return false;
    }
    if (!getBackendsList().equals(other.getBackendsList())) return false;
    if (hasCdnPolicy() != other.hasCdnPolicy()) return false;
    if (hasCdnPolicy()) {
      if (!getCdnPolicy().equals(other.getCdnPolicy())) return false;
    }
    if (hasCircuitBreakers() != other.hasCircuitBreakers()) return false;
    if (hasCircuitBreakers()) {
      if (!getCircuitBreakers().equals(other.getCircuitBreakers())) return false;
    }
    if (hasConnectionDraining() != other.hasConnectionDraining()) return false;
    if (hasConnectionDraining()) {
      if (!getConnectionDraining().equals(other.getConnectionDraining())) return false;
    }
    if (hasConsistentHash() != other.hasConsistentHash()) return false;
    if (hasConsistentHash()) {
      if (!getConsistentHash().equals(other.getConsistentHash())) return false;
    }
    if (hasCreationTimestamp() != other.hasCreationTimestamp()) return false;
    if (hasCreationTimestamp()) {
      if (!getCreationTimestamp().equals(other.getCreationTimestamp())) return false;
    }
    if (!getCustomRequestHeadersList().equals(other.getCustomRequestHeadersList())) return false;
    if (!getCustomResponseHeadersList().equals(other.getCustomResponseHeadersList())) return false;
    if (hasDescription() != other.hasDescription()) return false;
    if (hasDescription()) {
      if (!getDescription().equals(other.getDescription())) return false;
    }
    if (hasEnableCDN() != other.hasEnableCDN()) return false;
    if (hasEnableCDN()) {
      if (getEnableCDN() != other.getEnableCDN()) return false;
    }
    if (hasFailoverPolicy() != other.hasFailoverPolicy()) return false;
    if (hasFailoverPolicy()) {
      if (!getFailoverPolicy().equals(other.getFailoverPolicy())) return false;
    }
    if (hasFingerprint() != other.hasFingerprint()) return false;
    if (hasFingerprint()) {
      if (!getFingerprint().equals(other.getFingerprint())) return false;
    }
    if (!getHealthChecksList().equals(other.getHealthChecksList())) return false;
    if (hasIap() != other.hasIap()) return false;
    if (hasIap()) {
      if (!getIap().equals(other.getIap())) return false;
    }
    if (hasId() != other.hasId()) return false;
    if (hasId()) {
      if (!getId().equals(other.getId())) return false;
    }
    if (hasKind() != other.hasKind()) return false;
    if (hasKind()) {
      if (!getKind().equals(other.getKind())) return false;
    }
    if (hasLoadBalancingScheme() != other.hasLoadBalancingScheme()) return false;
    if (hasLoadBalancingScheme()) {
      if (loadBalancingScheme_ != other.loadBalancingScheme_) return false;
    }
    if (hasLocalityLbPolicy() != other.hasLocalityLbPolicy()) return false;
    if (hasLocalityLbPolicy()) {
      if (localityLbPolicy_ != other.localityLbPolicy_) return false;
    }
    if (hasLogConfig() != other.hasLogConfig()) return false;
    if (hasLogConfig()) {
      if (!getLogConfig().equals(other.getLogConfig())) return false;
    }
    if (hasName() != other.hasName()) return false;
    if (hasName()) {
      if (!getName().equals(other.getName())) return false;
    }
    if (hasNetwork() != other.hasNetwork()) return false;
    if (hasNetwork()) {
      if (!getNetwork().equals(other.getNetwork())) return false;
    }
    if (hasOutlierDetection() != other.hasOutlierDetection()) return false;
    if (hasOutlierDetection()) {
      if (!getOutlierDetection().equals(other.getOutlierDetection())) return false;
    }
    if (hasPort() != other.hasPort()) return false;
    if (hasPort()) {
      if (getPort() != other.getPort()) return false;
    }
    if (hasPortName() != other.hasPortName()) return false;
    if (hasPortName()) {
      if (!getPortName().equals(other.getPortName())) return false;
    }
    if (hasProtocol() != other.hasProtocol()) return false;
    if (hasProtocol()) {
      if (protocol_ != other.protocol_) return false;
    }
    if (hasRegion() != other.hasRegion()) return false;
    if (hasRegion()) {
      if (!getRegion().equals(other.getRegion())) return false;
    }
    if (hasSecurityPolicy() != other.hasSecurityPolicy()) return false;
    if (hasSecurityPolicy()) {
      if (!getSecurityPolicy().equals(other.getSecurityPolicy())) return false;
    }
    if (hasSecuritySettings() != other.hasSecuritySettings()) return false;
    if (hasSecuritySettings()) {
      if (!getSecuritySettings().equals(other.getSecuritySettings())) return false;
    }
    if (hasSelfLink() != other.hasSelfLink()) return false;
    if (hasSelfLink()) {
      if (!getSelfLink().equals(other.getSelfLink())) return false;
    }
    if (hasSessionAffinity() != other.hasSessionAffinity()) return false;
    if (hasSessionAffinity()) {
      if (sessionAffinity_ != other.sessionAffinity_) return false;
    }
    if (hasTimeoutSec() != other.hasTimeoutSec()) return false;
    if (hasTimeoutSec()) {
      if (getTimeoutSec() != other.getTimeoutSec()) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasAffinityCookieTtlSec()) {
      hash = (37 * hash) + AFFINITY_COOKIE_TTL_SEC_FIELD_NUMBER;
      hash = (53 * hash) + getAffinityCookieTtlSec();
    }
    if (getBackendsCount() > 0) {
      hash = (37 * hash) + BACKENDS_FIELD_NUMBER;
      hash = (53 * hash) + getBackendsList().hashCode();
    }
    if (hasCdnPolicy()) {
      hash = (37 * hash) + CDN_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getCdnPolicy().hashCode();
    }
    if (hasCircuitBreakers()) {
      hash = (37 * hash) + CIRCUIT_BREAKERS_FIELD_NUMBER;
      hash = (53 * hash) + getCircuitBreakers().hashCode();
    }
    if (hasConnectionDraining()) {
      hash = (37 * hash) + CONNECTION_DRAINING_FIELD_NUMBER;
      hash = (53 * hash) + getConnectionDraining().hashCode();
    }
    if (hasConsistentHash()) {
      hash = (37 * hash) + CONSISTENT_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getConsistentHash().hashCode();
    }
    if (hasCreationTimestamp()) {
      hash = (37 * hash) + CREATION_TIMESTAMP_FIELD_NUMBER;
      hash = (53 * hash) + getCreationTimestamp().hashCode();
    }
    if (getCustomRequestHeadersCount() > 0) {
      hash = (37 * hash) + CUSTOM_REQUEST_HEADERS_FIELD_NUMBER;
      hash = (53 * hash) + getCustomRequestHeadersList().hashCode();
    }
    if (getCustomResponseHeadersCount() > 0) {
      hash = (37 * hash) + CUSTOM_RESPONSE_HEADERS_FIELD_NUMBER;
      hash = (53 * hash) + getCustomResponseHeadersList().hashCode();
    }
    if (hasDescription()) {
      hash = (37 * hash) + DESCRIPTION_FIELD_NUMBER;
      hash = (53 * hash) + getDescription().hashCode();
    }
    if (hasEnableCDN()) {
      hash = (37 * hash) + ENABLE_C_D_N_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getEnableCDN());
    }
    if (hasFailoverPolicy()) {
      hash = (37 * hash) + FAILOVER_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getFailoverPolicy().hashCode();
    }
    if (hasFingerprint()) {
      hash = (37 * hash) + FINGERPRINT_FIELD_NUMBER;
      hash = (53 * hash) + getFingerprint().hashCode();
    }
    if (getHealthChecksCount() > 0) {
      hash = (37 * hash) + HEALTH_CHECKS_FIELD_NUMBER;
      hash = (53 * hash) + getHealthChecksList().hashCode();
    }
    if (hasIap()) {
      hash = (37 * hash) + IAP_FIELD_NUMBER;
      hash = (53 * hash) + getIap().hashCode();
    }
    if (hasId()) {
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
    }
    if (hasKind()) {
      hash = (37 * hash) + KIND_FIELD_NUMBER;
      hash = (53 * hash) + getKind().hashCode();
    }
    if (hasLoadBalancingScheme()) {
      hash = (37 * hash) + LOAD_BALANCING_SCHEME_FIELD_NUMBER;
      hash = (53 * hash) + loadBalancingScheme_;
    }
    if (hasLocalityLbPolicy()) {
      hash = (37 * hash) + LOCALITY_LB_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + localityLbPolicy_;
    }
    if (hasLogConfig()) {
      hash = (37 * hash) + LOG_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getLogConfig().hashCode();
    }
    if (hasName()) {
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
    }
    if (hasNetwork()) {
      hash = (37 * hash) + NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getNetwork().hashCode();
    }
    if (hasOutlierDetection()) {
      hash = (37 * hash) + OUTLIER_DETECTION_FIELD_NUMBER;
      hash = (53 * hash) + getOutlierDetection().hashCode();
    }
    if (hasPort()) {
      hash = (37 * hash) + PORT_FIELD_NUMBER;
      hash = (53 * hash) + getPort();
    }
    if (hasPortName()) {
      hash = (37 * hash) + PORT_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getPortName().hashCode();
    }
    if (hasProtocol()) {
      hash = (37 * hash) + PROTOCOL_FIELD_NUMBER;
      hash = (53 * hash) + protocol_;
    }
    if (hasRegion()) {
      hash = (37 * hash) + REGION_FIELD_NUMBER;
      hash = (53 * hash) + getRegion().hashCode();
    }
    if (hasSecurityPolicy()) {
      hash = (37 * hash) + SECURITY_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getSecurityPolicy().hashCode();
    }
    if (hasSecuritySettings()) {
      hash = (37 * hash) + SECURITY_SETTINGS_FIELD_NUMBER;
      hash = (53 * hash) + getSecuritySettings().hashCode();
    }
    if (hasSelfLink()) {
      hash = (37 * hash) + SELF_LINK_FIELD_NUMBER;
      hash = (53 * hash) + getSelfLink().hashCode();
    }
    if (hasSessionAffinity()) {
      hash = (37 * hash) + SESSION_AFFINITY_FIELD_NUMBER;
      hash = (53 * hash) + sessionAffinity_;
    }
    if (hasTimeoutSec()) {
      hash = (37 * hash) + TIMEOUT_SEC_FIELD_NUMBER;
      hash = (53 * hash) + getTimeoutSec();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.BackendService parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.BackendService parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.BackendService parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.BackendService prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Represents a Backend Service resource.
   * A backend service defines how Google Cloud load balancers distribute traffic. The backend service configuration contains a set of values, such as the protocol used to connect to backends, various distribution and session settings, health checks, and timeouts. These settings provide fine-grained control over how your load balancer behaves. Most of the settings have default values that allow for easy configuration if you need to get started quickly.
   * Backend services in Google Compute Engine can be either regionally or globally scoped.
   * * [Global](/compute/docs/reference/rest/{$api_version}/backendServices) * [Regional](/compute/docs/reference/rest/{$api_version}/regionBackendServices)
   * For more information, see Backend Services.
   * (== resource_for {$api_version}.backendService ==)
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.BackendService}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.BackendService)
      com.google.cloud.compute.v1.BackendServiceOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_BackendService_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_BackendService_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.BackendService.class,
              com.google.cloud.compute.v1.BackendService.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.BackendService.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getBackendsFieldBuilder();
        getCdnPolicyFieldBuilder();
        getCircuitBreakersFieldBuilder();
        getConnectionDrainingFieldBuilder();
        getConsistentHashFieldBuilder();
        getFailoverPolicyFieldBuilder();
        getIapFieldBuilder();
        getLogConfigFieldBuilder();
        getOutlierDetectionFieldBuilder();
        getSecuritySettingsFieldBuilder();
      }
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      affinityCookieTtlSec_ = 0;
      bitField0_ = (bitField0_ & ~0x00000001);
      if (backendsBuilder_ == null) {
        backends_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
      } else {
        backendsBuilder_.clear();
      }
      if (cdnPolicyBuilder_ == null) {
        cdnPolicy_ = null;
      } else {
        cdnPolicyBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000004);
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
      } else {
        circuitBreakersBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000008);
      if (connectionDrainingBuilder_ == null) {
        connectionDraining_ = null;
      } else {
        connectionDrainingBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000010);
      if (consistentHashBuilder_ == null) {
        consistentHash_ = null;
      } else {
        consistentHashBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000020);
      creationTimestamp_ = "";
      bitField0_ = (bitField0_ & ~0x00000040);
      customRequestHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000080);
      customResponseHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000100);
      description_ = "";
      bitField0_ = (bitField0_ & ~0x00000200);
      enableCDN_ = false;
      bitField0_ = (bitField0_ & ~0x00000400);
      if (failoverPolicyBuilder_ == null) {
        failoverPolicy_ = null;
      } else {
        failoverPolicyBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000800);
      fingerprint_ = "";
      bitField0_ = (bitField0_ & ~0x00001000);
      healthChecks_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00002000);
      if (iapBuilder_ == null) {
        iap_ = null;
      } else {
        iapBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00004000);
      id_ = "";
      bitField0_ = (bitField0_ & ~0x00008000);
      kind_ = "";
      bitField0_ = (bitField0_ & ~0x00010000);
      loadBalancingScheme_ = 0;
      bitField0_ = (bitField0_ & ~0x00020000);
      localityLbPolicy_ = 0;
      bitField0_ = (bitField0_ & ~0x00040000);
      if (logConfigBuilder_ == null) {
        logConfig_ = null;
      } else {
        logConfigBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00080000);
      name_ = "";
      bitField0_ = (bitField0_ & ~0x00100000);
      network_ = "";
      bitField0_ = (bitField0_ & ~0x00200000);
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
      } else {
        outlierDetectionBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00400000);
      port_ = 0;
      bitField0_ = (bitField0_ & ~0x00800000);
      portName_ = "";
      bitField0_ = (bitField0_ & ~0x01000000);
      protocol_ = 0;
      bitField0_ = (bitField0_ & ~0x02000000);
      region_ = "";
      bitField0_ = (bitField0_ & ~0x04000000);
      securityPolicy_ = "";
      bitField0_ = (bitField0_ & ~0x08000000);
      if (securitySettingsBuilder_ == null) {
        securitySettings_ = null;
      } else {
        securitySettingsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x10000000);
      selfLink_ = "";
      bitField0_ = (bitField0_ & ~0x20000000);
      sessionAffinity_ = 0;
      bitField0_ = (bitField0_ & ~0x40000000);
      timeoutSec_ = 0;
      bitField0_ = (bitField0_ & ~0x80000000);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_BackendService_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.BackendService.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService build() {
      com.google.cloud.compute.v1.BackendService result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService buildPartial() {
      com.google.cloud.compute.v1.BackendService result =
          new com.google.cloud.compute.v1.BackendService(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.affinityCookieTtlSec_ = affinityCookieTtlSec_;
        to_bitField0_ |= 0x00000001;
      }
      if (backendsBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0)) {
          backends_ = java.util.Collections.unmodifiableList(backends_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.backends_ = backends_;
      } else {
        result.backends_ = backendsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        if (cdnPolicyBuilder_ == null) {
          result.cdnPolicy_ = cdnPolicy_;
        } else {
          result.cdnPolicy_ = cdnPolicyBuilder_.build();
        }
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        if (circuitBreakersBuilder_ == null) {
          result.circuitBreakers_ = circuitBreakers_;
        } else {
          result.circuitBreakers_ = circuitBreakersBuilder_.build();
        }
        to_bitField0_ |= 0x00000004;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        if (connectionDrainingBuilder_ == null) {
          result.connectionDraining_ = connectionDraining_;
        } else {
          result.connectionDraining_ = connectionDrainingBuilder_.build();
        }
        to_bitField0_ |= 0x00000008;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        if (consistentHashBuilder_ == null) {
          result.consistentHash_ = consistentHash_;
        } else {
          result.consistentHash_ = consistentHashBuilder_.build();
        }
        to_bitField0_ |= 0x00000010;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        to_bitField0_ |= 0x00000020;
      }
      result.creationTimestamp_ = creationTimestamp_;
      if (((bitField0_ & 0x00000080) != 0)) {
        customRequestHeaders_ = customRequestHeaders_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000080);
      }
      result.customRequestHeaders_ = customRequestHeaders_;
      if (((bitField0_ & 0x00000100) != 0)) {
        customResponseHeaders_ = customResponseHeaders_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000100);
      }
      result.customResponseHeaders_ = customResponseHeaders_;
      if (((from_bitField0_ & 0x00000200) != 0)) {
        to_bitField0_ |= 0x00000040;
      }
      result.description_ = description_;
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.enableCDN_ = enableCDN_;
        to_bitField0_ |= 0x00000080;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        if (failoverPolicyBuilder_ == null) {
          result.failoverPolicy_ = failoverPolicy_;
        } else {
          result.failoverPolicy_ = failoverPolicyBuilder_.build();
        }
        to_bitField0_ |= 0x00000100;
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        to_bitField0_ |= 0x00000200;
      }
      result.fingerprint_ = fingerprint_;
      if (((bitField0_ & 0x00002000) != 0)) {
        healthChecks_ = healthChecks_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00002000);
      }
      result.healthChecks_ = healthChecks_;
      if (((from_bitField0_ & 0x00004000) != 0)) {
        if (iapBuilder_ == null) {
          result.iap_ = iap_;
        } else {
          result.iap_ = iapBuilder_.build();
        }
        to_bitField0_ |= 0x00000400;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        to_bitField0_ |= 0x00000800;
      }
      result.id_ = id_;
      if (((from_bitField0_ & 0x00010000) != 0)) {
        to_bitField0_ |= 0x00001000;
      }
      result.kind_ = kind_;
      if (((from_bitField0_ & 0x00020000) != 0)) {
        to_bitField0_ |= 0x00002000;
      }
      result.loadBalancingScheme_ = loadBalancingScheme_;
      if (((from_bitField0_ & 0x00040000) != 0)) {
        to_bitField0_ |= 0x00004000;
      }
      result.localityLbPolicy_ = localityLbPolicy_;
      if (((from_bitField0_ & 0x00080000) != 0)) {
        if (logConfigBuilder_ == null) {
          result.logConfig_ = logConfig_;
        } else {
          result.logConfig_ = logConfigBuilder_.build();
        }
        to_bitField0_ |= 0x00008000;
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        to_bitField0_ |= 0x00010000;
      }
      result.name_ = name_;
      if (((from_bitField0_ & 0x00200000) != 0)) {
        to_bitField0_ |= 0x00020000;
      }
      result.network_ = network_;
      if (((from_bitField0_ & 0x00400000) != 0)) {
        if (outlierDetectionBuilder_ == null) {
          result.outlierDetection_ = outlierDetection_;
        } else {
          result.outlierDetection_ = outlierDetectionBuilder_.build();
        }
        to_bitField0_ |= 0x00040000;
      }
      if (((from_bitField0_ & 0x00800000) != 0)) {
        result.port_ = port_;
        to_bitField0_ |= 0x00080000;
      }
      if (((from_bitField0_ & 0x01000000) != 0)) {
        to_bitField0_ |= 0x00100000;
      }
      result.portName_ = portName_;
      if (((from_bitField0_ & 0x02000000) != 0)) {
        to_bitField0_ |= 0x00200000;
      }
      result.protocol_ = protocol_;
      if (((from_bitField0_ & 0x04000000) != 0)) {
        to_bitField0_ |= 0x00400000;
      }
      result.region_ = region_;
      if (((from_bitField0_ & 0x08000000) != 0)) {
        to_bitField0_ |= 0x00800000;
      }
      result.securityPolicy_ = securityPolicy_;
      if (((from_bitField0_ & 0x10000000) != 0)) {
        if (securitySettingsBuilder_ == null) {
          result.securitySettings_ = securitySettings_;
        } else {
          result.securitySettings_ = securitySettingsBuilder_.build();
        }
        to_bitField0_ |= 0x01000000;
      }
      if (((from_bitField0_ & 0x20000000) != 0)) {
        to_bitField0_ |= 0x02000000;
      }
      result.selfLink_ = selfLink_;
      if (((from_bitField0_ & 0x40000000) != 0)) {
        to_bitField0_ |= 0x04000000;
      }
      result.sessionAffinity_ = sessionAffinity_;
      if (((from_bitField0_ & 0x80000000) != 0)) {
        result.timeoutSec_ = timeoutSec_;
        to_bitField0_ |= 0x08000000;
      }
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.BackendService) {
        return mergeFrom((com.google.cloud.compute.v1.BackendService) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.BackendService other) {
      if (other == com.google.cloud.compute.v1.BackendService.getDefaultInstance()) return this;
      if (other.hasAffinityCookieTtlSec()) {
        setAffinityCookieTtlSec(other.getAffinityCookieTtlSec());
      }
      if (backendsBuilder_ == null) {
        if (!other.backends_.isEmpty()) {
          if (backends_.isEmpty()) {
            backends_ = other.backends_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureBackendsIsMutable();
            backends_.addAll(other.backends_);
          }
          onChanged();
        }
      } else {
        if (!other.backends_.isEmpty()) {
          if (backendsBuilder_.isEmpty()) {
            backendsBuilder_.dispose();
            backendsBuilder_ = null;
            backends_ = other.backends_;
            bitField0_ = (bitField0_ & ~0x00000002);
            backendsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getBackendsFieldBuilder()
                    : null;
          } else {
            backendsBuilder_.addAllMessages(other.backends_);
          }
        }
      }
      if (other.hasCdnPolicy()) {
        mergeCdnPolicy(other.getCdnPolicy());
      }
      if (other.hasCircuitBreakers()) {
        mergeCircuitBreakers(other.getCircuitBreakers());
      }
      if (other.hasConnectionDraining()) {
        mergeConnectionDraining(other.getConnectionDraining());
      }
      if (other.hasConsistentHash()) {
        mergeConsistentHash(other.getConsistentHash());
      }
      if (other.hasCreationTimestamp()) {
        bitField0_ |= 0x00000040;
        creationTimestamp_ = other.creationTimestamp_;
        onChanged();
      }
      if (!other.customRequestHeaders_.isEmpty()) {
        if (customRequestHeaders_.isEmpty()) {
          customRequestHeaders_ = other.customRequestHeaders_;
          bitField0_ = (bitField0_ & ~0x00000080);
        } else {
          ensureCustomRequestHeadersIsMutable();
          customRequestHeaders_.addAll(other.customRequestHeaders_);
        }
        onChanged();
      }
      if (!other.customResponseHeaders_.isEmpty()) {
        if (customResponseHeaders_.isEmpty()) {
          customResponseHeaders_ = other.customResponseHeaders_;
          bitField0_ = (bitField0_ & ~0x00000100);
        } else {
          ensureCustomResponseHeadersIsMutable();
          customResponseHeaders_.addAll(other.customResponseHeaders_);
        }
        onChanged();
      }
      if (other.hasDescription()) {
        bitField0_ |= 0x00000200;
        description_ = other.description_;
        onChanged();
      }
      if (other.hasEnableCDN()) {
        setEnableCDN(other.getEnableCDN());
      }
      if (other.hasFailoverPolicy()) {
        mergeFailoverPolicy(other.getFailoverPolicy());
      }
      if (other.hasFingerprint()) {
        bitField0_ |= 0x00001000;
        fingerprint_ = other.fingerprint_;
        onChanged();
      }
      if (!other.healthChecks_.isEmpty()) {
        if (healthChecks_.isEmpty()) {
          healthChecks_ = other.healthChecks_;
          bitField0_ = (bitField0_ & ~0x00002000);
        } else {
          ensureHealthChecksIsMutable();
          healthChecks_.addAll(other.healthChecks_);
        }
        onChanged();
      }
      if (other.hasIap()) {
        mergeIap(other.getIap());
      }
      if (other.hasId()) {
        bitField0_ |= 0x00008000;
        id_ = other.id_;
        onChanged();
      }
      if (other.hasKind()) {
        bitField0_ |= 0x00010000;
        kind_ = other.kind_;
        onChanged();
      }
      if (other.hasLoadBalancingScheme()) {
        setLoadBalancingScheme(other.getLoadBalancingScheme());
      }
      if (other.hasLocalityLbPolicy()) {
        setLocalityLbPolicy(other.getLocalityLbPolicy());
      }
      if (other.hasLogConfig()) {
        mergeLogConfig(other.getLogConfig());
      }
      if (other.hasName()) {
        bitField0_ |= 0x00100000;
        name_ = other.name_;
        onChanged();
      }
      if (other.hasNetwork()) {
        bitField0_ |= 0x00200000;
        network_ = other.network_;
        onChanged();
      }
      if (other.hasOutlierDetection()) {
        mergeOutlierDetection(other.getOutlierDetection());
      }
      if (other.hasPort()) {
        setPort(other.getPort());
      }
      if (other.hasPortName()) {
        bitField0_ |= 0x01000000;
        portName_ = other.portName_;
        onChanged();
      }
      if (other.hasProtocol()) {
        setProtocol(other.getProtocol());
      }
      if (other.hasRegion()) {
        bitField0_ |= 0x04000000;
        region_ = other.region_;
        onChanged();
      }
      if (other.hasSecurityPolicy()) {
        bitField0_ |= 0x08000000;
        securityPolicy_ = other.securityPolicy_;
        onChanged();
      }
      if (other.hasSecuritySettings()) {
        mergeSecuritySettings(other.getSecuritySettings());
      }
      if (other.hasSelfLink()) {
        bitField0_ |= 0x20000000;
        selfLink_ = other.selfLink_;
        onChanged();
      }
      if (other.hasSessionAffinity()) {
        setSessionAffinity(other.getSessionAffinity());
      }
      if (other.hasTimeoutSec()) {
        setTimeoutSec(other.getTimeoutSec());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.BackendService parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.cloud.compute.v1.BackendService) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int bitField0_;

    private int affinityCookieTtlSec_;
    /**
     *
     *
     * <pre>
     * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
     * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
     *
     * @return Whether the affinityCookieTtlSec field is set.
     */
    @java.lang.Override
    public boolean hasAffinityCookieTtlSec() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     *
     *
     * <pre>
     * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
     * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
     *
     * @return The affinityCookieTtlSec.
     */
    @java.lang.Override
    public int getAffinityCookieTtlSec() {
      return affinityCookieTtlSec_;
    }
    /**
     *
     *
     * <pre>
     * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
     * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
     *
     * @param value The affinityCookieTtlSec to set.
     * @return This builder for chaining.
     */
    public Builder setAffinityCookieTtlSec(int value) {
      bitField0_ |= 0x00000001;
      affinityCookieTtlSec_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
     * If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is one day (86,400).
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>int32 affinity_cookie_ttl_sec = 369996954;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAffinityCookieTtlSec() {
      bitField0_ = (bitField0_ & ~0x00000001);
      affinityCookieTtlSec_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<com.google.cloud.compute.v1.Backend> backends_ =
        java.util.Collections.emptyList();

    private void ensureBackendsIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        backends_ = new java.util.ArrayList<com.google.cloud.compute.v1.Backend>(backends_);
        bitField0_ |= 0x00000002;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.Backend,
            com.google.cloud.compute.v1.Backend.Builder,
            com.google.cloud.compute.v1.BackendOrBuilder>
        backendsBuilder_;

    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public java.util.List<com.google.cloud.compute.v1.Backend> getBackendsList() {
      if (backendsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(backends_);
      } else {
        return backendsBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public int getBackendsCount() {
      if (backendsBuilder_ == null) {
        return backends_.size();
      } else {
        return backendsBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public com.google.cloud.compute.v1.Backend getBackends(int index) {
      if (backendsBuilder_ == null) {
        return backends_.get(index);
      } else {
        return backendsBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder setBackends(int index, com.google.cloud.compute.v1.Backend value) {
      if (backendsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureBackendsIsMutable();
        backends_.set(index, value);
        onChanged();
      } else {
        backendsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder setBackends(
        int index, com.google.cloud.compute.v1.Backend.Builder builderForValue) {
      if (backendsBuilder_ == null) {
        ensureBackendsIsMutable();
        backends_.set(index, builderForValue.build());
        onChanged();
      } else {
        backendsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder addBackends(com.google.cloud.compute.v1.Backend value) {
      if (backendsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureBackendsIsMutable();
        backends_.add(value);
        onChanged();
      } else {
        backendsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder addBackends(int index, com.google.cloud.compute.v1.Backend value) {
      if (backendsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureBackendsIsMutable();
        backends_.add(index, value);
        onChanged();
      } else {
        backendsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder addBackends(com.google.cloud.compute.v1.Backend.Builder builderForValue) {
      if (backendsBuilder_ == null) {
        ensureBackendsIsMutable();
        backends_.add(builderForValue.build());
        onChanged();
      } else {
        backendsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder addBackends(
        int index, com.google.cloud.compute.v1.Backend.Builder builderForValue) {
      if (backendsBuilder_ == null) {
        ensureBackendsIsMutable();
        backends_.add(index, builderForValue.build());
        onChanged();
      } else {
        backendsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder addAllBackends(
        java.lang.Iterable<? extends com.google.cloud.compute.v1.Backend> values) {
      if (backendsBuilder_ == null) {
        ensureBackendsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, backends_);
        onChanged();
      } else {
        backendsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder clearBackends() {
      if (backendsBuilder_ == null) {
        backends_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
      } else {
        backendsBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public Builder removeBackends(int index) {
      if (backendsBuilder_ == null) {
        ensureBackendsIsMutable();
        backends_.remove(index);
        onChanged();
      } else {
        backendsBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public com.google.cloud.compute.v1.Backend.Builder getBackendsBuilder(int index) {
      return getBackendsFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public com.google.cloud.compute.v1.BackendOrBuilder getBackendsOrBuilder(int index) {
      if (backendsBuilder_ == null) {
        return backends_.get(index);
      } else {
        return backendsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public java.util.List<? extends com.google.cloud.compute.v1.BackendOrBuilder>
        getBackendsOrBuilderList() {
      if (backendsBuilder_ != null) {
        return backendsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(backends_);
      }
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public com.google.cloud.compute.v1.Backend.Builder addBackendsBuilder() {
      return getBackendsFieldBuilder()
          .addBuilder(com.google.cloud.compute.v1.Backend.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public com.google.cloud.compute.v1.Backend.Builder addBackendsBuilder(int index) {
      return getBackendsFieldBuilder()
          .addBuilder(index, com.google.cloud.compute.v1.Backend.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * The list of backends that serve this BackendService.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.Backend backends = 510839903;</code>
     */
    public java.util.List<com.google.cloud.compute.v1.Backend.Builder> getBackendsBuilderList() {
      return getBackendsFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.Backend,
            com.google.cloud.compute.v1.Backend.Builder,
            com.google.cloud.compute.v1.BackendOrBuilder>
        getBackendsFieldBuilder() {
      if (backendsBuilder_ == null) {
        backendsBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.cloud.compute.v1.Backend,
                com.google.cloud.compute.v1.Backend.Builder,
                com.google.cloud.compute.v1.BackendOrBuilder>(
                backends_, ((bitField0_ & 0x00000002) != 0), getParentForChildren(), isClean());
        backends_ = null;
      }
      return backendsBuilder_;
    }

    private com.google.cloud.compute.v1.BackendServiceCdnPolicy cdnPolicy_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceCdnPolicy,
            com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder,
            com.google.cloud.compute.v1.BackendServiceCdnPolicyOrBuilder>
        cdnPolicyBuilder_;
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     *
     * @return Whether the cdnPolicy field is set.
     */
    public boolean hasCdnPolicy() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     *
     * @return The cdnPolicy.
     */
    public com.google.cloud.compute.v1.BackendServiceCdnPolicy getCdnPolicy() {
      if (cdnPolicyBuilder_ == null) {
        return cdnPolicy_ == null
            ? com.google.cloud.compute.v1.BackendServiceCdnPolicy.getDefaultInstance()
            : cdnPolicy_;
      } else {
        return cdnPolicyBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public Builder setCdnPolicy(com.google.cloud.compute.v1.BackendServiceCdnPolicy value) {
      if (cdnPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        cdnPolicy_ = value;
        onChanged();
      } else {
        cdnPolicyBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public Builder setCdnPolicy(
        com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder builderForValue) {
      if (cdnPolicyBuilder_ == null) {
        cdnPolicy_ = builderForValue.build();
        onChanged();
      } else {
        cdnPolicyBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public Builder mergeCdnPolicy(com.google.cloud.compute.v1.BackendServiceCdnPolicy value) {
      if (cdnPolicyBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)
            && cdnPolicy_ != null
            && cdnPolicy_
                != com.google.cloud.compute.v1.BackendServiceCdnPolicy.getDefaultInstance()) {
          cdnPolicy_ =
              com.google.cloud.compute.v1.BackendServiceCdnPolicy.newBuilder(cdnPolicy_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          cdnPolicy_ = value;
        }
        onChanged();
      } else {
        cdnPolicyBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000004;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public Builder clearCdnPolicy() {
      if (cdnPolicyBuilder_ == null) {
        cdnPolicy_ = null;
        onChanged();
      } else {
        cdnPolicyBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000004);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder getCdnPolicyBuilder() {
      bitField0_ |= 0x00000004;
      onChanged();
      return getCdnPolicyFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceCdnPolicyOrBuilder getCdnPolicyOrBuilder() {
      if (cdnPolicyBuilder_ != null) {
        return cdnPolicyBuilder_.getMessageOrBuilder();
      } else {
        return cdnPolicy_ == null
            ? com.google.cloud.compute.v1.BackendServiceCdnPolicy.getDefaultInstance()
            : cdnPolicy_;
      }
    }
    /**
     *
     *
     * <pre>
     * Cloud CDN configuration for this BackendService. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceCdnPolicy cdn_policy = 213976452;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceCdnPolicy,
            com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder,
            com.google.cloud.compute.v1.BackendServiceCdnPolicyOrBuilder>
        getCdnPolicyFieldBuilder() {
      if (cdnPolicyBuilder_ == null) {
        cdnPolicyBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.BackendServiceCdnPolicy,
                com.google.cloud.compute.v1.BackendServiceCdnPolicy.Builder,
                com.google.cloud.compute.v1.BackendServiceCdnPolicyOrBuilder>(
                getCdnPolicy(), getParentForChildren(), isClean());
        cdnPolicy_ = null;
      }
      return cdnPolicyBuilder_;
    }

    private com.google.cloud.compute.v1.CircuitBreakers circuitBreakers_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.CircuitBreakers,
            com.google.cloud.compute.v1.CircuitBreakers.Builder,
            com.google.cloud.compute.v1.CircuitBreakersOrBuilder>
        circuitBreakersBuilder_;
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     *
     * @return Whether the circuitBreakers field is set.
     */
    public boolean hasCircuitBreakers() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     *
     * @return The circuitBreakers.
     */
    public com.google.cloud.compute.v1.CircuitBreakers getCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        return circuitBreakers_ == null
            ? com.google.cloud.compute.v1.CircuitBreakers.getDefaultInstance()
            : circuitBreakers_;
      } else {
        return circuitBreakersBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public Builder setCircuitBreakers(com.google.cloud.compute.v1.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        circuitBreakers_ = value;
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000008;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public Builder setCircuitBreakers(
        com.google.cloud.compute.v1.CircuitBreakers.Builder builderForValue) {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = builderForValue.build();
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000008;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public Builder mergeCircuitBreakers(com.google.cloud.compute.v1.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (((bitField0_ & 0x00000008) != 0)
            && circuitBreakers_ != null
            && circuitBreakers_
                != com.google.cloud.compute.v1.CircuitBreakers.getDefaultInstance()) {
          circuitBreakers_ =
              com.google.cloud.compute.v1.CircuitBreakers.newBuilder(circuitBreakers_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          circuitBreakers_ = value;
        }
        onChanged();
      } else {
        circuitBreakersBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000008;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public Builder clearCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
        onChanged();
      } else {
        circuitBreakersBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000008);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public com.google.cloud.compute.v1.CircuitBreakers.Builder getCircuitBreakersBuilder() {
      bitField0_ |= 0x00000008;
      onChanged();
      return getCircuitBreakersFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    public com.google.cloud.compute.v1.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
      if (circuitBreakersBuilder_ != null) {
        return circuitBreakersBuilder_.getMessageOrBuilder();
      } else {
        return circuitBreakers_ == null
            ? com.google.cloud.compute.v1.CircuitBreakers.getDefaultInstance()
            : circuitBreakers_;
      }
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the volume of connections to a backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.CircuitBreakers circuit_breakers = 421340061;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.CircuitBreakers,
            com.google.cloud.compute.v1.CircuitBreakers.Builder,
            com.google.cloud.compute.v1.CircuitBreakersOrBuilder>
        getCircuitBreakersFieldBuilder() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakersBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.CircuitBreakers,
                com.google.cloud.compute.v1.CircuitBreakers.Builder,
                com.google.cloud.compute.v1.CircuitBreakersOrBuilder>(
                getCircuitBreakers(), getParentForChildren(), isClean());
        circuitBreakers_ = null;
      }
      return circuitBreakersBuilder_;
    }

    private com.google.cloud.compute.v1.ConnectionDraining connectionDraining_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.ConnectionDraining,
            com.google.cloud.compute.v1.ConnectionDraining.Builder,
            com.google.cloud.compute.v1.ConnectionDrainingOrBuilder>
        connectionDrainingBuilder_;
    /**
     * <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code>
     *
     * @return Whether the connectionDraining field is set.
     */
    public boolean hasConnectionDraining() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code>
     *
     * @return The connectionDraining.
     */
    public com.google.cloud.compute.v1.ConnectionDraining getConnectionDraining() {
      if (connectionDrainingBuilder_ == null) {
        return connectionDraining_ == null
            ? com.google.cloud.compute.v1.ConnectionDraining.getDefaultInstance()
            : connectionDraining_;
      } else {
        return connectionDrainingBuilder_.getMessage();
      }
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public Builder setConnectionDraining(com.google.cloud.compute.v1.ConnectionDraining value) {
      if (connectionDrainingBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        connectionDraining_ = value;
        onChanged();
      } else {
        connectionDrainingBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000010;
      return this;
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public Builder setConnectionDraining(
        com.google.cloud.compute.v1.ConnectionDraining.Builder builderForValue) {
      if (connectionDrainingBuilder_ == null) {
        connectionDraining_ = builderForValue.build();
        onChanged();
      } else {
        connectionDrainingBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000010;
      return this;
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public Builder mergeConnectionDraining(com.google.cloud.compute.v1.ConnectionDraining value) {
      if (connectionDrainingBuilder_ == null) {
        if (((bitField0_ & 0x00000010) != 0)
            && connectionDraining_ != null
            && connectionDraining_
                != com.google.cloud.compute.v1.ConnectionDraining.getDefaultInstance()) {
          connectionDraining_ =
              com.google.cloud.compute.v1.ConnectionDraining.newBuilder(connectionDraining_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          connectionDraining_ = value;
        }
        onChanged();
      } else {
        connectionDrainingBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000010;
      return this;
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public Builder clearConnectionDraining() {
      if (connectionDrainingBuilder_ == null) {
        connectionDraining_ = null;
        onChanged();
      } else {
        connectionDrainingBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000010);
      return this;
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public com.google.cloud.compute.v1.ConnectionDraining.Builder getConnectionDrainingBuilder() {
      bitField0_ |= 0x00000010;
      onChanged();
      return getConnectionDrainingFieldBuilder().getBuilder();
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    public com.google.cloud.compute.v1.ConnectionDrainingOrBuilder
        getConnectionDrainingOrBuilder() {
      if (connectionDrainingBuilder_ != null) {
        return connectionDrainingBuilder_.getMessageOrBuilder();
      } else {
        return connectionDraining_ == null
            ? com.google.cloud.compute.v1.ConnectionDraining.getDefaultInstance()
            : connectionDraining_;
      }
    }
    /** <code>.google.cloud.compute.v1.ConnectionDraining connection_draining = 461096747;</code> */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.ConnectionDraining,
            com.google.cloud.compute.v1.ConnectionDraining.Builder,
            com.google.cloud.compute.v1.ConnectionDrainingOrBuilder>
        getConnectionDrainingFieldBuilder() {
      if (connectionDrainingBuilder_ == null) {
        connectionDrainingBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.ConnectionDraining,
                com.google.cloud.compute.v1.ConnectionDraining.Builder,
                com.google.cloud.compute.v1.ConnectionDrainingOrBuilder>(
                getConnectionDraining(), getParentForChildren(), isClean());
        connectionDraining_ = null;
      }
      return connectionDrainingBuilder_;
    }

    private com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistentHash_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings,
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder,
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettingsOrBuilder>
        consistentHashBuilder_;
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     *
     * @return Whether the consistentHash field is set.
     */
    public boolean hasConsistentHash() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     *
     * @return The consistentHash.
     */
    public com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings getConsistentHash() {
      if (consistentHashBuilder_ == null) {
        return consistentHash_ == null
            ? com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.getDefaultInstance()
            : consistentHash_;
      } else {
        return consistentHashBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public Builder setConsistentHash(
        com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings value) {
      if (consistentHashBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        consistentHash_ = value;
        onChanged();
      } else {
        consistentHashBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000020;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public Builder setConsistentHash(
        com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder builderForValue) {
      if (consistentHashBuilder_ == null) {
        consistentHash_ = builderForValue.build();
        onChanged();
      } else {
        consistentHashBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000020;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public Builder mergeConsistentHash(
        com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings value) {
      if (consistentHashBuilder_ == null) {
        if (((bitField0_ & 0x00000020) != 0)
            && consistentHash_ != null
            && consistentHash_
                != com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings
                    .getDefaultInstance()) {
          consistentHash_ =
              com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.newBuilder(
                      consistentHash_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          consistentHash_ = value;
        }
        onChanged();
      } else {
        consistentHashBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000020;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public Builder clearConsistentHash() {
      if (consistentHashBuilder_ == null) {
        consistentHash_ = null;
        onChanged();
      } else {
        consistentHashBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000020);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder
        getConsistentHashBuilder() {
      bitField0_ |= 0x00000020;
      onChanged();
      return getConsistentHashFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    public com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettingsOrBuilder
        getConsistentHashOrBuilder() {
      if (consistentHashBuilder_ != null) {
        return consistentHashBuilder_.getMessageOrBuilder();
      } else {
        return consistentHash_ == null
            ? com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.getDefaultInstance()
            : consistentHash_;
      }
    }
    /**
     *
     *
     * <pre>
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular destination host will be lost when one or more hosts are added/removed from the destination service. This field specifies parameters that control consistent hashing. This field is only applicable when localityLbPolicy is set to MAGLEV or RING_HASH.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings consistent_hash = 905883;
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings,
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder,
            com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettingsOrBuilder>
        getConsistentHashFieldBuilder() {
      if (consistentHashBuilder_ == null) {
        consistentHashBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings,
                com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettings.Builder,
                com.google.cloud.compute.v1.ConsistentHashLoadBalancerSettingsOrBuilder>(
                getConsistentHash(), getParentForChildren(), isClean());
        consistentHash_ = null;
      }
      return consistentHashBuilder_;
    }

    private java.lang.Object creationTimestamp_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return Whether the creationTimestamp field is set.
     */
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The creationTimestamp.
     */
    public java.lang.String getCreationTimestamp() {
      java.lang.Object ref = creationTimestamp_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        creationTimestamp_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The bytes for creationTimestamp.
     */
    public com.google.protobuf.ByteString getCreationTimestampBytes() {
      java.lang.Object ref = creationTimestamp_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        creationTimestamp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestamp(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000040;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000040);
      creationTimestamp_ = getDefaultInstance().getCreationTimestamp();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The bytes for creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestampBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000040;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList customRequestHeaders_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensureCustomRequestHeadersIsMutable() {
      if (!((bitField0_ & 0x00000080) != 0)) {
        customRequestHeaders_ = new com.google.protobuf.LazyStringArrayList(customRequestHeaders_);
        bitField0_ |= 0x00000080;
      }
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @return A list containing the customRequestHeaders.
     */
    public com.google.protobuf.ProtocolStringList getCustomRequestHeadersList() {
      return customRequestHeaders_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @return The count of customRequestHeaders.
     */
    public int getCustomRequestHeadersCount() {
      return customRequestHeaders_.size();
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param index The index of the element to return.
     * @return The customRequestHeaders at the given index.
     */
    public java.lang.String getCustomRequestHeaders(int index) {
      return customRequestHeaders_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the customRequestHeaders at the given index.
     */
    public com.google.protobuf.ByteString getCustomRequestHeadersBytes(int index) {
      return customRequestHeaders_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param index The index to set the value at.
     * @param value The customRequestHeaders to set.
     * @return This builder for chaining.
     */
    public Builder setCustomRequestHeaders(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCustomRequestHeadersIsMutable();
      customRequestHeaders_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param value The customRequestHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addCustomRequestHeaders(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCustomRequestHeadersIsMutable();
      customRequestHeaders_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param values The customRequestHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addAllCustomRequestHeaders(java.lang.Iterable<java.lang.String> values) {
      ensureCustomRequestHeadersIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, customRequestHeaders_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCustomRequestHeaders() {
      customRequestHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000080);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied requests.
     * </pre>
     *
     * <code>repeated string custom_request_headers = 27977992;</code>
     *
     * @param value The bytes of the customRequestHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addCustomRequestHeadersBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureCustomRequestHeadersIsMutable();
      customRequestHeaders_.add(value);
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList customResponseHeaders_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensureCustomResponseHeadersIsMutable() {
      if (!((bitField0_ & 0x00000100) != 0)) {
        customResponseHeaders_ =
            new com.google.protobuf.LazyStringArrayList(customResponseHeaders_);
        bitField0_ |= 0x00000100;
      }
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @return A list containing the customResponseHeaders.
     */
    public com.google.protobuf.ProtocolStringList getCustomResponseHeadersList() {
      return customResponseHeaders_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @return The count of customResponseHeaders.
     */
    public int getCustomResponseHeadersCount() {
      return customResponseHeaders_.size();
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param index The index of the element to return.
     * @return The customResponseHeaders at the given index.
     */
    public java.lang.String getCustomResponseHeaders(int index) {
      return customResponseHeaders_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the customResponseHeaders at the given index.
     */
    public com.google.protobuf.ByteString getCustomResponseHeadersBytes(int index) {
      return customResponseHeaders_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param index The index to set the value at.
     * @param value The customResponseHeaders to set.
     * @return This builder for chaining.
     */
    public Builder setCustomResponseHeaders(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCustomResponseHeadersIsMutable();
      customResponseHeaders_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param value The customResponseHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addCustomResponseHeaders(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCustomResponseHeadersIsMutable();
      customResponseHeaders_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param values The customResponseHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addAllCustomResponseHeaders(java.lang.Iterable<java.lang.String> values) {
      ensureCustomResponseHeadersIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, customResponseHeaders_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCustomResponseHeaders() {
      customResponseHeaders_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000100);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Headers that the HTTP/S load balancer should add to proxied responses.
     * </pre>
     *
     * <code>repeated string custom_response_headers = 387539094;</code>
     *
     * @param value The bytes of the customResponseHeaders to add.
     * @return This builder for chaining.
     */
    public Builder addCustomResponseHeadersBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureCustomResponseHeadersIsMutable();
      customResponseHeaders_.add(value);
      onChanged();
      return this;
    }

    private java.lang.Object description_ = "";
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return Whether the description field is set.
     */
    public boolean hasDescription() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The description.
     */
    public java.lang.String getDescription() {
      java.lang.Object ref = description_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        description_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The bytes for description.
     */
    public com.google.protobuf.ByteString getDescriptionBytes() {
      java.lang.Object ref = description_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The description to set.
     * @return This builder for chaining.
     */
    public Builder setDescription(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000200;
      description_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearDescription() {
      bitField0_ = (bitField0_ & ~0x00000200);
      description_ = getDefaultInstance().getDescription();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The bytes for description to set.
     * @return This builder for chaining.
     */
    public Builder setDescriptionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000200;
      description_ = value;
      onChanged();
      return this;
    }

    private boolean enableCDN_;
    /**
     *
     *
     * <pre>
     * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
     * </pre>
     *
     * <code>bool enable_c_d_n = 250733499;</code>
     *
     * @return Whether the enableCDN field is set.
     */
    @java.lang.Override
    public boolean hasEnableCDN() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     *
     *
     * <pre>
     * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
     * </pre>
     *
     * <code>bool enable_c_d_n = 250733499;</code>
     *
     * @return The enableCDN.
     */
    @java.lang.Override
    public boolean getEnableCDN() {
      return enableCDN_;
    }
    /**
     *
     *
     * <pre>
     * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
     * </pre>
     *
     * <code>bool enable_c_d_n = 250733499;</code>
     *
     * @param value The enableCDN to set.
     * @return This builder for chaining.
     */
    public Builder setEnableCDN(boolean value) {
      bitField0_ |= 0x00000400;
      enableCDN_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * If true, enables Cloud CDN for the backend service. Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
     * </pre>
     *
     * <code>bool enable_c_d_n = 250733499;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEnableCDN() {
      bitField0_ = (bitField0_ & ~0x00000400);
      enableCDN_ = false;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.BackendServiceFailoverPolicy failoverPolicy_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceFailoverPolicy,
            com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder,
            com.google.cloud.compute.v1.BackendServiceFailoverPolicyOrBuilder>
        failoverPolicyBuilder_;
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     *
     * @return Whether the failoverPolicy field is set.
     */
    public boolean hasFailoverPolicy() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     *
     * @return The failoverPolicy.
     */
    public com.google.cloud.compute.v1.BackendServiceFailoverPolicy getFailoverPolicy() {
      if (failoverPolicyBuilder_ == null) {
        return failoverPolicy_ == null
            ? com.google.cloud.compute.v1.BackendServiceFailoverPolicy.getDefaultInstance()
            : failoverPolicy_;
      } else {
        return failoverPolicyBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public Builder setFailoverPolicy(
        com.google.cloud.compute.v1.BackendServiceFailoverPolicy value) {
      if (failoverPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        failoverPolicy_ = value;
        onChanged();
      } else {
        failoverPolicyBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000800;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public Builder setFailoverPolicy(
        com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder builderForValue) {
      if (failoverPolicyBuilder_ == null) {
        failoverPolicy_ = builderForValue.build();
        onChanged();
      } else {
        failoverPolicyBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000800;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public Builder mergeFailoverPolicy(
        com.google.cloud.compute.v1.BackendServiceFailoverPolicy value) {
      if (failoverPolicyBuilder_ == null) {
        if (((bitField0_ & 0x00000800) != 0)
            && failoverPolicy_ != null
            && failoverPolicy_
                != com.google.cloud.compute.v1.BackendServiceFailoverPolicy.getDefaultInstance()) {
          failoverPolicy_ =
              com.google.cloud.compute.v1.BackendServiceFailoverPolicy.newBuilder(failoverPolicy_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          failoverPolicy_ = value;
        }
        onChanged();
      } else {
        failoverPolicyBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000800;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public Builder clearFailoverPolicy() {
      if (failoverPolicyBuilder_ == null) {
        failoverPolicy_ = null;
        onChanged();
      } else {
        failoverPolicyBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000800);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder
        getFailoverPolicyBuilder() {
      bitField0_ |= 0x00000800;
      onChanged();
      return getFailoverPolicyFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    public com.google.cloud.compute.v1.BackendServiceFailoverPolicyOrBuilder
        getFailoverPolicyOrBuilder() {
      if (failoverPolicyBuilder_ != null) {
        return failoverPolicyBuilder_.getMessageOrBuilder();
      } else {
        return failoverPolicy_ == null
            ? com.google.cloud.compute.v1.BackendServiceFailoverPolicy.getDefaultInstance()
            : failoverPolicy_;
      }
    }
    /**
     *
     *
     * <pre>
     * Applicable only to Failover for Internal TCP/UDP Load Balancing and Network Load Balancing. Requires at least one backend instance group to be defined as a backup (failover) backend.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceFailoverPolicy failover_policy = 105658655;
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceFailoverPolicy,
            com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder,
            com.google.cloud.compute.v1.BackendServiceFailoverPolicyOrBuilder>
        getFailoverPolicyFieldBuilder() {
      if (failoverPolicyBuilder_ == null) {
        failoverPolicyBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.BackendServiceFailoverPolicy,
                com.google.cloud.compute.v1.BackendServiceFailoverPolicy.Builder,
                com.google.cloud.compute.v1.BackendServiceFailoverPolicyOrBuilder>(
                getFailoverPolicy(), getParentForChildren(), isClean());
        failoverPolicy_ = null;
      }
      return failoverPolicyBuilder_;
    }

    private java.lang.Object fingerprint_ = "";
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return Whether the fingerprint field is set.
     */
    public boolean hasFingerprint() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return The fingerprint.
     */
    public java.lang.String getFingerprint() {
      java.lang.Object ref = fingerprint_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        fingerprint_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return The bytes for fingerprint.
     */
    public com.google.protobuf.ByteString getFingerprintBytes() {
      java.lang.Object ref = fingerprint_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        fingerprint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @param value The fingerprint to set.
     * @return This builder for chaining.
     */
    public Builder setFingerprint(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00001000;
      fingerprint_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearFingerprint() {
      bitField0_ = (bitField0_ & ~0x00001000);
      fingerprint_ = getDefaultInstance().getFingerprint();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet.
     * To see the latest fingerprint, make a get() request to retrieve a BackendService.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @param value The bytes for fingerprint to set.
     * @return This builder for chaining.
     */
    public Builder setFingerprintBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00001000;
      fingerprint_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList healthChecks_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensureHealthChecksIsMutable() {
      if (!((bitField0_ & 0x00002000) != 0)) {
        healthChecks_ = new com.google.protobuf.LazyStringArrayList(healthChecks_);
        bitField0_ |= 0x00002000;
      }
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @return A list containing the healthChecks.
     */
    public com.google.protobuf.ProtocolStringList getHealthChecksList() {
      return healthChecks_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @return The count of healthChecks.
     */
    public int getHealthChecksCount() {
      return healthChecks_.size();
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param index The index of the element to return.
     * @return The healthChecks at the given index.
     */
    public java.lang.String getHealthChecks(int index) {
      return healthChecks_.get(index);
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the healthChecks at the given index.
     */
    public com.google.protobuf.ByteString getHealthChecksBytes(int index) {
      return healthChecks_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param index The index to set the value at.
     * @param value The healthChecks to set.
     * @return This builder for chaining.
     */
    public Builder setHealthChecks(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureHealthChecksIsMutable();
      healthChecks_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param value The healthChecks to add.
     * @return This builder for chaining.
     */
    public Builder addHealthChecks(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureHealthChecksIsMutable();
      healthChecks_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param values The healthChecks to add.
     * @return This builder for chaining.
     */
    public Builder addAllHealthChecks(java.lang.Iterable<java.lang.String> values) {
      ensureHealthChecksIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, healthChecks_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearHealthChecks() {
      healthChecks_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See  Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
     * </pre>
     *
     * <code>repeated string health_checks = 448370606;</code>
     *
     * @param value The bytes of the healthChecks to add.
     * @return This builder for chaining.
     */
    public Builder addHealthChecksBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureHealthChecksIsMutable();
      healthChecks_.add(value);
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.BackendServiceIAP iap_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceIAP,
            com.google.cloud.compute.v1.BackendServiceIAP.Builder,
            com.google.cloud.compute.v1.BackendServiceIAPOrBuilder>
        iapBuilder_;
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     *
     * @return Whether the iap field is set.
     */
    public boolean hasIap() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     *
     * @return The iap.
     */
    public com.google.cloud.compute.v1.BackendServiceIAP getIap() {
      if (iapBuilder_ == null) {
        return iap_ == null
            ? com.google.cloud.compute.v1.BackendServiceIAP.getDefaultInstance()
            : iap_;
      } else {
        return iapBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public Builder setIap(com.google.cloud.compute.v1.BackendServiceIAP value) {
      if (iapBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        iap_ = value;
        onChanged();
      } else {
        iapBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00004000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public Builder setIap(com.google.cloud.compute.v1.BackendServiceIAP.Builder builderForValue) {
      if (iapBuilder_ == null) {
        iap_ = builderForValue.build();
        onChanged();
      } else {
        iapBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00004000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public Builder mergeIap(com.google.cloud.compute.v1.BackendServiceIAP value) {
      if (iapBuilder_ == null) {
        if (((bitField0_ & 0x00004000) != 0)
            && iap_ != null
            && iap_ != com.google.cloud.compute.v1.BackendServiceIAP.getDefaultInstance()) {
          iap_ =
              com.google.cloud.compute.v1.BackendServiceIAP.newBuilder(iap_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          iap_ = value;
        }
        onChanged();
      } else {
        iapBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00004000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public Builder clearIap() {
      if (iapBuilder_ == null) {
        iap_ = null;
        onChanged();
      } else {
        iapBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00004000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceIAP.Builder getIapBuilder() {
      bitField0_ |= 0x00004000;
      onChanged();
      return getIapFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceIAPOrBuilder getIapOrBuilder() {
      if (iapBuilder_ != null) {
        return iapBuilder_.getMessageOrBuilder();
      } else {
        return iap_ == null
            ? com.google.cloud.compute.v1.BackendServiceIAP.getDefaultInstance()
            : iap_;
      }
    }
    /**
     *
     *
     * <pre>
     * The configurations for Identity-Aware Proxy on this resource. Not available for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceIAP iap = 104024;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceIAP,
            com.google.cloud.compute.v1.BackendServiceIAP.Builder,
            com.google.cloud.compute.v1.BackendServiceIAPOrBuilder>
        getIapFieldBuilder() {
      if (iapBuilder_ == null) {
        iapBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.BackendServiceIAP,
                com.google.cloud.compute.v1.BackendServiceIAP.Builder,
                com.google.cloud.compute.v1.BackendServiceIAPOrBuilder>(
                getIap(), getParentForChildren(), isClean());
        iap_ = null;
      }
      return iapBuilder_;
    }

    private java.lang.Object id_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return Whether the id field is set.
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The id.
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The bytes for id.
     */
    public com.google.protobuf.ByteString getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The id to set.
     * @return This builder for chaining.
     */
    public Builder setId(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00008000;
      id_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearId() {
      bitField0_ = (bitField0_ & ~0x00008000);
      id_ = getDefaultInstance().getId();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The bytes for id to set.
     * @return This builder for chaining.
     */
    public Builder setIdBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00008000;
      id_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object kind_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return Whether the kind field is set.
     */
    public boolean hasKind() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The kind.
     */
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        kind_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The bytes for kind.
     */
    public com.google.protobuf.ByteString getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The kind to set.
     * @return This builder for chaining.
     */
    public Builder setKind(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00010000;
      kind_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearKind() {
      bitField0_ = (bitField0_ & ~0x00010000);
      kind_ = getDefaultInstance().getKind();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of resource. Always compute#backendService for backend services.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The bytes for kind to set.
     * @return This builder for chaining.
     */
    public Builder setKindBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00010000;
      kind_ = value;
      onChanged();
      return this;
    }

    private int loadBalancingScheme_ = 0;
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return Whether the loadBalancingScheme field is set.
     */
    @java.lang.Override
    public boolean hasLoadBalancingScheme() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return The enum numeric value on the wire for loadBalancingScheme.
     */
    @java.lang.Override
    public int getLoadBalancingSchemeValue() {
      return loadBalancingScheme_;
    }
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @param value The enum numeric value on the wire for loadBalancingScheme to set.
     * @return This builder for chaining.
     */
    public Builder setLoadBalancingSchemeValue(int value) {
      bitField0_ |= 0x00020000;
      loadBalancingScheme_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return The loadBalancingScheme.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService.LoadBalancingScheme getLoadBalancingScheme() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.BackendService.LoadBalancingScheme result =
          com.google.cloud.compute.v1.BackendService.LoadBalancingScheme.valueOf(
              loadBalancingScheme_);
      return result == null
          ? com.google.cloud.compute.v1.BackendService.LoadBalancingScheme.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @param value The loadBalancingScheme to set.
     * @return This builder for chaining.
     */
    public Builder setLoadBalancingScheme(
        com.google.cloud.compute.v1.BackendService.LoadBalancingScheme value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00020000;
      loadBalancingScheme_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearLoadBalancingScheme() {
      bitField0_ = (bitField0_ & ~0x00020000);
      loadBalancingScheme_ = 0;
      onChanged();
      return this;
    }

    private int localityLbPolicy_ = 0;
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @return Whether the localityLbPolicy field is set.
     */
    @java.lang.Override
    public boolean hasLocalityLbPolicy() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @return The enum numeric value on the wire for localityLbPolicy.
     */
    @java.lang.Override
    public int getLocalityLbPolicyValue() {
      return localityLbPolicy_;
    }
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @param value The enum numeric value on the wire for localityLbPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setLocalityLbPolicyValue(int value) {
      bitField0_ |= 0x00040000;
      localityLbPolicy_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @return The localityLbPolicy.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService.LocalityLbPolicy getLocalityLbPolicy() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.BackendService.LocalityLbPolicy result =
          com.google.cloud.compute.v1.BackendService.LocalityLbPolicy.valueOf(localityLbPolicy_);
      return result == null
          ? com.google.cloud.compute.v1.BackendService.LocalityLbPolicy.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @param value The localityLbPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setLocalityLbPolicy(
        com.google.cloud.compute.v1.BackendService.LocalityLbPolicy value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00040000;
      localityLbPolicy_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The load balancing algorithm used within the scope of the locality. The possible values are:
     * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
     * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
     * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
     * - RANDOM: The load balancer selects a random healthy host.
     * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
     * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
     * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.BackendService.LocalityLbPolicy locality_lb_policy = 131431487;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearLocalityLbPolicy() {
      bitField0_ = (bitField0_ & ~0x00040000);
      localityLbPolicy_ = 0;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.BackendServiceLogConfig logConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceLogConfig,
            com.google.cloud.compute.v1.BackendServiceLogConfig.Builder,
            com.google.cloud.compute.v1.BackendServiceLogConfigOrBuilder>
        logConfigBuilder_;
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     *
     * @return Whether the logConfig field is set.
     */
    public boolean hasLogConfig() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     *
     * @return The logConfig.
     */
    public com.google.cloud.compute.v1.BackendServiceLogConfig getLogConfig() {
      if (logConfigBuilder_ == null) {
        return logConfig_ == null
            ? com.google.cloud.compute.v1.BackendServiceLogConfig.getDefaultInstance()
            : logConfig_;
      } else {
        return logConfigBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public Builder setLogConfig(com.google.cloud.compute.v1.BackendServiceLogConfig value) {
      if (logConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        logConfig_ = value;
        onChanged();
      } else {
        logConfigBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00080000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public Builder setLogConfig(
        com.google.cloud.compute.v1.BackendServiceLogConfig.Builder builderForValue) {
      if (logConfigBuilder_ == null) {
        logConfig_ = builderForValue.build();
        onChanged();
      } else {
        logConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00080000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public Builder mergeLogConfig(com.google.cloud.compute.v1.BackendServiceLogConfig value) {
      if (logConfigBuilder_ == null) {
        if (((bitField0_ & 0x00080000) != 0)
            && logConfig_ != null
            && logConfig_
                != com.google.cloud.compute.v1.BackendServiceLogConfig.getDefaultInstance()) {
          logConfig_ =
              com.google.cloud.compute.v1.BackendServiceLogConfig.newBuilder(logConfig_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          logConfig_ = value;
        }
        onChanged();
      } else {
        logConfigBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00080000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public Builder clearLogConfig() {
      if (logConfigBuilder_ == null) {
        logConfig_ = null;
        onChanged();
      } else {
        logConfigBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00080000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceLogConfig.Builder getLogConfigBuilder() {
      bitField0_ |= 0x00080000;
      onChanged();
      return getLogConfigFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    public com.google.cloud.compute.v1.BackendServiceLogConfigOrBuilder getLogConfigOrBuilder() {
      if (logConfigBuilder_ != null) {
        return logConfigBuilder_.getMessageOrBuilder();
      } else {
        return logConfig_ == null
            ? com.google.cloud.compute.v1.BackendServiceLogConfig.getDefaultInstance()
            : logConfig_;
      }
    }
    /**
     *
     *
     * <pre>
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is enabled, logs will be exported to Stackdriver.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendServiceLogConfig log_config = 351299741;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.BackendServiceLogConfig,
            com.google.cloud.compute.v1.BackendServiceLogConfig.Builder,
            com.google.cloud.compute.v1.BackendServiceLogConfigOrBuilder>
        getLogConfigFieldBuilder() {
      if (logConfigBuilder_ == null) {
        logConfigBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.BackendServiceLogConfig,
                com.google.cloud.compute.v1.BackendServiceLogConfig.Builder,
                com.google.cloud.compute.v1.BackendServiceLogConfigOrBuilder>(
                getLogConfig(), getParentForChildren(), isClean());
        logConfig_ = null;
      }
      return logConfigBuilder_;
    }

    private java.lang.Object name_ = "";
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return Whether the name field is set.
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00100000;
      name_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearName() {
      bitField0_ = (bitField0_ & ~0x00100000);
      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00100000;
      name_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object network_ = "";
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return Whether the network field is set.
     */
    public boolean hasNetwork() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The network.
     */
    public java.lang.String getNetwork() {
      java.lang.Object ref = network_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        network_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The bytes for network.
     */
    public com.google.protobuf.ByteString getNetworkBytes() {
      java.lang.Object ref = network_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        network_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The network to set.
     * @return This builder for chaining.
     */
    public Builder setNetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00200000;
      network_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearNetwork() {
      bitField0_ = (bitField0_ & ~0x00200000);
      network_ = getDefaultInstance().getNetwork();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The bytes for network to set.
     * @return This builder for chaining.
     */
    public Builder setNetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00200000;
      network_ = value;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.OutlierDetection outlierDetection_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.OutlierDetection,
            com.google.cloud.compute.v1.OutlierDetection.Builder,
            com.google.cloud.compute.v1.OutlierDetectionOrBuilder>
        outlierDetectionBuilder_;
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     *
     * @return Whether the outlierDetection field is set.
     */
    public boolean hasOutlierDetection() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     *
     * @return The outlierDetection.
     */
    public com.google.cloud.compute.v1.OutlierDetection getOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        return outlierDetection_ == null
            ? com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()
            : outlierDetection_;
      } else {
        return outlierDetectionBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public Builder setOutlierDetection(com.google.cloud.compute.v1.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        outlierDetection_ = value;
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00400000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public Builder setOutlierDetection(
        com.google.cloud.compute.v1.OutlierDetection.Builder builderForValue) {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = builderForValue.build();
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00400000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public Builder mergeOutlierDetection(com.google.cloud.compute.v1.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (((bitField0_ & 0x00400000) != 0)
            && outlierDetection_ != null
            && outlierDetection_
                != com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()) {
          outlierDetection_ =
              com.google.cloud.compute.v1.OutlierDetection.newBuilder(outlierDetection_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          outlierDetection_ = value;
        }
        onChanged();
      } else {
        outlierDetectionBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00400000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public Builder clearOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
        onChanged();
      } else {
        outlierDetectionBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00400000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public com.google.cloud.compute.v1.OutlierDetection.Builder getOutlierDetectionBuilder() {
      bitField0_ |= 0x00400000;
      onChanged();
      return getOutlierDetectionFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    public com.google.cloud.compute.v1.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
      if (outlierDetectionBuilder_ != null) {
        return outlierDetectionBuilder_.getMessageOrBuilder();
      } else {
        return outlierDetection_ == null
            ? com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()
            : outlierDetection_;
      }
    }
    /**
     *
     *
     * <pre>
     * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service. If not set, this feature is considered disabled.
     * This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.OutlierDetection outlier_detection = 354625086;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.OutlierDetection,
            com.google.cloud.compute.v1.OutlierDetection.Builder,
            com.google.cloud.compute.v1.OutlierDetectionOrBuilder>
        getOutlierDetectionFieldBuilder() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetectionBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.OutlierDetection,
                com.google.cloud.compute.v1.OutlierDetection.Builder,
                com.google.cloud.compute.v1.OutlierDetectionOrBuilder>(
                getOutlierDetection(), getParentForChildren(), isClean());
        outlierDetection_ = null;
      }
      return outlierDetectionBuilder_;
    }

    private int port_;
    /**
     *
     *
     * <pre>
     * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
     * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
     * </pre>
     *
     * <code>int32 port = 3446913;</code>
     *
     * @return Whether the port field is set.
     */
    @java.lang.Override
    public boolean hasPort() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
     * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
     * </pre>
     *
     * <code>int32 port = 3446913;</code>
     *
     * @return The port.
     */
    @java.lang.Override
    public int getPort() {
      return port_;
    }
    /**
     *
     *
     * <pre>
     * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
     * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
     * </pre>
     *
     * <code>int32 port = 3446913;</code>
     *
     * @param value The port to set.
     * @return This builder for chaining.
     */
    public Builder setPort(int value) {
      bitField0_ |= 0x00800000;
      port_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80.
     * This cannot be used if the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
     * </pre>
     *
     * <code>int32 port = 3446913;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPort() {
      bitField0_ = (bitField0_ & ~0x00800000);
      port_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object portName_ = "";
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @return Whether the portName field is set.
     */
    public boolean hasPortName() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @return The portName.
     */
    public java.lang.String getPortName() {
      java.lang.Object ref = portName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        portName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @return The bytes for portName.
     */
    public com.google.protobuf.ByteString getPortNameBytes() {
      java.lang.Object ref = portName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        portName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @param value The portName to set.
     * @return This builder for chaining.
     */
    public Builder setPortName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x01000000;
      portName_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPortName() {
      bitField0_ = (bitField0_ & ~0x01000000);
      portName_ = getDefaultInstance().getPortName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * A named port on a backend instance group representing the port for communication to the backend VMs in that group. Required when the loadBalancingScheme is EXTERNAL (except Network Load Balancing), INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are instance groups. The named port must be defined on each backend instance group. This parameter has no meaning if the backends are NEGs.
     * Backend services for Internal TCP/UDP Load Balancing and Network Load Balancing require you omit port_name.
     * </pre>
     *
     * <code>string port_name = 41534345;</code>
     *
     * @param value The bytes for portName to set.
     * @return This builder for chaining.
     */
    public Builder setPortNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x01000000;
      portName_ = value;
      onChanged();
      return this;
    }

    private int protocol_ = 0;
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @return Whether the protocol field is set.
     */
    @java.lang.Override
    public boolean hasProtocol() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @return The enum numeric value on the wire for protocol.
     */
    @java.lang.Override
    public int getProtocolValue() {
      return protocol_;
    }
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @param value The enum numeric value on the wire for protocol to set.
     * @return This builder for chaining.
     */
    public Builder setProtocolValue(int value) {
      bitField0_ |= 0x02000000;
      protocol_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @return The protocol.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService.Protocol getProtocol() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.BackendService.Protocol result =
          com.google.cloud.compute.v1.BackendService.Protocol.valueOf(protocol_);
      return result == null
          ? com.google.cloud.compute.v1.BackendService.Protocol.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @param value The protocol to set.
     * @return This builder for chaining.
     */
    public Builder setProtocol(com.google.cloud.compute.v1.BackendService.Protocol value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x02000000;
      protocol_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The protocol this BackendService uses to communicate with backends.
     * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
     * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.Protocol protocol = 84577944;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearProtocol() {
      bitField0_ = (bitField0_ & ~0x02000000);
      protocol_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object region_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return Whether the region field is set.
     */
    public boolean hasRegion() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The region.
     */
    public java.lang.String getRegion() {
      java.lang.Object ref = region_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        region_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The bytes for region.
     */
    public com.google.protobuf.ByteString getRegionBytes() {
      java.lang.Object ref = region_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        region_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The region to set.
     * @return This builder for chaining.
     */
    public Builder setRegion(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x04000000;
      region_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearRegion() {
      bitField0_ = (bitField0_ & ~0x04000000);
      region_ = getDefaultInstance().getRegion();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The bytes for region to set.
     * @return This builder for chaining.
     */
    public Builder setRegionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x04000000;
      region_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object securityPolicy_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @return Whether the securityPolicy field is set.
     */
    public boolean hasSecurityPolicy() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @return The securityPolicy.
     */
    public java.lang.String getSecurityPolicy() {
      java.lang.Object ref = securityPolicy_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        securityPolicy_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @return The bytes for securityPolicy.
     */
    public com.google.protobuf.ByteString getSecurityPolicyBytes() {
      java.lang.Object ref = securityPolicy_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        securityPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @param value The securityPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setSecurityPolicy(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x08000000;
      securityPolicy_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSecurityPolicy() {
      bitField0_ = (bitField0_ & ~0x08000000);
      securityPolicy_ = getDefaultInstance().getSecurityPolicy();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The resource URL for the security policy associated with this backend service.
     * </pre>
     *
     * <code>string security_policy = 171082513;</code>
     *
     * @param value The bytes for securityPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setSecurityPolicyBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x08000000;
      securityPolicy_ = value;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.SecuritySettings securitySettings_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.SecuritySettings,
            com.google.cloud.compute.v1.SecuritySettings.Builder,
            com.google.cloud.compute.v1.SecuritySettingsOrBuilder>
        securitySettingsBuilder_;
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     *
     * @return Whether the securitySettings field is set.
     */
    public boolean hasSecuritySettings() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     *
     * @return The securitySettings.
     */
    public com.google.cloud.compute.v1.SecuritySettings getSecuritySettings() {
      if (securitySettingsBuilder_ == null) {
        return securitySettings_ == null
            ? com.google.cloud.compute.v1.SecuritySettings.getDefaultInstance()
            : securitySettings_;
      } else {
        return securitySettingsBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public Builder setSecuritySettings(com.google.cloud.compute.v1.SecuritySettings value) {
      if (securitySettingsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        securitySettings_ = value;
        onChanged();
      } else {
        securitySettingsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x10000000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public Builder setSecuritySettings(
        com.google.cloud.compute.v1.SecuritySettings.Builder builderForValue) {
      if (securitySettingsBuilder_ == null) {
        securitySettings_ = builderForValue.build();
        onChanged();
      } else {
        securitySettingsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x10000000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public Builder mergeSecuritySettings(com.google.cloud.compute.v1.SecuritySettings value) {
      if (securitySettingsBuilder_ == null) {
        if (((bitField0_ & 0x10000000) != 0)
            && securitySettings_ != null
            && securitySettings_
                != com.google.cloud.compute.v1.SecuritySettings.getDefaultInstance()) {
          securitySettings_ =
              com.google.cloud.compute.v1.SecuritySettings.newBuilder(securitySettings_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          securitySettings_ = value;
        }
        onChanged();
      } else {
        securitySettingsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x10000000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public Builder clearSecuritySettings() {
      if (securitySettingsBuilder_ == null) {
        securitySettings_ = null;
        onChanged();
      } else {
        securitySettingsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x10000000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public com.google.cloud.compute.v1.SecuritySettings.Builder getSecuritySettingsBuilder() {
      bitField0_ |= 0x10000000;
      onChanged();
      return getSecuritySettingsFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    public com.google.cloud.compute.v1.SecuritySettingsOrBuilder getSecuritySettingsOrBuilder() {
      if (securitySettingsBuilder_ != null) {
        return securitySettingsBuilder_.getMessageOrBuilder();
      } else {
        return securitySettings_ == null
            ? com.google.cloud.compute.v1.SecuritySettings.getDefaultInstance()
            : securitySettings_;
      }
    }
    /**
     *
     *
     * <pre>
     * This field specifies the security policy that applies to this backend service. This field is applicable to either:
     * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
     * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.SecuritySettings security_settings = 478649922;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.SecuritySettings,
            com.google.cloud.compute.v1.SecuritySettings.Builder,
            com.google.cloud.compute.v1.SecuritySettingsOrBuilder>
        getSecuritySettingsFieldBuilder() {
      if (securitySettingsBuilder_ == null) {
        securitySettingsBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.SecuritySettings,
                com.google.cloud.compute.v1.SecuritySettings.Builder,
                com.google.cloud.compute.v1.SecuritySettingsOrBuilder>(
                getSecuritySettings(), getParentForChildren(), isClean());
        securitySettings_ = null;
      }
      return securitySettingsBuilder_;
    }

    private java.lang.Object selfLink_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return Whether the selfLink field is set.
     */
    public boolean hasSelfLink() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The selfLink.
     */
    public java.lang.String getSelfLink() {
      java.lang.Object ref = selfLink_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        selfLink_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The bytes for selfLink.
     */
    public com.google.protobuf.ByteString getSelfLinkBytes() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        selfLink_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLink(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x20000000;
      selfLink_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSelfLink() {
      bitField0_ = (bitField0_ & ~0x20000000);
      selfLink_ = getDefaultInstance().getSelfLink();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The bytes for selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLinkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x20000000;
      selfLink_ = value;
      onChanged();
      return this;
    }

    private int sessionAffinity_ = 0;
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @return Whether the sessionAffinity field is set.
     */
    @java.lang.Override
    public boolean hasSessionAffinity() {
      return ((bitField0_ & 0x40000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @return The enum numeric value on the wire for sessionAffinity.
     */
    @java.lang.Override
    public int getSessionAffinityValue() {
      return sessionAffinity_;
    }
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @param value The enum numeric value on the wire for sessionAffinity to set.
     * @return This builder for chaining.
     */
    public Builder setSessionAffinityValue(int value) {
      bitField0_ |= 0x40000000;
      sessionAffinity_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @return The sessionAffinity.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.BackendService.SessionAffinity getSessionAffinity() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.BackendService.SessionAffinity result =
          com.google.cloud.compute.v1.BackendService.SessionAffinity.valueOf(sessionAffinity_);
      return result == null
          ? com.google.cloud.compute.v1.BackendService.SessionAffinity.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @param value The sessionAffinity to set.
     * @return This builder for chaining.
     */
    public Builder setSessionAffinity(
        com.google.cloud.compute.v1.BackendService.SessionAffinity value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x40000000;
      sessionAffinity_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Type of session affinity to use. The default is NONE.
     * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
     * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
     * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
     * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.BackendService.SessionAffinity session_affinity = 463888561;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSessionAffinity() {
      bitField0_ = (bitField0_ & ~0x40000000);
      sessionAffinity_ = 0;
      onChanged();
      return this;
    }

    private int timeoutSec_;
    /**
     *
     *
     * <pre>
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
     * </pre>
     *
     * <code>int32 timeout_sec = 79994995;</code>
     *
     * @return Whether the timeoutSec field is set.
     */
    @java.lang.Override
    public boolean hasTimeoutSec() {
      return ((bitField0_ & 0x80000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
     * </pre>
     *
     * <code>int32 timeout_sec = 79994995;</code>
     *
     * @return The timeoutSec.
     */
    @java.lang.Override
    public int getTimeoutSec() {
      return timeoutSec_;
    }
    /**
     *
     *
     * <pre>
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
     * </pre>
     *
     * <code>int32 timeout_sec = 79994995;</code>
     *
     * @param value The timeoutSec to set.
     * @return This builder for chaining.
     */
    public Builder setTimeoutSec(int value) {
      bitField0_ |= 0x80000000;
      timeoutSec_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,  Backend service settings The default is 30 seconds.
     * </pre>
     *
     * <code>int32 timeout_sec = 79994995;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTimeoutSec() {
      bitField0_ = (bitField0_ & ~0x80000000);
      timeoutSec_ = 0;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.BackendService)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.BackendService)
  private static final com.google.cloud.compute.v1.BackendService DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.BackendService();
  }

  public static com.google.cloud.compute.v1.BackendService getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<BackendService> PARSER =
      new com.google.protobuf.AbstractParser<BackendService>() {
        @java.lang.Override
        public BackendService parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new BackendService(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<BackendService> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<BackendService> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.BackendService getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
