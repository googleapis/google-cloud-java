/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * Represents an Interconnect Attachment (VLAN) resource.
 * You can use Interconnect attachments (VLANS) to connect your Virtual Private Cloud networks to your on-premises networks through an Interconnect. For more information, read  Creating VLAN Attachments. (== resource_for {$api_version}.interconnectAttachments ==)
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.InterconnectAttachment}
 */
public final class InterconnectAttachment extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.InterconnectAttachment)
    InterconnectAttachmentOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use InterconnectAttachment.newBuilder() to construct.
  private InterconnectAttachment(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private InterconnectAttachment() {
    bandwidth_ = 0;
    candidateSubnets_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    cloudRouterIpAddress_ = "";
    creationTimestamp_ = "";
    customerRouterIpAddress_ = "";
    description_ = "";
    edgeAvailabilityDomain_ = 0;
    encryption_ = 0;
    googleReferenceId_ = "";
    id_ = "";
    interconnect_ = "";
    ipsecInternalAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    kind_ = "";
    name_ = "";
    operationalStatus_ = 0;
    pairingKey_ = "";
    partnerAsn_ = "";
    region_ = "";
    router_ = "";
    selfLink_ = "";
    state_ = 0;
    type_ = 0;
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new InterconnectAttachment();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private InterconnectAttachment(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 26842:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000400;
              id_ = s;
              break;
            }
          case 867696:
            {
              bitField0_ |= 0x00002000;
              mtu_ = input.readInt32();
              break;
            }
          case 26336418:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00001000;
              kind_ = s;
              break;
            }
          case 26989658:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00004000;
              name_ = s;
              break;
            }
          case 28604880:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x01000000;
              type_ = rawValue;
              break;
            }
          case 244202930:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000008;
              creationTimestamp_ = s;
              break;
            }
          case 279360600:
            {
              bitField0_ |= 0x00000020;
              dataplaneVersion_ = input.readInt32();
              break;
            }
          case 527271474:
            {
              com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder subBuilder =
                  null;
              if (((bitField0_ & 0x00040000) != 0)) {
                subBuilder = partnerMetadata_.toBuilder();
              }
              partnerMetadata_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(partnerMetadata_);
                partnerMetadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00040000;
              break;
            }
          case 570316080:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00000080;
              edgeAvailabilityDomain_ = rawValue;
              break;
            }
          case 783842328:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00000100;
              encryption_ = rawValue;
              break;
            }
          case 878060680:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00800000;
              state_ = rawValue;
              break;
            }
          case 959422688:
            {
              bitField0_ |= 0x02000000;
              vlanTag8021Q_ = input.readInt32();
              break;
            }
          case 1111570338:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00100000;
              region_ = s;
              break;
            }
          case 1188870730:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00200000;
              router_ = s;
              break;
            }
          case 1453720968:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00000002;
              bandwidth_ = rawValue;
              break;
            }
          case 1608566776:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00008000;
              operationalStatus_ = rawValue;
              break;
            }
          case 1796809842:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000800;
              interconnect_ = s;
              break;
            }
          case 1898164250:
            {
              com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder subBuilder =
                  null;
              if (((bitField0_ & 0x00080000) != 0)) {
                subBuilder = privateInterconnectInfo_.toBuilder();
              }
              privateInterconnectInfo_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.parser(),
                      extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(privateInterconnectInfo_);
                privateInterconnectInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00080000;
              break;
            }
          case 1902743506:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                candidateSubnets_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              candidateSubnets_.add(s);
              break;
            }
          case -1995825086:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000004;
              cloudRouterIpAddress_ = s;
              break;
            }
          case -1635161206:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000010;
              customerRouterIpAddress_ = s;
              break;
            }
          case -1033778774:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00002000) != 0)) {
                ipsecInternalAddresses_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00002000;
              }
              ipsecInternalAddresses_.add(s);
              break;
            }
          case -911466526:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000040;
              description_ = s;
              break;
            }
          case -789638102:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00020000;
              partnerAsn_ = s;
              break;
            }
          case -777403582:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00010000;
              pairingKey_ = s;
              break;
            }
          case -729566584:
            {
              bitField0_ |= 0x00000001;
              adminEnabled_ = input.readBool();
              break;
            }
          case -645248918:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00400000;
              selfLink_ = s;
              break;
            }
          case -15411542:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000200;
              googleReferenceId_ = s;
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000004) != 0)) {
        candidateSubnets_ = candidateSubnets_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00002000) != 0)) {
        ipsecInternalAddresses_ = ipsecInternalAddresses_.getUnmodifiableView();
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_InterconnectAttachment_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_InterconnectAttachment_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.InterconnectAttachment.class,
            com.google.cloud.compute.v1.InterconnectAttachment.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
   * - BPS_50M: 50 Mbit/s
   * - BPS_100M: 100 Mbit/s
   * - BPS_200M: 200 Mbit/s
   * - BPS_300M: 300 Mbit/s
   * - BPS_400M: 400 Mbit/s
   * - BPS_500M: 500 Mbit/s
   * - BPS_1G: 1 Gbit/s
   * - BPS_2G: 2 Gbit/s
   * - BPS_5G: 5 Gbit/s
   * - BPS_10G: 10 Gbit/s
   * - BPS_20G: 20 Gbit/s
   * - BPS_50G: 50 Gbit/s
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.Bandwidth}
   */
  public enum Bandwidth implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_BANDWIDTH = 0;</code>
     */
    UNDEFINED_BANDWIDTH(0),
    /** <code>BPS_100M = 49547958;</code> */
    BPS_100M(49547958),
    /** <code>BPS_10G = 278693006;</code> */
    BPS_10G(278693006),
    /** <code>BPS_1G = 355358448;</code> */
    BPS_1G(355358448),
    /** <code>BPS_200M = 49577749;</code> */
    BPS_200M(49577749),
    /** <code>BPS_20G = 278693967;</code> */
    BPS_20G(278693967),
    /** <code>BPS_2G = 355358479;</code> */
    BPS_2G(355358479),
    /** <code>BPS_300M = 49607540;</code> */
    BPS_300M(49607540),
    /** <code>BPS_400M = 49637331;</code> */
    BPS_400M(49637331),
    /** <code>BPS_500M = 49667122;</code> */
    BPS_500M(49667122),
    /** <code>BPS_50G = 278696850;</code> */
    BPS_50G(278696850),
    /** <code>BPS_50M = 278696856;</code> */
    BPS_50M(278696856),
    /** <code>BPS_5G = 355358572;</code> */
    BPS_5G(355358572),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_BANDWIDTH = 0;</code>
     */
    public static final int UNDEFINED_BANDWIDTH_VALUE = 0;
    /** <code>BPS_100M = 49547958;</code> */
    public static final int BPS_100M_VALUE = 49547958;
    /** <code>BPS_10G = 278693006;</code> */
    public static final int BPS_10G_VALUE = 278693006;
    /** <code>BPS_1G = 355358448;</code> */
    public static final int BPS_1G_VALUE = 355358448;
    /** <code>BPS_200M = 49577749;</code> */
    public static final int BPS_200M_VALUE = 49577749;
    /** <code>BPS_20G = 278693967;</code> */
    public static final int BPS_20G_VALUE = 278693967;
    /** <code>BPS_2G = 355358479;</code> */
    public static final int BPS_2G_VALUE = 355358479;
    /** <code>BPS_300M = 49607540;</code> */
    public static final int BPS_300M_VALUE = 49607540;
    /** <code>BPS_400M = 49637331;</code> */
    public static final int BPS_400M_VALUE = 49637331;
    /** <code>BPS_500M = 49667122;</code> */
    public static final int BPS_500M_VALUE = 49667122;
    /** <code>BPS_50G = 278696850;</code> */
    public static final int BPS_50G_VALUE = 278696850;
    /** <code>BPS_50M = 278696856;</code> */
    public static final int BPS_50M_VALUE = 278696856;
    /** <code>BPS_5G = 355358572;</code> */
    public static final int BPS_5G_VALUE = 355358572;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Bandwidth valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Bandwidth forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_BANDWIDTH;
        case 49547958:
          return BPS_100M;
        case 278693006:
          return BPS_10G;
        case 355358448:
          return BPS_1G;
        case 49577749:
          return BPS_200M;
        case 278693967:
          return BPS_20G;
        case 355358479:
          return BPS_2G;
        case 49607540:
          return BPS_300M;
        case 49637331:
          return BPS_400M;
        case 49667122:
          return BPS_500M;
        case 278696850:
          return BPS_50G;
        case 278696856:
          return BPS_50M;
        case 355358572:
          return BPS_5G;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Bandwidth> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Bandwidth> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Bandwidth>() {
          public Bandwidth findValueByNumber(int number) {
            return Bandwidth.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(0);
    }

    private static final Bandwidth[] VALUES = values();

    public static Bandwidth valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Bandwidth(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.Bandwidth)
  }

  /**
   *
   *
   * <pre>
   * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
   * - AVAILABILITY_DOMAIN_ANY
   * - AVAILABILITY_DOMAIN_1
   * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain}
   */
  public enum EdgeAvailabilityDomain implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_EDGE_AVAILABILITY_DOMAIN = 0;</code>
     */
    UNDEFINED_EDGE_AVAILABILITY_DOMAIN(0),
    /** <code>AVAILABILITY_DOMAIN_1 = 349552090;</code> */
    AVAILABILITY_DOMAIN_1(349552090),
    /** <code>AVAILABILITY_DOMAIN_2 = 349552091;</code> */
    AVAILABILITY_DOMAIN_2(349552091),
    /** <code>AVAILABILITY_DOMAIN_ANY = 375256373;</code> */
    AVAILABILITY_DOMAIN_ANY(375256373),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_EDGE_AVAILABILITY_DOMAIN = 0;</code>
     */
    public static final int UNDEFINED_EDGE_AVAILABILITY_DOMAIN_VALUE = 0;
    /** <code>AVAILABILITY_DOMAIN_1 = 349552090;</code> */
    public static final int AVAILABILITY_DOMAIN_1_VALUE = 349552090;
    /** <code>AVAILABILITY_DOMAIN_2 = 349552091;</code> */
    public static final int AVAILABILITY_DOMAIN_2_VALUE = 349552091;
    /** <code>AVAILABILITY_DOMAIN_ANY = 375256373;</code> */
    public static final int AVAILABILITY_DOMAIN_ANY_VALUE = 375256373;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static EdgeAvailabilityDomain valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static EdgeAvailabilityDomain forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_EDGE_AVAILABILITY_DOMAIN;
        case 349552090:
          return AVAILABILITY_DOMAIN_1;
        case 349552091:
          return AVAILABILITY_DOMAIN_2;
        case 375256373:
          return AVAILABILITY_DOMAIN_ANY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EdgeAvailabilityDomain>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<EdgeAvailabilityDomain>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EdgeAvailabilityDomain>() {
              public EdgeAvailabilityDomain findValueByNumber(int number) {
                return EdgeAvailabilityDomain.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(1);
    }

    private static final EdgeAvailabilityDomain[] VALUES = values();

    public static EdgeAvailabilityDomain valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private EdgeAvailabilityDomain(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain)
  }

  /**
   *
   *
   * <pre>
   * Indicates the user-supplied encryption option of this interconnect attachment:
   * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
   * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.Encryption}
   */
  public enum Encryption implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ENCRYPTION = 0;</code>
     */
    UNDEFINED_ENCRYPTION(0),
    /** <code>IPSEC = 69882282;</code> */
    IPSEC(69882282),
    /** <code>NONE = 2402104;</code> */
    NONE(2402104),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ENCRYPTION = 0;</code>
     */
    public static final int UNDEFINED_ENCRYPTION_VALUE = 0;
    /** <code>IPSEC = 69882282;</code> */
    public static final int IPSEC_VALUE = 69882282;
    /** <code>NONE = 2402104;</code> */
    public static final int NONE_VALUE = 2402104;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Encryption valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Encryption forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ENCRYPTION;
        case 69882282:
          return IPSEC;
        case 2402104:
          return NONE;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Encryption> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Encryption> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Encryption>() {
          public Encryption findValueByNumber(int number) {
            return Encryption.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(2);
    }

    private static final Encryption[] VALUES = values();

    public static Encryption valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Encryption(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.Encryption)
  }

  /**
   *
   *
   * <pre>
   * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
   * - OS_ACTIVE: The attachment has been turned up and is ready to use.
   * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.OperationalStatus}
   */
  public enum OperationalStatus implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_OPERATIONAL_STATUS = 0;</code>
     */
    UNDEFINED_OPERATIONAL_STATUS(0),
    /** <code>OS_ACTIVE = 55721409;</code> */
    OS_ACTIVE(55721409),
    /** <code>OS_UNPROVISIONED = 239771840;</code> */
    OS_UNPROVISIONED(239771840),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_OPERATIONAL_STATUS = 0;</code>
     */
    public static final int UNDEFINED_OPERATIONAL_STATUS_VALUE = 0;
    /** <code>OS_ACTIVE = 55721409;</code> */
    public static final int OS_ACTIVE_VALUE = 55721409;
    /** <code>OS_UNPROVISIONED = 239771840;</code> */
    public static final int OS_UNPROVISIONED_VALUE = 239771840;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static OperationalStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static OperationalStatus forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_OPERATIONAL_STATUS;
        case 55721409:
          return OS_ACTIVE;
        case 239771840:
          return OS_UNPROVISIONED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<OperationalStatus>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<OperationalStatus>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OperationalStatus>() {
              public OperationalStatus findValueByNumber(int number) {
                return OperationalStatus.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(3);
    }

    private static final OperationalStatus[] VALUES = values();

    public static OperationalStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private OperationalStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.OperationalStatus)
  }

  /**
   *
   *
   * <pre>
   * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
   * - ACTIVE: The attachment has been turned up and is ready to use.
   * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
   * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
   * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
   * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.State}
   */
  public enum State implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_STATE = 0;</code>
     */
    UNDEFINED_STATE(0),
    /** <code>ACTIVE = 314733318;</code> */
    ACTIVE(314733318),
    /** <code>DEFUNCT = 115891759;</code> */
    DEFUNCT(115891759),
    /** <code>PARTNER_REQUEST_RECEIVED = 513587304;</code> */
    PARTNER_REQUEST_RECEIVED(513587304),
    /** <code>PENDING_CUSTOMER = 167494054;</code> */
    PENDING_CUSTOMER(167494054),
    /** <code>PENDING_PARTNER = 387890656;</code> */
    PENDING_PARTNER(387890656),
    /** <code>STATE_UNSPECIFIED = 470755401;</code> */
    STATE_UNSPECIFIED(470755401),
    /** <code>UNPROVISIONED = 517333979;</code> */
    UNPROVISIONED(517333979),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_STATE = 0;</code>
     */
    public static final int UNDEFINED_STATE_VALUE = 0;
    /** <code>ACTIVE = 314733318;</code> */
    public static final int ACTIVE_VALUE = 314733318;
    /** <code>DEFUNCT = 115891759;</code> */
    public static final int DEFUNCT_VALUE = 115891759;
    /** <code>PARTNER_REQUEST_RECEIVED = 513587304;</code> */
    public static final int PARTNER_REQUEST_RECEIVED_VALUE = 513587304;
    /** <code>PENDING_CUSTOMER = 167494054;</code> */
    public static final int PENDING_CUSTOMER_VALUE = 167494054;
    /** <code>PENDING_PARTNER = 387890656;</code> */
    public static final int PENDING_PARTNER_VALUE = 387890656;
    /** <code>STATE_UNSPECIFIED = 470755401;</code> */
    public static final int STATE_UNSPECIFIED_VALUE = 470755401;
    /** <code>UNPROVISIONED = 517333979;</code> */
    public static final int UNPROVISIONED_VALUE = 517333979;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static State valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static State forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_STATE;
        case 314733318:
          return ACTIVE;
        case 115891759:
          return DEFUNCT;
        case 513587304:
          return PARTNER_REQUEST_RECEIVED;
        case 167494054:
          return PENDING_CUSTOMER;
        case 387890656:
          return PENDING_PARTNER;
        case 470755401:
          return STATE_UNSPECIFIED;
        case 517333979:
          return UNPROVISIONED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<State> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<State> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<State>() {
          public State findValueByNumber(int number) {
            return State.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(4);
    }

    private static final State[] VALUES = values();

    public static State valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private State(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.State)
  }

  /**
   *
   *
   * <pre>
   * The type of interconnect attachment this is, which can take one of the following values:
   * - DEDICATED: an attachment to a Dedicated Interconnect.
   * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
   * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.InterconnectAttachment.Type}
   */
  public enum Type implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_TYPE = 0;</code>
     */
    UNDEFINED_TYPE(0),
    /** <code>DEDICATED = 258411983;</code> */
    DEDICATED(258411983),
    /** <code>PARTNER = 461924520;</code> */
    PARTNER(461924520),
    /** <code>PARTNER_PROVIDER = 483261352;</code> */
    PARTNER_PROVIDER(483261352),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_TYPE = 0;</code>
     */
    public static final int UNDEFINED_TYPE_VALUE = 0;
    /** <code>DEDICATED = 258411983;</code> */
    public static final int DEDICATED_VALUE = 258411983;
    /** <code>PARTNER = 461924520;</code> */
    public static final int PARTNER_VALUE = 461924520;
    /** <code>PARTNER_PROVIDER = 483261352;</code> */
    public static final int PARTNER_PROVIDER_VALUE = 483261352;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Type valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Type forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_TYPE;
        case 258411983:
          return DEDICATED;
        case 461924520:
          return PARTNER;
        case 483261352:
          return PARTNER_PROVIDER;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Type> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Type> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Type>() {
          public Type findValueByNumber(int number) {
            return Type.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDescriptor()
          .getEnumTypes()
          .get(5);
    }

    private static final Type[] VALUES = values();

    public static Type valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Type(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.InterconnectAttachment.Type)
  }

  private int bitField0_;
  public static final int ADMIN_ENABLED_FIELD_NUMBER = 445675089;
  private boolean adminEnabled_;
  /**
   *
   *
   * <pre>
   * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
   * </pre>
   *
   * <code>bool admin_enabled = 445675089;</code>
   *
   * @return Whether the adminEnabled field is set.
   */
  @java.lang.Override
  public boolean hasAdminEnabled() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   *
   *
   * <pre>
   * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
   * </pre>
   *
   * <code>bool admin_enabled = 445675089;</code>
   *
   * @return The adminEnabled.
   */
  @java.lang.Override
  public boolean getAdminEnabled() {
    return adminEnabled_;
  }

  public static final int BANDWIDTH_FIELD_NUMBER = 181715121;
  private int bandwidth_;
  /**
   *
   *
   * <pre>
   * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
   * - BPS_50M: 50 Mbit/s
   * - BPS_100M: 100 Mbit/s
   * - BPS_200M: 200 Mbit/s
   * - BPS_300M: 300 Mbit/s
   * - BPS_400M: 400 Mbit/s
   * - BPS_500M: 500 Mbit/s
   * - BPS_1G: 1 Gbit/s
   * - BPS_2G: 2 Gbit/s
   * - BPS_5G: 5 Gbit/s
   * - BPS_10G: 10 Gbit/s
   * - BPS_20G: 20 Gbit/s
   * - BPS_50G: 50 Gbit/s
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
   *
   * @return Whether the bandwidth field is set.
   */
  @java.lang.Override
  public boolean hasBandwidth() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   *
   *
   * <pre>
   * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
   * - BPS_50M: 50 Mbit/s
   * - BPS_100M: 100 Mbit/s
   * - BPS_200M: 200 Mbit/s
   * - BPS_300M: 300 Mbit/s
   * - BPS_400M: 400 Mbit/s
   * - BPS_500M: 500 Mbit/s
   * - BPS_1G: 1 Gbit/s
   * - BPS_2G: 2 Gbit/s
   * - BPS_5G: 5 Gbit/s
   * - BPS_10G: 10 Gbit/s
   * - BPS_20G: 20 Gbit/s
   * - BPS_50G: 50 Gbit/s
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
   *
   * @return The enum numeric value on the wire for bandwidth.
   */
  @java.lang.Override
  public int getBandwidthValue() {
    return bandwidth_;
  }
  /**
   *
   *
   * <pre>
   * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
   * - BPS_50M: 50 Mbit/s
   * - BPS_100M: 100 Mbit/s
   * - BPS_200M: 200 Mbit/s
   * - BPS_300M: 300 Mbit/s
   * - BPS_400M: 400 Mbit/s
   * - BPS_500M: 500 Mbit/s
   * - BPS_1G: 1 Gbit/s
   * - BPS_2G: 2 Gbit/s
   * - BPS_5G: 5 Gbit/s
   * - BPS_10G: 10 Gbit/s
   * - BPS_20G: 20 Gbit/s
   * - BPS_50G: 50 Gbit/s
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
   *
   * @return The bandwidth.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth getBandwidth() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth result =
        com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth.valueOf(bandwidth_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth.UNRECOGNIZED
        : result;
  }

  public static final int CANDIDATE_SUBNETS_FIELD_NUMBER = 237842938;
  private com.google.protobuf.LazyStringList candidateSubnets_;
  /**
   *
   *
   * <pre>
   * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
   * </pre>
   *
   * <code>repeated string candidate_subnets = 237842938;</code>
   *
   * @return A list containing the candidateSubnets.
   */
  public com.google.protobuf.ProtocolStringList getCandidateSubnetsList() {
    return candidateSubnets_;
  }
  /**
   *
   *
   * <pre>
   * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
   * </pre>
   *
   * <code>repeated string candidate_subnets = 237842938;</code>
   *
   * @return The count of candidateSubnets.
   */
  public int getCandidateSubnetsCount() {
    return candidateSubnets_.size();
  }
  /**
   *
   *
   * <pre>
   * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
   * </pre>
   *
   * <code>repeated string candidate_subnets = 237842938;</code>
   *
   * @param index The index of the element to return.
   * @return The candidateSubnets at the given index.
   */
  public java.lang.String getCandidateSubnets(int index) {
    return candidateSubnets_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
   * </pre>
   *
   * <code>repeated string candidate_subnets = 237842938;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the candidateSubnets at the given index.
   */
  public com.google.protobuf.ByteString getCandidateSubnetsBytes(int index) {
    return candidateSubnets_.getByteString(index);
  }

  public static final int CLOUD_ROUTER_IP_ADDRESS_FIELD_NUMBER = 287392776;
  private volatile java.lang.Object cloudRouterIpAddress_;
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
   * </pre>
   *
   * <code>string cloud_router_ip_address = 287392776;</code>
   *
   * @return Whether the cloudRouterIpAddress field is set.
   */
  @java.lang.Override
  public boolean hasCloudRouterIpAddress() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
   * </pre>
   *
   * <code>string cloud_router_ip_address = 287392776;</code>
   *
   * @return The cloudRouterIpAddress.
   */
  @java.lang.Override
  public java.lang.String getCloudRouterIpAddress() {
    java.lang.Object ref = cloudRouterIpAddress_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      cloudRouterIpAddress_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
   * </pre>
   *
   * <code>string cloud_router_ip_address = 287392776;</code>
   *
   * @return The bytes for cloudRouterIpAddress.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getCloudRouterIpAddressBytes() {
    java.lang.Object ref = cloudRouterIpAddress_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      cloudRouterIpAddress_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 30525366;
  private volatile java.lang.Object creationTimestamp_;
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return Whether the creationTimestamp field is set.
   */
  @java.lang.Override
  public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The creationTimestamp.
   */
  @java.lang.Override
  public java.lang.String getCreationTimestamp() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      creationTimestamp_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The bytes for creationTimestamp.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getCreationTimestampBytes() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      creationTimestamp_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int CUSTOMER_ROUTER_IP_ADDRESS_FIELD_NUMBER = 332475761;
  private volatile java.lang.Object customerRouterIpAddress_;
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
   * </pre>
   *
   * <code>string customer_router_ip_address = 332475761;</code>
   *
   * @return Whether the customerRouterIpAddress field is set.
   */
  @java.lang.Override
  public boolean hasCustomerRouterIpAddress() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
   * </pre>
   *
   * <code>string customer_router_ip_address = 332475761;</code>
   *
   * @return The customerRouterIpAddress.
   */
  @java.lang.Override
  public java.lang.String getCustomerRouterIpAddress() {
    java.lang.Object ref = customerRouterIpAddress_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      customerRouterIpAddress_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
   * </pre>
   *
   * <code>string customer_router_ip_address = 332475761;</code>
   *
   * @return The bytes for customerRouterIpAddress.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getCustomerRouterIpAddressBytes() {
    java.lang.Object ref = customerRouterIpAddress_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      customerRouterIpAddress_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int DATAPLANE_VERSION_FIELD_NUMBER = 34920075;
  private int dataplaneVersion_;
  /**
   *
   *
   * <pre>
   * [Output Only] Dataplane version for this InterconnectAttachment.
   * </pre>
   *
   * <code>int32 dataplane_version = 34920075;</code>
   *
   * @return Whether the dataplaneVersion field is set.
   */
  @java.lang.Override
  public boolean hasDataplaneVersion() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Dataplane version for this InterconnectAttachment.
   * </pre>
   *
   * <code>int32 dataplane_version = 34920075;</code>
   *
   * @return The dataplaneVersion.
   */
  @java.lang.Override
  public int getDataplaneVersion() {
    return dataplaneVersion_;
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 422937596;
  private volatile java.lang.Object description_;
  /**
   *
   *
   * <pre>
   * An optional description of this resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return Whether the description field is set.
   */
  @java.lang.Override
  public boolean hasDescription() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The description.
   */
  @java.lang.Override
  public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      description_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The bytes for description.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      description_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int EDGE_AVAILABILITY_DOMAIN_FIELD_NUMBER = 71289510;
  private int edgeAvailabilityDomain_;
  /**
   *
   *
   * <pre>
   * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
   * - AVAILABILITY_DOMAIN_ANY
   * - AVAILABILITY_DOMAIN_1
   * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
   * </code>
   *
   * @return Whether the edgeAvailabilityDomain field is set.
   */
  @java.lang.Override
  public boolean hasEdgeAvailabilityDomain() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   *
   *
   * <pre>
   * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
   * - AVAILABILITY_DOMAIN_ANY
   * - AVAILABILITY_DOMAIN_1
   * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
   * </code>
   *
   * @return The enum numeric value on the wire for edgeAvailabilityDomain.
   */
  @java.lang.Override
  public int getEdgeAvailabilityDomainValue() {
    return edgeAvailabilityDomain_;
  }
  /**
   *
   *
   * <pre>
   * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
   * - AVAILABILITY_DOMAIN_ANY
   * - AVAILABILITY_DOMAIN_1
   * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
   * </code>
   *
   * @return The edgeAvailabilityDomain.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain
      getEdgeAvailabilityDomain() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain result =
        com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain.valueOf(
            edgeAvailabilityDomain_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain.UNRECOGNIZED
        : result;
  }

  public static final int ENCRYPTION_FIELD_NUMBER = 97980291;
  private int encryption_;
  /**
   *
   *
   * <pre>
   * Indicates the user-supplied encryption option of this interconnect attachment:
   * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
   * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;</code>
   *
   * @return Whether the encryption field is set.
   */
  @java.lang.Override
  public boolean hasEncryption() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   *
   *
   * <pre>
   * Indicates the user-supplied encryption option of this interconnect attachment:
   * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
   * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;</code>
   *
   * @return The enum numeric value on the wire for encryption.
   */
  @java.lang.Override
  public int getEncryptionValue() {
    return encryption_;
  }
  /**
   *
   *
   * <pre>
   * Indicates the user-supplied encryption option of this interconnect attachment:
   * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
   * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;</code>
   *
   * @return The encryption.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.Encryption getEncryption() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.Encryption result =
        com.google.cloud.compute.v1.InterconnectAttachment.Encryption.valueOf(encryption_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.Encryption.UNRECOGNIZED
        : result;
  }

  public static final int GOOGLE_REFERENCE_ID_FIELD_NUMBER = 534944469;
  private volatile java.lang.Object googleReferenceId_;
  /**
   *
   *
   * <pre>
   * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
   * </pre>
   *
   * <code>string google_reference_id = 534944469;</code>
   *
   * @return Whether the googleReferenceId field is set.
   */
  @java.lang.Override
  public boolean hasGoogleReferenceId() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
   * </pre>
   *
   * <code>string google_reference_id = 534944469;</code>
   *
   * @return The googleReferenceId.
   */
  @java.lang.Override
  public java.lang.String getGoogleReferenceId() {
    java.lang.Object ref = googleReferenceId_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      googleReferenceId_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
   * </pre>
   *
   * <code>string google_reference_id = 534944469;</code>
   *
   * @return The bytes for googleReferenceId.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getGoogleReferenceIdBytes() {
    java.lang.Object ref = googleReferenceId_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      googleReferenceId_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ID_FIELD_NUMBER = 3355;
  private volatile java.lang.Object id_;
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return Whether the id field is set.
   */
  @java.lang.Override
  public boolean hasId() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The id.
   */
  @java.lang.Override
  public java.lang.String getId() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      id_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The bytes for id.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getIdBytes() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      id_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int INTERCONNECT_FIELD_NUMBER = 224601230;
  private volatile java.lang.Object interconnect_;
  /**
   *
   *
   * <pre>
   * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
   * </pre>
   *
   * <code>string interconnect = 224601230;</code>
   *
   * @return Whether the interconnect field is set.
   */
  @java.lang.Override
  public boolean hasInterconnect() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   *
   *
   * <pre>
   * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
   * </pre>
   *
   * <code>string interconnect = 224601230;</code>
   *
   * @return The interconnect.
   */
  @java.lang.Override
  public java.lang.String getInterconnect() {
    java.lang.Object ref = interconnect_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      interconnect_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
   * </pre>
   *
   * <code>string interconnect = 224601230;</code>
   *
   * @return The bytes for interconnect.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getInterconnectBytes() {
    java.lang.Object ref = interconnect_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      interconnect_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int IPSEC_INTERNAL_ADDRESSES_FIELD_NUMBER = 407648565;
  private com.google.protobuf.LazyStringList ipsecInternalAddresses_;
  /**
   *
   *
   * <pre>
   * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>repeated string ipsec_internal_addresses = 407648565;</code>
   *
   * @return A list containing the ipsecInternalAddresses.
   */
  public com.google.protobuf.ProtocolStringList getIpsecInternalAddressesList() {
    return ipsecInternalAddresses_;
  }
  /**
   *
   *
   * <pre>
   * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>repeated string ipsec_internal_addresses = 407648565;</code>
   *
   * @return The count of ipsecInternalAddresses.
   */
  public int getIpsecInternalAddressesCount() {
    return ipsecInternalAddresses_.size();
  }
  /**
   *
   *
   * <pre>
   * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>repeated string ipsec_internal_addresses = 407648565;</code>
   *
   * @param index The index of the element to return.
   * @return The ipsecInternalAddresses at the given index.
   */
  public java.lang.String getIpsecInternalAddresses(int index) {
    return ipsecInternalAddresses_.get(index);
  }
  /**
   *
   *
   * <pre>
   * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
   * Not currently available in all Interconnect locations.
   * </pre>
   *
   * <code>repeated string ipsec_internal_addresses = 407648565;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the ipsecInternalAddresses at the given index.
   */
  public com.google.protobuf.ByteString getIpsecInternalAddressesBytes(int index) {
    return ipsecInternalAddresses_.getByteString(index);
  }

  public static final int KIND_FIELD_NUMBER = 3292052;
  private volatile java.lang.Object kind_;
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return Whether the kind field is set.
   */
  @java.lang.Override
  public boolean hasKind() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The kind.
   */
  @java.lang.Override
  public java.lang.String getKind() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      kind_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The bytes for kind.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getKindBytes() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      kind_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MTU_FIELD_NUMBER = 108462;
  private int mtu_;
  /**
   *
   *
   * <pre>
   * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
   * </pre>
   *
   * <code>int32 mtu = 108462;</code>
   *
   * @return Whether the mtu field is set.
   */
  @java.lang.Override
  public boolean hasMtu() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
   * </pre>
   *
   * <code>int32 mtu = 108462;</code>
   *
   * @return The mtu.
   */
  @java.lang.Override
  public int getMtu() {
    return mtu_;
  }

  public static final int NAME_FIELD_NUMBER = 3373707;
  private volatile java.lang.Object name_;
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return Whether the name field is set.
   */
  @java.lang.Override
  public boolean hasName() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int OPERATIONAL_STATUS_FIELD_NUMBER = 201070847;
  private int operationalStatus_;
  /**
   *
   *
   * <pre>
   * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
   * - OS_ACTIVE: The attachment has been turned up and is ready to use.
   * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
   * </code>
   *
   * @return Whether the operationalStatus field is set.
   */
  @java.lang.Override
  public boolean hasOperationalStatus() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
   * - OS_ACTIVE: The attachment has been turned up and is ready to use.
   * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
   * </code>
   *
   * @return The enum numeric value on the wire for operationalStatus.
   */
  @java.lang.Override
  public int getOperationalStatusValue() {
    return operationalStatus_;
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
   * - OS_ACTIVE: The attachment has been turned up and is ready to use.
   * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
   * </code>
   *
   * @return The operationalStatus.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus
      getOperationalStatus() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus result =
        com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus.valueOf(
            operationalStatus_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus.UNRECOGNIZED
        : result;
  }

  public static final int PAIRING_KEY_FIELD_NUMBER = 439695464;
  private volatile java.lang.Object pairingKey_;
  /**
   *
   *
   * <pre>
   * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
   * </pre>
   *
   * <code>string pairing_key = 439695464;</code>
   *
   * @return Whether the pairingKey field is set.
   */
  @java.lang.Override
  public boolean hasPairingKey() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
   * </pre>
   *
   * <code>string pairing_key = 439695464;</code>
   *
   * @return The pairingKey.
   */
  @java.lang.Override
  public java.lang.String getPairingKey() {
    java.lang.Object ref = pairingKey_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      pairingKey_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
   * </pre>
   *
   * <code>string pairing_key = 439695464;</code>
   *
   * @return The bytes for pairingKey.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getPairingKeyBytes() {
    java.lang.Object ref = pairingKey_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      pairingKey_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PARTNER_ASN_FIELD_NUMBER = 438166149;
  private volatile java.lang.Object partnerAsn_;
  /**
   *
   *
   * <pre>
   * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>string partner_asn = 438166149;</code>
   *
   * @return Whether the partnerAsn field is set.
   */
  @java.lang.Override
  public boolean hasPartnerAsn() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>string partner_asn = 438166149;</code>
   *
   * @return The partnerAsn.
   */
  @java.lang.Override
  public java.lang.String getPartnerAsn() {
    java.lang.Object ref = partnerAsn_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      partnerAsn_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>string partner_asn = 438166149;</code>
   *
   * @return The bytes for partnerAsn.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getPartnerAsnBytes() {
    java.lang.Object ref = partnerAsn_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      partnerAsn_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PARTNER_METADATA_FIELD_NUMBER = 65908934;
  private com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partnerMetadata_;
  /**
   *
   *
   * <pre>
   * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
   * </code>
   *
   * @return Whether the partnerMetadata field is set.
   */
  @java.lang.Override
  public boolean hasPartnerMetadata() {
    return ((bitField0_ & 0x00040000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
   * </code>
   *
   * @return The partnerMetadata.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata getPartnerMetadata() {
    return partnerMetadata_ == null
        ? com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.getDefaultInstance()
        : partnerMetadata_;
  }
  /**
   *
   *
   * <pre>
   * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
   * </code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadataOrBuilder
      getPartnerMetadataOrBuilder() {
    return partnerMetadata_ == null
        ? com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.getDefaultInstance()
        : partnerMetadata_;
  }

  public static final int PRIVATE_INTERCONNECT_INFO_FIELD_NUMBER = 237270531;
  private com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo privateInterconnectInfo_;
  /**
   *
   *
   * <pre>
   * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
   * </code>
   *
   * @return Whether the privateInterconnectInfo field is set.
   */
  @java.lang.Override
  public boolean hasPrivateInterconnectInfo() {
    return ((bitField0_ & 0x00080000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
   * </code>
   *
   * @return The privateInterconnectInfo.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo
      getPrivateInterconnectInfo() {
    return privateInterconnectInfo_ == null
        ? com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.getDefaultInstance()
        : privateInterconnectInfo_;
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
   * </code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfoOrBuilder
      getPrivateInterconnectInfoOrBuilder() {
    return privateInterconnectInfo_ == null
        ? com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.getDefaultInstance()
        : privateInterconnectInfo_;
  }

  public static final int REGION_FIELD_NUMBER = 138946292;
  private volatile java.lang.Object region_;
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return Whether the region field is set.
   */
  @java.lang.Override
  public boolean hasRegion() {
    return ((bitField0_ & 0x00100000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The region.
   */
  @java.lang.Override
  public java.lang.String getRegion() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      region_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The bytes for region.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getRegionBytes() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      region_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ROUTER_FIELD_NUMBER = 148608841;
  private volatile java.lang.Object router_;
  /**
   *
   *
   * <pre>
   * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
   * </pre>
   *
   * <code>string router = 148608841;</code>
   *
   * @return Whether the router field is set.
   */
  @java.lang.Override
  public boolean hasRouter() {
    return ((bitField0_ & 0x00200000) != 0);
  }
  /**
   *
   *
   * <pre>
   * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
   * </pre>
   *
   * <code>string router = 148608841;</code>
   *
   * @return The router.
   */
  @java.lang.Override
  public java.lang.String getRouter() {
    java.lang.Object ref = router_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      router_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
   * </pre>
   *
   * <code>string router = 148608841;</code>
   *
   * @return The bytes for router.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getRouterBytes() {
    java.lang.Object ref = router_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      router_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SELF_LINK_FIELD_NUMBER = 456214797;
  private volatile java.lang.Object selfLink_;
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return Whether the selfLink field is set.
   */
  @java.lang.Override
  public boolean hasSelfLink() {
    return ((bitField0_ & 0x00400000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The selfLink.
   */
  @java.lang.Override
  public java.lang.String getSelfLink() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      selfLink_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The bytes for selfLink.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getSelfLinkBytes() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      selfLink_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int STATE_FIELD_NUMBER = 109757585;
  private int state_;
  /**
   *
   *
   * <pre>
   * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
   * - ACTIVE: The attachment has been turned up and is ready to use.
   * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
   * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
   * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
   * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
   *
   * @return Whether the state field is set.
   */
  @java.lang.Override
  public boolean hasState() {
    return ((bitField0_ & 0x00800000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
   * - ACTIVE: The attachment has been turned up and is ready to use.
   * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
   * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
   * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
   * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
   *
   * @return The enum numeric value on the wire for state.
   */
  @java.lang.Override
  public int getStateValue() {
    return state_;
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
   * - ACTIVE: The attachment has been turned up and is ready to use.
   * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
   * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
   * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
   * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
   * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
   *
   * @return The state.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.State getState() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.State result =
        com.google.cloud.compute.v1.InterconnectAttachment.State.valueOf(state_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.State.UNRECOGNIZED
        : result;
  }

  public static final int TYPE_FIELD_NUMBER = 3575610;
  private int type_;
  /**
   *
   *
   * <pre>
   * The type of interconnect attachment this is, which can take one of the following values:
   * - DEDICATED: an attachment to a Dedicated Interconnect.
   * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
   * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
   *
   * @return Whether the type field is set.
   */
  @java.lang.Override
  public boolean hasType() {
    return ((bitField0_ & 0x01000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The type of interconnect attachment this is, which can take one of the following values:
   * - DEDICATED: an attachment to a Dedicated Interconnect.
   * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
   * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
   *
   * @return The enum numeric value on the wire for type.
   */
  @java.lang.Override
  public int getTypeValue() {
    return type_;
  }
  /**
   *
   *
   * <pre>
   * The type of interconnect attachment this is, which can take one of the following values:
   * - DEDICATED: an attachment to a Dedicated Interconnect.
   * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
   * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
   *
   * @return The type.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment.Type getType() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.InterconnectAttachment.Type result =
        com.google.cloud.compute.v1.InterconnectAttachment.Type.valueOf(type_);
    return result == null
        ? com.google.cloud.compute.v1.InterconnectAttachment.Type.UNRECOGNIZED
        : result;
  }

  public static final int VLAN_TAG8021Q_FIELD_NUMBER = 119927836;
  private int vlanTag8021Q_;
  /**
   *
   *
   * <pre>
   * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
   * </pre>
   *
   * <code>int32 vlan_tag8021q = 119927836;</code>
   *
   * @return Whether the vlanTag8021q field is set.
   */
  @java.lang.Override
  public boolean hasVlanTag8021Q() {
    return ((bitField0_ & 0x02000000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
   * </pre>
   *
   * <code>int32 vlan_tag8021q = 119927836;</code>
   *
   * @return The vlanTag8021q.
   */
  @java.lang.Override
  public int getVlanTag8021Q() {
    return vlanTag8021Q_;
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000400) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3355, id_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      output.writeInt32(108462, mtu_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3292052, kind_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3373707, name_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      output.writeEnum(3575610, type_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      output.writeInt32(34920075, dataplaneVersion_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      output.writeMessage(65908934, getPartnerMetadata());
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      output.writeEnum(71289510, edgeAvailabilityDomain_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      output.writeEnum(97980291, encryption_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      output.writeEnum(109757585, state_);
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      output.writeInt32(119927836, vlanTag8021Q_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 138946292, region_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 148608841, router_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeEnum(181715121, bandwidth_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      output.writeEnum(201070847, operationalStatus_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 224601230, interconnect_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      output.writeMessage(237270531, getPrivateInterconnectInfo());
    }
    for (int i = 0; i < candidateSubnets_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 237842938, candidateSubnets_.getRaw(i));
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 287392776, cloudRouterIpAddress_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 332475761, customerRouterIpAddress_);
    }
    for (int i = 0; i < ipsecInternalAddresses_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 407648565, ipsecInternalAddresses_.getRaw(i));
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 422937596, description_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 438166149, partnerAsn_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 439695464, pairingKey_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeBool(445675089, adminEnabled_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 456214797, selfLink_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 534944469, googleReferenceId_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000400) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3355, id_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(108462, mtu_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3292052, kind_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3373707, name_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(3575610, type_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(34920075, dataplaneVersion_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(65908934, getPartnerMetadata());
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeEnumSize(71289510, edgeAvailabilityDomain_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(97980291, encryption_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(109757585, state_);
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(119927836, vlanTag8021Q_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(138946292, region_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(148608841, router_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(181715121, bandwidth_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(201070847, operationalStatus_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(224601230, interconnect_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              237270531, getPrivateInterconnectInfo());
    }
    {
      int dataSize = 0;
      for (int i = 0; i < candidateSubnets_.size(); i++) {
        dataSize += computeStringSizeNoTag(candidateSubnets_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getCandidateSubnetsList().size();
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              287392776, cloudRouterIpAddress_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              332475761, customerRouterIpAddress_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < ipsecInternalAddresses_.size(); i++) {
        dataSize += computeStringSizeNoTag(ipsecInternalAddresses_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getIpsecInternalAddressesList().size();
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(422937596, description_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(438166149, partnerAsn_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(439695464, pairingKey_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(445675089, adminEnabled_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(456214797, selfLink_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(534944469, googleReferenceId_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.InterconnectAttachment)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.InterconnectAttachment other =
        (com.google.cloud.compute.v1.InterconnectAttachment) obj;

    if (hasAdminEnabled() != other.hasAdminEnabled()) return false;
    if (hasAdminEnabled()) {
      if (getAdminEnabled() != other.getAdminEnabled()) return false;
    }
    if (hasBandwidth() != other.hasBandwidth()) return false;
    if (hasBandwidth()) {
      if (bandwidth_ != other.bandwidth_) return false;
    }
    if (!getCandidateSubnetsList().equals(other.getCandidateSubnetsList())) return false;
    if (hasCloudRouterIpAddress() != other.hasCloudRouterIpAddress()) return false;
    if (hasCloudRouterIpAddress()) {
      if (!getCloudRouterIpAddress().equals(other.getCloudRouterIpAddress())) return false;
    }
    if (hasCreationTimestamp() != other.hasCreationTimestamp()) return false;
    if (hasCreationTimestamp()) {
      if (!getCreationTimestamp().equals(other.getCreationTimestamp())) return false;
    }
    if (hasCustomerRouterIpAddress() != other.hasCustomerRouterIpAddress()) return false;
    if (hasCustomerRouterIpAddress()) {
      if (!getCustomerRouterIpAddress().equals(other.getCustomerRouterIpAddress())) return false;
    }
    if (hasDataplaneVersion() != other.hasDataplaneVersion()) return false;
    if (hasDataplaneVersion()) {
      if (getDataplaneVersion() != other.getDataplaneVersion()) return false;
    }
    if (hasDescription() != other.hasDescription()) return false;
    if (hasDescription()) {
      if (!getDescription().equals(other.getDescription())) return false;
    }
    if (hasEdgeAvailabilityDomain() != other.hasEdgeAvailabilityDomain()) return false;
    if (hasEdgeAvailabilityDomain()) {
      if (edgeAvailabilityDomain_ != other.edgeAvailabilityDomain_) return false;
    }
    if (hasEncryption() != other.hasEncryption()) return false;
    if (hasEncryption()) {
      if (encryption_ != other.encryption_) return false;
    }
    if (hasGoogleReferenceId() != other.hasGoogleReferenceId()) return false;
    if (hasGoogleReferenceId()) {
      if (!getGoogleReferenceId().equals(other.getGoogleReferenceId())) return false;
    }
    if (hasId() != other.hasId()) return false;
    if (hasId()) {
      if (!getId().equals(other.getId())) return false;
    }
    if (hasInterconnect() != other.hasInterconnect()) return false;
    if (hasInterconnect()) {
      if (!getInterconnect().equals(other.getInterconnect())) return false;
    }
    if (!getIpsecInternalAddressesList().equals(other.getIpsecInternalAddressesList()))
      return false;
    if (hasKind() != other.hasKind()) return false;
    if (hasKind()) {
      if (!getKind().equals(other.getKind())) return false;
    }
    if (hasMtu() != other.hasMtu()) return false;
    if (hasMtu()) {
      if (getMtu() != other.getMtu()) return false;
    }
    if (hasName() != other.hasName()) return false;
    if (hasName()) {
      if (!getName().equals(other.getName())) return false;
    }
    if (hasOperationalStatus() != other.hasOperationalStatus()) return false;
    if (hasOperationalStatus()) {
      if (operationalStatus_ != other.operationalStatus_) return false;
    }
    if (hasPairingKey() != other.hasPairingKey()) return false;
    if (hasPairingKey()) {
      if (!getPairingKey().equals(other.getPairingKey())) return false;
    }
    if (hasPartnerAsn() != other.hasPartnerAsn()) return false;
    if (hasPartnerAsn()) {
      if (!getPartnerAsn().equals(other.getPartnerAsn())) return false;
    }
    if (hasPartnerMetadata() != other.hasPartnerMetadata()) return false;
    if (hasPartnerMetadata()) {
      if (!getPartnerMetadata().equals(other.getPartnerMetadata())) return false;
    }
    if (hasPrivateInterconnectInfo() != other.hasPrivateInterconnectInfo()) return false;
    if (hasPrivateInterconnectInfo()) {
      if (!getPrivateInterconnectInfo().equals(other.getPrivateInterconnectInfo())) return false;
    }
    if (hasRegion() != other.hasRegion()) return false;
    if (hasRegion()) {
      if (!getRegion().equals(other.getRegion())) return false;
    }
    if (hasRouter() != other.hasRouter()) return false;
    if (hasRouter()) {
      if (!getRouter().equals(other.getRouter())) return false;
    }
    if (hasSelfLink() != other.hasSelfLink()) return false;
    if (hasSelfLink()) {
      if (!getSelfLink().equals(other.getSelfLink())) return false;
    }
    if (hasState() != other.hasState()) return false;
    if (hasState()) {
      if (state_ != other.state_) return false;
    }
    if (hasType() != other.hasType()) return false;
    if (hasType()) {
      if (type_ != other.type_) return false;
    }
    if (hasVlanTag8021Q() != other.hasVlanTag8021Q()) return false;
    if (hasVlanTag8021Q()) {
      if (getVlanTag8021Q() != other.getVlanTag8021Q()) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasAdminEnabled()) {
      hash = (37 * hash) + ADMIN_ENABLED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getAdminEnabled());
    }
    if (hasBandwidth()) {
      hash = (37 * hash) + BANDWIDTH_FIELD_NUMBER;
      hash = (53 * hash) + bandwidth_;
    }
    if (getCandidateSubnetsCount() > 0) {
      hash = (37 * hash) + CANDIDATE_SUBNETS_FIELD_NUMBER;
      hash = (53 * hash) + getCandidateSubnetsList().hashCode();
    }
    if (hasCloudRouterIpAddress()) {
      hash = (37 * hash) + CLOUD_ROUTER_IP_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getCloudRouterIpAddress().hashCode();
    }
    if (hasCreationTimestamp()) {
      hash = (37 * hash) + CREATION_TIMESTAMP_FIELD_NUMBER;
      hash = (53 * hash) + getCreationTimestamp().hashCode();
    }
    if (hasCustomerRouterIpAddress()) {
      hash = (37 * hash) + CUSTOMER_ROUTER_IP_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getCustomerRouterIpAddress().hashCode();
    }
    if (hasDataplaneVersion()) {
      hash = (37 * hash) + DATAPLANE_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getDataplaneVersion();
    }
    if (hasDescription()) {
      hash = (37 * hash) + DESCRIPTION_FIELD_NUMBER;
      hash = (53 * hash) + getDescription().hashCode();
    }
    if (hasEdgeAvailabilityDomain()) {
      hash = (37 * hash) + EDGE_AVAILABILITY_DOMAIN_FIELD_NUMBER;
      hash = (53 * hash) + edgeAvailabilityDomain_;
    }
    if (hasEncryption()) {
      hash = (37 * hash) + ENCRYPTION_FIELD_NUMBER;
      hash = (53 * hash) + encryption_;
    }
    if (hasGoogleReferenceId()) {
      hash = (37 * hash) + GOOGLE_REFERENCE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getGoogleReferenceId().hashCode();
    }
    if (hasId()) {
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
    }
    if (hasInterconnect()) {
      hash = (37 * hash) + INTERCONNECT_FIELD_NUMBER;
      hash = (53 * hash) + getInterconnect().hashCode();
    }
    if (getIpsecInternalAddressesCount() > 0) {
      hash = (37 * hash) + IPSEC_INTERNAL_ADDRESSES_FIELD_NUMBER;
      hash = (53 * hash) + getIpsecInternalAddressesList().hashCode();
    }
    if (hasKind()) {
      hash = (37 * hash) + KIND_FIELD_NUMBER;
      hash = (53 * hash) + getKind().hashCode();
    }
    if (hasMtu()) {
      hash = (37 * hash) + MTU_FIELD_NUMBER;
      hash = (53 * hash) + getMtu();
    }
    if (hasName()) {
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
    }
    if (hasOperationalStatus()) {
      hash = (37 * hash) + OPERATIONAL_STATUS_FIELD_NUMBER;
      hash = (53 * hash) + operationalStatus_;
    }
    if (hasPairingKey()) {
      hash = (37 * hash) + PAIRING_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getPairingKey().hashCode();
    }
    if (hasPartnerAsn()) {
      hash = (37 * hash) + PARTNER_ASN_FIELD_NUMBER;
      hash = (53 * hash) + getPartnerAsn().hashCode();
    }
    if (hasPartnerMetadata()) {
      hash = (37 * hash) + PARTNER_METADATA_FIELD_NUMBER;
      hash = (53 * hash) + getPartnerMetadata().hashCode();
    }
    if (hasPrivateInterconnectInfo()) {
      hash = (37 * hash) + PRIVATE_INTERCONNECT_INFO_FIELD_NUMBER;
      hash = (53 * hash) + getPrivateInterconnectInfo().hashCode();
    }
    if (hasRegion()) {
      hash = (37 * hash) + REGION_FIELD_NUMBER;
      hash = (53 * hash) + getRegion().hashCode();
    }
    if (hasRouter()) {
      hash = (37 * hash) + ROUTER_FIELD_NUMBER;
      hash = (53 * hash) + getRouter().hashCode();
    }
    if (hasSelfLink()) {
      hash = (37 * hash) + SELF_LINK_FIELD_NUMBER;
      hash = (53 * hash) + getSelfLink().hashCode();
    }
    if (hasState()) {
      hash = (37 * hash) + STATE_FIELD_NUMBER;
      hash = (53 * hash) + state_;
    }
    if (hasType()) {
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
    }
    if (hasVlanTag8021Q()) {
      hash = (37 * hash) + VLAN_TAG8021Q_FIELD_NUMBER;
      hash = (53 * hash) + getVlanTag8021Q();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.InterconnectAttachment prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Represents an Interconnect Attachment (VLAN) resource.
   * You can use Interconnect attachments (VLANS) to connect your Virtual Private Cloud networks to your on-premises networks through an Interconnect. For more information, read  Creating VLAN Attachments. (== resource_for {$api_version}.interconnectAttachments ==)
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.InterconnectAttachment}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.InterconnectAttachment)
      com.google.cloud.compute.v1.InterconnectAttachmentOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InterconnectAttachment_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InterconnectAttachment_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.InterconnectAttachment.class,
              com.google.cloud.compute.v1.InterconnectAttachment.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.InterconnectAttachment.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getPartnerMetadataFieldBuilder();
        getPrivateInterconnectInfoFieldBuilder();
      }
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      adminEnabled_ = false;
      bitField0_ = (bitField0_ & ~0x00000001);
      bandwidth_ = 0;
      bitField0_ = (bitField0_ & ~0x00000002);
      candidateSubnets_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000004);
      cloudRouterIpAddress_ = "";
      bitField0_ = (bitField0_ & ~0x00000008);
      creationTimestamp_ = "";
      bitField0_ = (bitField0_ & ~0x00000010);
      customerRouterIpAddress_ = "";
      bitField0_ = (bitField0_ & ~0x00000020);
      dataplaneVersion_ = 0;
      bitField0_ = (bitField0_ & ~0x00000040);
      description_ = "";
      bitField0_ = (bitField0_ & ~0x00000080);
      edgeAvailabilityDomain_ = 0;
      bitField0_ = (bitField0_ & ~0x00000100);
      encryption_ = 0;
      bitField0_ = (bitField0_ & ~0x00000200);
      googleReferenceId_ = "";
      bitField0_ = (bitField0_ & ~0x00000400);
      id_ = "";
      bitField0_ = (bitField0_ & ~0x00000800);
      interconnect_ = "";
      bitField0_ = (bitField0_ & ~0x00001000);
      ipsecInternalAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00002000);
      kind_ = "";
      bitField0_ = (bitField0_ & ~0x00004000);
      mtu_ = 0;
      bitField0_ = (bitField0_ & ~0x00008000);
      name_ = "";
      bitField0_ = (bitField0_ & ~0x00010000);
      operationalStatus_ = 0;
      bitField0_ = (bitField0_ & ~0x00020000);
      pairingKey_ = "";
      bitField0_ = (bitField0_ & ~0x00040000);
      partnerAsn_ = "";
      bitField0_ = (bitField0_ & ~0x00080000);
      if (partnerMetadataBuilder_ == null) {
        partnerMetadata_ = null;
      } else {
        partnerMetadataBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00100000);
      if (privateInterconnectInfoBuilder_ == null) {
        privateInterconnectInfo_ = null;
      } else {
        privateInterconnectInfoBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00200000);
      region_ = "";
      bitField0_ = (bitField0_ & ~0x00400000);
      router_ = "";
      bitField0_ = (bitField0_ & ~0x00800000);
      selfLink_ = "";
      bitField0_ = (bitField0_ & ~0x01000000);
      state_ = 0;
      bitField0_ = (bitField0_ & ~0x02000000);
      type_ = 0;
      bitField0_ = (bitField0_ & ~0x04000000);
      vlanTag8021Q_ = 0;
      bitField0_ = (bitField0_ & ~0x08000000);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InterconnectAttachment_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.InterconnectAttachment.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment build() {
      com.google.cloud.compute.v1.InterconnectAttachment result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment buildPartial() {
      com.google.cloud.compute.v1.InterconnectAttachment result =
          new com.google.cloud.compute.v1.InterconnectAttachment(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.adminEnabled_ = adminEnabled_;
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        to_bitField0_ |= 0x00000002;
      }
      result.bandwidth_ = bandwidth_;
      if (((bitField0_ & 0x00000004) != 0)) {
        candidateSubnets_ = candidateSubnets_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000004);
      }
      result.candidateSubnets_ = candidateSubnets_;
      if (((from_bitField0_ & 0x00000008) != 0)) {
        to_bitField0_ |= 0x00000004;
      }
      result.cloudRouterIpAddress_ = cloudRouterIpAddress_;
      if (((from_bitField0_ & 0x00000010) != 0)) {
        to_bitField0_ |= 0x00000008;
      }
      result.creationTimestamp_ = creationTimestamp_;
      if (((from_bitField0_ & 0x00000020) != 0)) {
        to_bitField0_ |= 0x00000010;
      }
      result.customerRouterIpAddress_ = customerRouterIpAddress_;
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.dataplaneVersion_ = dataplaneVersion_;
        to_bitField0_ |= 0x00000020;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        to_bitField0_ |= 0x00000040;
      }
      result.description_ = description_;
      if (((from_bitField0_ & 0x00000100) != 0)) {
        to_bitField0_ |= 0x00000080;
      }
      result.edgeAvailabilityDomain_ = edgeAvailabilityDomain_;
      if (((from_bitField0_ & 0x00000200) != 0)) {
        to_bitField0_ |= 0x00000100;
      }
      result.encryption_ = encryption_;
      if (((from_bitField0_ & 0x00000400) != 0)) {
        to_bitField0_ |= 0x00000200;
      }
      result.googleReferenceId_ = googleReferenceId_;
      if (((from_bitField0_ & 0x00000800) != 0)) {
        to_bitField0_ |= 0x00000400;
      }
      result.id_ = id_;
      if (((from_bitField0_ & 0x00001000) != 0)) {
        to_bitField0_ |= 0x00000800;
      }
      result.interconnect_ = interconnect_;
      if (((bitField0_ & 0x00002000) != 0)) {
        ipsecInternalAddresses_ = ipsecInternalAddresses_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00002000);
      }
      result.ipsecInternalAddresses_ = ipsecInternalAddresses_;
      if (((from_bitField0_ & 0x00004000) != 0)) {
        to_bitField0_ |= 0x00001000;
      }
      result.kind_ = kind_;
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.mtu_ = mtu_;
        to_bitField0_ |= 0x00002000;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        to_bitField0_ |= 0x00004000;
      }
      result.name_ = name_;
      if (((from_bitField0_ & 0x00020000) != 0)) {
        to_bitField0_ |= 0x00008000;
      }
      result.operationalStatus_ = operationalStatus_;
      if (((from_bitField0_ & 0x00040000) != 0)) {
        to_bitField0_ |= 0x00010000;
      }
      result.pairingKey_ = pairingKey_;
      if (((from_bitField0_ & 0x00080000) != 0)) {
        to_bitField0_ |= 0x00020000;
      }
      result.partnerAsn_ = partnerAsn_;
      if (((from_bitField0_ & 0x00100000) != 0)) {
        if (partnerMetadataBuilder_ == null) {
          result.partnerMetadata_ = partnerMetadata_;
        } else {
          result.partnerMetadata_ = partnerMetadataBuilder_.build();
        }
        to_bitField0_ |= 0x00040000;
      }
      if (((from_bitField0_ & 0x00200000) != 0)) {
        if (privateInterconnectInfoBuilder_ == null) {
          result.privateInterconnectInfo_ = privateInterconnectInfo_;
        } else {
          result.privateInterconnectInfo_ = privateInterconnectInfoBuilder_.build();
        }
        to_bitField0_ |= 0x00080000;
      }
      if (((from_bitField0_ & 0x00400000) != 0)) {
        to_bitField0_ |= 0x00100000;
      }
      result.region_ = region_;
      if (((from_bitField0_ & 0x00800000) != 0)) {
        to_bitField0_ |= 0x00200000;
      }
      result.router_ = router_;
      if (((from_bitField0_ & 0x01000000) != 0)) {
        to_bitField0_ |= 0x00400000;
      }
      result.selfLink_ = selfLink_;
      if (((from_bitField0_ & 0x02000000) != 0)) {
        to_bitField0_ |= 0x00800000;
      }
      result.state_ = state_;
      if (((from_bitField0_ & 0x04000000) != 0)) {
        to_bitField0_ |= 0x01000000;
      }
      result.type_ = type_;
      if (((from_bitField0_ & 0x08000000) != 0)) {
        result.vlanTag8021Q_ = vlanTag8021Q_;
        to_bitField0_ |= 0x02000000;
      }
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.InterconnectAttachment) {
        return mergeFrom((com.google.cloud.compute.v1.InterconnectAttachment) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.InterconnectAttachment other) {
      if (other == com.google.cloud.compute.v1.InterconnectAttachment.getDefaultInstance())
        return this;
      if (other.hasAdminEnabled()) {
        setAdminEnabled(other.getAdminEnabled());
      }
      if (other.hasBandwidth()) {
        setBandwidth(other.getBandwidth());
      }
      if (!other.candidateSubnets_.isEmpty()) {
        if (candidateSubnets_.isEmpty()) {
          candidateSubnets_ = other.candidateSubnets_;
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          ensureCandidateSubnetsIsMutable();
          candidateSubnets_.addAll(other.candidateSubnets_);
        }
        onChanged();
      }
      if (other.hasCloudRouterIpAddress()) {
        bitField0_ |= 0x00000008;
        cloudRouterIpAddress_ = other.cloudRouterIpAddress_;
        onChanged();
      }
      if (other.hasCreationTimestamp()) {
        bitField0_ |= 0x00000010;
        creationTimestamp_ = other.creationTimestamp_;
        onChanged();
      }
      if (other.hasCustomerRouterIpAddress()) {
        bitField0_ |= 0x00000020;
        customerRouterIpAddress_ = other.customerRouterIpAddress_;
        onChanged();
      }
      if (other.hasDataplaneVersion()) {
        setDataplaneVersion(other.getDataplaneVersion());
      }
      if (other.hasDescription()) {
        bitField0_ |= 0x00000080;
        description_ = other.description_;
        onChanged();
      }
      if (other.hasEdgeAvailabilityDomain()) {
        setEdgeAvailabilityDomain(other.getEdgeAvailabilityDomain());
      }
      if (other.hasEncryption()) {
        setEncryption(other.getEncryption());
      }
      if (other.hasGoogleReferenceId()) {
        bitField0_ |= 0x00000400;
        googleReferenceId_ = other.googleReferenceId_;
        onChanged();
      }
      if (other.hasId()) {
        bitField0_ |= 0x00000800;
        id_ = other.id_;
        onChanged();
      }
      if (other.hasInterconnect()) {
        bitField0_ |= 0x00001000;
        interconnect_ = other.interconnect_;
        onChanged();
      }
      if (!other.ipsecInternalAddresses_.isEmpty()) {
        if (ipsecInternalAddresses_.isEmpty()) {
          ipsecInternalAddresses_ = other.ipsecInternalAddresses_;
          bitField0_ = (bitField0_ & ~0x00002000);
        } else {
          ensureIpsecInternalAddressesIsMutable();
          ipsecInternalAddresses_.addAll(other.ipsecInternalAddresses_);
        }
        onChanged();
      }
      if (other.hasKind()) {
        bitField0_ |= 0x00004000;
        kind_ = other.kind_;
        onChanged();
      }
      if (other.hasMtu()) {
        setMtu(other.getMtu());
      }
      if (other.hasName()) {
        bitField0_ |= 0x00010000;
        name_ = other.name_;
        onChanged();
      }
      if (other.hasOperationalStatus()) {
        setOperationalStatus(other.getOperationalStatus());
      }
      if (other.hasPairingKey()) {
        bitField0_ |= 0x00040000;
        pairingKey_ = other.pairingKey_;
        onChanged();
      }
      if (other.hasPartnerAsn()) {
        bitField0_ |= 0x00080000;
        partnerAsn_ = other.partnerAsn_;
        onChanged();
      }
      if (other.hasPartnerMetadata()) {
        mergePartnerMetadata(other.getPartnerMetadata());
      }
      if (other.hasPrivateInterconnectInfo()) {
        mergePrivateInterconnectInfo(other.getPrivateInterconnectInfo());
      }
      if (other.hasRegion()) {
        bitField0_ |= 0x00400000;
        region_ = other.region_;
        onChanged();
      }
      if (other.hasRouter()) {
        bitField0_ |= 0x00800000;
        router_ = other.router_;
        onChanged();
      }
      if (other.hasSelfLink()) {
        bitField0_ |= 0x01000000;
        selfLink_ = other.selfLink_;
        onChanged();
      }
      if (other.hasState()) {
        setState(other.getState());
      }
      if (other.hasType()) {
        setType(other.getType());
      }
      if (other.hasVlanTag8021Q()) {
        setVlanTag8021Q(other.getVlanTag8021Q());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.InterconnectAttachment parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage =
            (com.google.cloud.compute.v1.InterconnectAttachment) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int bitField0_;

    private boolean adminEnabled_;
    /**
     *
     *
     * <pre>
     * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
     * </pre>
     *
     * <code>bool admin_enabled = 445675089;</code>
     *
     * @return Whether the adminEnabled field is set.
     */
    @java.lang.Override
    public boolean hasAdminEnabled() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     *
     *
     * <pre>
     * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
     * </pre>
     *
     * <code>bool admin_enabled = 445675089;</code>
     *
     * @return The adminEnabled.
     */
    @java.lang.Override
    public boolean getAdminEnabled() {
      return adminEnabled_;
    }
    /**
     *
     *
     * <pre>
     * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
     * </pre>
     *
     * <code>bool admin_enabled = 445675089;</code>
     *
     * @param value The adminEnabled to set.
     * @return This builder for chaining.
     */
    public Builder setAdminEnabled(boolean value) {
      bitField0_ |= 0x00000001;
      adminEnabled_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
     * </pre>
     *
     * <code>bool admin_enabled = 445675089;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAdminEnabled() {
      bitField0_ = (bitField0_ & ~0x00000001);
      adminEnabled_ = false;
      onChanged();
      return this;
    }

    private int bandwidth_ = 0;
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @return Whether the bandwidth field is set.
     */
    @java.lang.Override
    public boolean hasBandwidth() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @return The enum numeric value on the wire for bandwidth.
     */
    @java.lang.Override
    public int getBandwidthValue() {
      return bandwidth_;
    }
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @param value The enum numeric value on the wire for bandwidth to set.
     * @return This builder for chaining.
     */
    public Builder setBandwidthValue(int value) {
      bitField0_ |= 0x00000002;
      bandwidth_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @return The bandwidth.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth getBandwidth() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth result =
          com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth.valueOf(bandwidth_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @param value The bandwidth to set.
     * @return This builder for chaining.
     */
    public Builder setBandwidth(
        com.google.cloud.compute.v1.InterconnectAttachment.Bandwidth value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      bandwidth_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values:
     * - BPS_50M: 50 Mbit/s
     * - BPS_100M: 100 Mbit/s
     * - BPS_200M: 200 Mbit/s
     * - BPS_300M: 300 Mbit/s
     * - BPS_400M: 400 Mbit/s
     * - BPS_500M: 500 Mbit/s
     * - BPS_1G: 1 Gbit/s
     * - BPS_2G: 2 Gbit/s
     * - BPS_5G: 5 Gbit/s
     * - BPS_10G: 10 Gbit/s
     * - BPS_20G: 20 Gbit/s
     * - BPS_50G: 50 Gbit/s
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Bandwidth bandwidth = 181715121;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearBandwidth() {
      bitField0_ = (bitField0_ & ~0x00000002);
      bandwidth_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList candidateSubnets_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensureCandidateSubnetsIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        candidateSubnets_ = new com.google.protobuf.LazyStringArrayList(candidateSubnets_);
        bitField0_ |= 0x00000004;
      }
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @return A list containing the candidateSubnets.
     */
    public com.google.protobuf.ProtocolStringList getCandidateSubnetsList() {
      return candidateSubnets_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @return The count of candidateSubnets.
     */
    public int getCandidateSubnetsCount() {
      return candidateSubnets_.size();
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param index The index of the element to return.
     * @return The candidateSubnets at the given index.
     */
    public java.lang.String getCandidateSubnets(int index) {
      return candidateSubnets_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the candidateSubnets at the given index.
     */
    public com.google.protobuf.ByteString getCandidateSubnetsBytes(int index) {
      return candidateSubnets_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param index The index to set the value at.
     * @param value The candidateSubnets to set.
     * @return This builder for chaining.
     */
    public Builder setCandidateSubnets(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCandidateSubnetsIsMutable();
      candidateSubnets_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param value The candidateSubnets to add.
     * @return This builder for chaining.
     */
    public Builder addCandidateSubnets(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureCandidateSubnetsIsMutable();
      candidateSubnets_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param values The candidateSubnets to add.
     * @return This builder for chaining.
     */
    public Builder addAllCandidateSubnets(java.lang.Iterable<java.lang.String> values) {
      ensureCandidateSubnetsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, candidateSubnets_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCandidateSubnets() {
      candidateSubnets_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
     * </pre>
     *
     * <code>repeated string candidate_subnets = 237842938;</code>
     *
     * @param value The bytes of the candidateSubnets to add.
     * @return This builder for chaining.
     */
    public Builder addCandidateSubnetsBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureCandidateSubnetsIsMutable();
      candidateSubnets_.add(value);
      onChanged();
      return this;
    }

    private java.lang.Object cloudRouterIpAddress_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @return Whether the cloudRouterIpAddress field is set.
     */
    public boolean hasCloudRouterIpAddress() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @return The cloudRouterIpAddress.
     */
    public java.lang.String getCloudRouterIpAddress() {
      java.lang.Object ref = cloudRouterIpAddress_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        cloudRouterIpAddress_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @return The bytes for cloudRouterIpAddress.
     */
    public com.google.protobuf.ByteString getCloudRouterIpAddressBytes() {
      java.lang.Object ref = cloudRouterIpAddress_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        cloudRouterIpAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @param value The cloudRouterIpAddress to set.
     * @return This builder for chaining.
     */
    public Builder setCloudRouterIpAddress(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000008;
      cloudRouterIpAddress_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCloudRouterIpAddress() {
      bitField0_ = (bitField0_ & ~0x00000008);
      cloudRouterIpAddress_ = getDefaultInstance().getCloudRouterIpAddress();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
     * </pre>
     *
     * <code>string cloud_router_ip_address = 287392776;</code>
     *
     * @param value The bytes for cloudRouterIpAddress to set.
     * @return This builder for chaining.
     */
    public Builder setCloudRouterIpAddressBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000008;
      cloudRouterIpAddress_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object creationTimestamp_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return Whether the creationTimestamp field is set.
     */
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The creationTimestamp.
     */
    public java.lang.String getCreationTimestamp() {
      java.lang.Object ref = creationTimestamp_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        creationTimestamp_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The bytes for creationTimestamp.
     */
    public com.google.protobuf.ByteString getCreationTimestampBytes() {
      java.lang.Object ref = creationTimestamp_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        creationTimestamp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestamp(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000010);
      creationTimestamp_ = getDefaultInstance().getCreationTimestamp();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The bytes for creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestampBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000010;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object customerRouterIpAddress_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @return Whether the customerRouterIpAddress field is set.
     */
    public boolean hasCustomerRouterIpAddress() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @return The customerRouterIpAddress.
     */
    public java.lang.String getCustomerRouterIpAddress() {
      java.lang.Object ref = customerRouterIpAddress_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        customerRouterIpAddress_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @return The bytes for customerRouterIpAddress.
     */
    public com.google.protobuf.ByteString getCustomerRouterIpAddressBytes() {
      java.lang.Object ref = customerRouterIpAddress_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        customerRouterIpAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @param value The customerRouterIpAddress to set.
     * @return This builder for chaining.
     */
    public Builder setCustomerRouterIpAddress(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000020;
      customerRouterIpAddress_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCustomerRouterIpAddress() {
      bitField0_ = (bitField0_ & ~0x00000020);
      customerRouterIpAddress_ = getDefaultInstance().getCustomerRouterIpAddress();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
     * </pre>
     *
     * <code>string customer_router_ip_address = 332475761;</code>
     *
     * @param value The bytes for customerRouterIpAddress to set.
     * @return This builder for chaining.
     */
    public Builder setCustomerRouterIpAddressBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000020;
      customerRouterIpAddress_ = value;
      onChanged();
      return this;
    }

    private int dataplaneVersion_;
    /**
     *
     *
     * <pre>
     * [Output Only] Dataplane version for this InterconnectAttachment.
     * </pre>
     *
     * <code>int32 dataplane_version = 34920075;</code>
     *
     * @return Whether the dataplaneVersion field is set.
     */
    @java.lang.Override
    public boolean hasDataplaneVersion() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Dataplane version for this InterconnectAttachment.
     * </pre>
     *
     * <code>int32 dataplane_version = 34920075;</code>
     *
     * @return The dataplaneVersion.
     */
    @java.lang.Override
    public int getDataplaneVersion() {
      return dataplaneVersion_;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Dataplane version for this InterconnectAttachment.
     * </pre>
     *
     * <code>int32 dataplane_version = 34920075;</code>
     *
     * @param value The dataplaneVersion to set.
     * @return This builder for chaining.
     */
    public Builder setDataplaneVersion(int value) {
      bitField0_ |= 0x00000040;
      dataplaneVersion_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Dataplane version for this InterconnectAttachment.
     * </pre>
     *
     * <code>int32 dataplane_version = 34920075;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearDataplaneVersion() {
      bitField0_ = (bitField0_ & ~0x00000040);
      dataplaneVersion_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object description_ = "";
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return Whether the description field is set.
     */
    public boolean hasDescription() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The description.
     */
    public java.lang.String getDescription() {
      java.lang.Object ref = description_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        description_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The bytes for description.
     */
    public com.google.protobuf.ByteString getDescriptionBytes() {
      java.lang.Object ref = description_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The description to set.
     * @return This builder for chaining.
     */
    public Builder setDescription(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000080;
      description_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearDescription() {
      bitField0_ = (bitField0_ & ~0x00000080);
      description_ = getDefaultInstance().getDescription();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The bytes for description to set.
     * @return This builder for chaining.
     */
    public Builder setDescriptionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000080;
      description_ = value;
      onChanged();
      return this;
    }

    private int edgeAvailabilityDomain_ = 0;
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @return Whether the edgeAvailabilityDomain field is set.
     */
    @java.lang.Override
    public boolean hasEdgeAvailabilityDomain() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @return The enum numeric value on the wire for edgeAvailabilityDomain.
     */
    @java.lang.Override
    public int getEdgeAvailabilityDomainValue() {
      return edgeAvailabilityDomain_;
    }
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @param value The enum numeric value on the wire for edgeAvailabilityDomain to set.
     * @return This builder for chaining.
     */
    public Builder setEdgeAvailabilityDomainValue(int value) {
      bitField0_ |= 0x00000100;
      edgeAvailabilityDomain_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @return The edgeAvailabilityDomain.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain
        getEdgeAvailabilityDomain() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain result =
          com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain.valueOf(
              edgeAvailabilityDomain_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @param value The edgeAvailabilityDomain to set.
     * @return This builder for chaining.
     */
    public Builder setEdgeAvailabilityDomain(
        com.google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000100;
      edgeAvailabilityDomain_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values:
     * - AVAILABILITY_DOMAIN_ANY
     * - AVAILABILITY_DOMAIN_1
     * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.EdgeAvailabilityDomain edge_availability_domain = 71289510;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEdgeAvailabilityDomain() {
      bitField0_ = (bitField0_ & ~0x00000100);
      edgeAvailabilityDomain_ = 0;
      onChanged();
      return this;
    }

    private int encryption_ = 0;
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @return Whether the encryption field is set.
     */
    @java.lang.Override
    public boolean hasEncryption() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @return The enum numeric value on the wire for encryption.
     */
    @java.lang.Override
    public int getEncryptionValue() {
      return encryption_;
    }
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @param value The enum numeric value on the wire for encryption to set.
     * @return This builder for chaining.
     */
    public Builder setEncryptionValue(int value) {
      bitField0_ |= 0x00000200;
      encryption_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @return The encryption.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.Encryption getEncryption() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.Encryption result =
          com.google.cloud.compute.v1.InterconnectAttachment.Encryption.valueOf(encryption_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.Encryption.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @param value The encryption to set.
     * @return This builder for chaining.
     */
    public Builder setEncryption(
        com.google.cloud.compute.v1.InterconnectAttachment.Encryption value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000200;
      encryption_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates the user-supplied encryption option of this interconnect attachment:
     * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment.
     * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Encryption encryption = 97980291;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEncryption() {
      bitField0_ = (bitField0_ & ~0x00000200);
      encryption_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object googleReferenceId_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @return Whether the googleReferenceId field is set.
     */
    public boolean hasGoogleReferenceId() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @return The googleReferenceId.
     */
    public java.lang.String getGoogleReferenceId() {
      java.lang.Object ref = googleReferenceId_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        googleReferenceId_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @return The bytes for googleReferenceId.
     */
    public com.google.protobuf.ByteString getGoogleReferenceIdBytes() {
      java.lang.Object ref = googleReferenceId_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        googleReferenceId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @param value The googleReferenceId to set.
     * @return This builder for chaining.
     */
    public Builder setGoogleReferenceId(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000400;
      googleReferenceId_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearGoogleReferenceId() {
      bitField0_ = (bitField0_ & ~0x00000400);
      googleReferenceId_ = getDefaultInstance().getGoogleReferenceId();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
     * </pre>
     *
     * <code>string google_reference_id = 534944469;</code>
     *
     * @param value The bytes for googleReferenceId to set.
     * @return This builder for chaining.
     */
    public Builder setGoogleReferenceIdBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000400;
      googleReferenceId_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object id_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return Whether the id field is set.
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The id.
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The bytes for id.
     */
    public com.google.protobuf.ByteString getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The id to set.
     * @return This builder for chaining.
     */
    public Builder setId(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000800;
      id_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearId() {
      bitField0_ = (bitField0_ & ~0x00000800);
      id_ = getDefaultInstance().getId();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The bytes for id to set.
     * @return This builder for chaining.
     */
    public Builder setIdBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000800;
      id_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object interconnect_ = "";
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @return Whether the interconnect field is set.
     */
    public boolean hasInterconnect() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @return The interconnect.
     */
    public java.lang.String getInterconnect() {
      java.lang.Object ref = interconnect_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        interconnect_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @return The bytes for interconnect.
     */
    public com.google.protobuf.ByteString getInterconnectBytes() {
      java.lang.Object ref = interconnect_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        interconnect_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @param value The interconnect to set.
     * @return This builder for chaining.
     */
    public Builder setInterconnect(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00001000;
      interconnect_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearInterconnect() {
      bitField0_ = (bitField0_ & ~0x00001000);
      interconnect_ = getDefaultInstance().getInterconnect();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of the underlying Interconnect object that this attachment's traffic will traverse through.
     * </pre>
     *
     * <code>string interconnect = 224601230;</code>
     *
     * @param value The bytes for interconnect to set.
     * @return This builder for chaining.
     */
    public Builder setInterconnectBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00001000;
      interconnect_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList ipsecInternalAddresses_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensureIpsecInternalAddressesIsMutable() {
      if (!((bitField0_ & 0x00002000) != 0)) {
        ipsecInternalAddresses_ =
            new com.google.protobuf.LazyStringArrayList(ipsecInternalAddresses_);
        bitField0_ |= 0x00002000;
      }
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @return A list containing the ipsecInternalAddresses.
     */
    public com.google.protobuf.ProtocolStringList getIpsecInternalAddressesList() {
      return ipsecInternalAddresses_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @return The count of ipsecInternalAddresses.
     */
    public int getIpsecInternalAddressesCount() {
      return ipsecInternalAddresses_.size();
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param index The index of the element to return.
     * @return The ipsecInternalAddresses at the given index.
     */
    public java.lang.String getIpsecInternalAddresses(int index) {
      return ipsecInternalAddresses_.get(index);
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the ipsecInternalAddresses at the given index.
     */
    public com.google.protobuf.ByteString getIpsecInternalAddressesBytes(int index) {
      return ipsecInternalAddresses_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param index The index to set the value at.
     * @param value The ipsecInternalAddresses to set.
     * @return This builder for chaining.
     */
    public Builder setIpsecInternalAddresses(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureIpsecInternalAddressesIsMutable();
      ipsecInternalAddresses_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param value The ipsecInternalAddresses to add.
     * @return This builder for chaining.
     */
    public Builder addIpsecInternalAddresses(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureIpsecInternalAddressesIsMutable();
      ipsecInternalAddresses_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param values The ipsecInternalAddresses to add.
     * @return This builder for chaining.
     */
    public Builder addAllIpsecInternalAddresses(java.lang.Iterable<java.lang.String> values) {
      ensureIpsecInternalAddressesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ipsecInternalAddresses_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIpsecInternalAddresses() {
      ipsecInternalAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of addresses that have been reserved for the interconnect attachment, Used only for interconnect attachment that has the encryption option as IPSEC. The addresses must be RFC 1918 IP address ranges. When creating HA VPN gateway over the interconnect attachment, if the attachment is configured to use an RFC 1918 IP address, then the VPN gateway's IP address will be allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this interconnect attachment, then an RFC 1918 IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this interconnect attachment. If this field is not specified for interconnect attachment that has encryption option as IPSEC, later on when creating HA VPN gateway on this interconnect attachment, the HA VPN gateway's IP address will be allocated from regional external IP address pool.
     * Not currently available in all Interconnect locations.
     * </pre>
     *
     * <code>repeated string ipsec_internal_addresses = 407648565;</code>
     *
     * @param value The bytes of the ipsecInternalAddresses to add.
     * @return This builder for chaining.
     */
    public Builder addIpsecInternalAddressesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureIpsecInternalAddressesIsMutable();
      ipsecInternalAddresses_.add(value);
      onChanged();
      return this;
    }

    private java.lang.Object kind_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return Whether the kind field is set.
     */
    public boolean hasKind() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The kind.
     */
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        kind_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The bytes for kind.
     */
    public com.google.protobuf.ByteString getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The kind to set.
     * @return This builder for chaining.
     */
    public Builder setKind(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00004000;
      kind_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearKind() {
      bitField0_ = (bitField0_ & ~0x00004000);
      kind_ = getDefaultInstance().getKind();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The bytes for kind to set.
     * @return This builder for chaining.
     */
    public Builder setKindBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00004000;
      kind_ = value;
      onChanged();
      return this;
    }

    private int mtu_;
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
     * </pre>
     *
     * <code>int32 mtu = 108462;</code>
     *
     * @return Whether the mtu field is set.
     */
    @java.lang.Override
    public boolean hasMtu() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
     * </pre>
     *
     * <code>int32 mtu = 108462;</code>
     *
     * @return The mtu.
     */
    @java.lang.Override
    public int getMtu() {
      return mtu_;
    }
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
     * </pre>
     *
     * <code>int32 mtu = 108462;</code>
     *
     * @param value The mtu to set.
     * @return This builder for chaining.
     */
    public Builder setMtu(int value) {
      bitField0_ |= 0x00008000;
      mtu_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
     * </pre>
     *
     * <code>int32 mtu = 108462;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMtu() {
      bitField0_ = (bitField0_ & ~0x00008000);
      mtu_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object name_ = "";
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return Whether the name field is set.
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00010000;
      name_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearName() {
      bitField0_ = (bitField0_ & ~0x00010000);
      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00010000;
      name_ = value;
      onChanged();
      return this;
    }

    private int operationalStatus_ = 0;
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @return Whether the operationalStatus field is set.
     */
    @java.lang.Override
    public boolean hasOperationalStatus() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @return The enum numeric value on the wire for operationalStatus.
     */
    @java.lang.Override
    public int getOperationalStatusValue() {
      return operationalStatus_;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @param value The enum numeric value on the wire for operationalStatus to set.
     * @return This builder for chaining.
     */
    public Builder setOperationalStatusValue(int value) {
      bitField0_ |= 0x00020000;
      operationalStatus_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @return The operationalStatus.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus
        getOperationalStatus() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus result =
          com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus.valueOf(
              operationalStatus_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @param value The operationalStatus to set.
     * @return This builder for chaining.
     */
    public Builder setOperationalStatus(
        com.google.cloud.compute.v1.InterconnectAttachment.OperationalStatus value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00020000;
      operationalStatus_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values:
     * - OS_ACTIVE: The attachment has been turned up and is ready to use.
     * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachment.OperationalStatus operational_status = 201070847;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearOperationalStatus() {
      bitField0_ = (bitField0_ & ~0x00020000);
      operationalStatus_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object pairingKey_ = "";
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @return Whether the pairingKey field is set.
     */
    public boolean hasPairingKey() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @return The pairingKey.
     */
    public java.lang.String getPairingKey() {
      java.lang.Object ref = pairingKey_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        pairingKey_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @return The bytes for pairingKey.
     */
    public com.google.protobuf.ByteString getPairingKeyBytes() {
      java.lang.Object ref = pairingKey_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        pairingKey_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @param value The pairingKey to set.
     * @return This builder for chaining.
     */
    public Builder setPairingKey(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00040000;
      pairingKey_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPairingKey() {
      bitField0_ = (bitField0_ & ~0x00040000);
      pairingKey_ = getDefaultInstance().getPairingKey();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of an PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
     * </pre>
     *
     * <code>string pairing_key = 439695464;</code>
     *
     * @param value The bytes for pairingKey to set.
     * @return This builder for chaining.
     */
    public Builder setPairingKeyBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00040000;
      pairingKey_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object partnerAsn_ = "";
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @return Whether the partnerAsn field is set.
     */
    public boolean hasPartnerAsn() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @return The partnerAsn.
     */
    public java.lang.String getPartnerAsn() {
      java.lang.Object ref = partnerAsn_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        partnerAsn_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @return The bytes for partnerAsn.
     */
    public com.google.protobuf.ByteString getPartnerAsnBytes() {
      java.lang.Object ref = partnerAsn_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        partnerAsn_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @param value The partnerAsn to set.
     * @return This builder for chaining.
     */
    public Builder setPartnerAsn(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00080000;
      partnerAsn_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPartnerAsn() {
      bitField0_ = (bitField0_ & ~0x00080000);
      partnerAsn_ = getDefaultInstance().getPartnerAsn();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>string partner_asn = 438166149;</code>
     *
     * @param value The bytes for partnerAsn to set.
     * @return This builder for chaining.
     */
    public Builder setPartnerAsnBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00080000;
      partnerAsn_ = value;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partnerMetadata_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata,
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder,
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadataOrBuilder>
        partnerMetadataBuilder_;
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     *
     * @return Whether the partnerMetadata field is set.
     */
    public boolean hasPartnerMetadata() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     *
     * @return The partnerMetadata.
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata getPartnerMetadata() {
      if (partnerMetadataBuilder_ == null) {
        return partnerMetadata_ == null
            ? com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.getDefaultInstance()
            : partnerMetadata_;
      } else {
        return partnerMetadataBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public Builder setPartnerMetadata(
        com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata value) {
      if (partnerMetadataBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        partnerMetadata_ = value;
        onChanged();
      } else {
        partnerMetadataBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00100000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public Builder setPartnerMetadata(
        com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder builderForValue) {
      if (partnerMetadataBuilder_ == null) {
        partnerMetadata_ = builderForValue.build();
        onChanged();
      } else {
        partnerMetadataBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00100000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public Builder mergePartnerMetadata(
        com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata value) {
      if (partnerMetadataBuilder_ == null) {
        if (((bitField0_ & 0x00100000) != 0)
            && partnerMetadata_ != null
            && partnerMetadata_
                != com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata
                    .getDefaultInstance()) {
          partnerMetadata_ =
              com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.newBuilder(
                      partnerMetadata_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          partnerMetadata_ = value;
        }
        onChanged();
      } else {
        partnerMetadataBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00100000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public Builder clearPartnerMetadata() {
      if (partnerMetadataBuilder_ == null) {
        partnerMetadata_ = null;
        onChanged();
      } else {
        partnerMetadataBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00100000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder
        getPartnerMetadataBuilder() {
      bitField0_ |= 0x00100000;
      onChanged();
      return getPartnerMetadataFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadataOrBuilder
        getPartnerMetadataOrBuilder() {
      if (partnerMetadataBuilder_ != null) {
        return partnerMetadataBuilder_.getMessageOrBuilder();
      } else {
        return partnerMetadata_ == null
            ? com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.getDefaultInstance()
            : partnerMetadata_;
      }
    }
    /**
     *
     *
     * <pre>
     * Informational metadata about Partner attachments from Partners to display to customers. Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not available for DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata partner_metadata = 65908934;
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata,
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder,
            com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadataOrBuilder>
        getPartnerMetadataFieldBuilder() {
      if (partnerMetadataBuilder_ == null) {
        partnerMetadataBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata,
                com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadata.Builder,
                com.google.cloud.compute.v1.InterconnectAttachmentPartnerMetadataOrBuilder>(
                getPartnerMetadata(), getParentForChildren(), isClean());
        partnerMetadata_ = null;
      }
      return partnerMetadataBuilder_;
    }

    private com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo privateInterconnectInfo_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo,
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder,
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfoOrBuilder>
        privateInterconnectInfoBuilder_;
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     *
     * @return Whether the privateInterconnectInfo field is set.
     */
    public boolean hasPrivateInterconnectInfo() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     *
     * @return The privateInterconnectInfo.
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo
        getPrivateInterconnectInfo() {
      if (privateInterconnectInfoBuilder_ == null) {
        return privateInterconnectInfo_ == null
            ? com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.getDefaultInstance()
            : privateInterconnectInfo_;
      } else {
        return privateInterconnectInfoBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public Builder setPrivateInterconnectInfo(
        com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo value) {
      if (privateInterconnectInfoBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        privateInterconnectInfo_ = value;
        onChanged();
      } else {
        privateInterconnectInfoBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00200000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public Builder setPrivateInterconnectInfo(
        com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder builderForValue) {
      if (privateInterconnectInfoBuilder_ == null) {
        privateInterconnectInfo_ = builderForValue.build();
        onChanged();
      } else {
        privateInterconnectInfoBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00200000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public Builder mergePrivateInterconnectInfo(
        com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo value) {
      if (privateInterconnectInfoBuilder_ == null) {
        if (((bitField0_ & 0x00200000) != 0)
            && privateInterconnectInfo_ != null
            && privateInterconnectInfo_
                != com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo
                    .getDefaultInstance()) {
          privateInterconnectInfo_ =
              com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.newBuilder(
                      privateInterconnectInfo_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          privateInterconnectInfo_ = value;
        }
        onChanged();
      } else {
        privateInterconnectInfoBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00200000;
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public Builder clearPrivateInterconnectInfo() {
      if (privateInterconnectInfoBuilder_ == null) {
        privateInterconnectInfo_ = null;
        onChanged();
      } else {
        privateInterconnectInfoBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00200000);
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder
        getPrivateInterconnectInfoBuilder() {
      bitField0_ |= 0x00200000;
      onChanged();
      return getPrivateInterconnectInfoFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    public com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfoOrBuilder
        getPrivateInterconnectInfoOrBuilder() {
      if (privateInterconnectInfoBuilder_ != null) {
        return privateInterconnectInfoBuilder_.getMessageOrBuilder();
      } else {
        return privateInterconnectInfo_ == null
            ? com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.getDefaultInstance()
            : privateInterconnectInfo_;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Information specific to an InterconnectAttachment. This property is populated if the interconnect that this is attached to is of type DEDICATED.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.InterconnectAttachmentPrivateInfo private_interconnect_info = 237270531;
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo,
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder,
            com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfoOrBuilder>
        getPrivateInterconnectInfoFieldBuilder() {
      if (privateInterconnectInfoBuilder_ == null) {
        privateInterconnectInfoBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo,
                com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfo.Builder,
                com.google.cloud.compute.v1.InterconnectAttachmentPrivateInfoOrBuilder>(
                getPrivateInterconnectInfo(), getParentForChildren(), isClean());
        privateInterconnectInfo_ = null;
      }
      return privateInterconnectInfoBuilder_;
    }

    private java.lang.Object region_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return Whether the region field is set.
     */
    public boolean hasRegion() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The region.
     */
    public java.lang.String getRegion() {
      java.lang.Object ref = region_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        region_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The bytes for region.
     */
    public com.google.protobuf.ByteString getRegionBytes() {
      java.lang.Object ref = region_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        region_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The region to set.
     * @return This builder for chaining.
     */
    public Builder setRegion(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00400000;
      region_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearRegion() {
      bitField0_ = (bitField0_ & ~0x00400000);
      region_ = getDefaultInstance().getRegion();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The bytes for region to set.
     * @return This builder for chaining.
     */
    public Builder setRegionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00400000;
      region_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object router_ = "";
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @return Whether the router field is set.
     */
    public boolean hasRouter() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @return The router.
     */
    public java.lang.String getRouter() {
      java.lang.Object ref = router_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        router_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @return The bytes for router.
     */
    public com.google.protobuf.ByteString getRouterBytes() {
      java.lang.Object ref = router_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        router_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @param value The router to set.
     * @return This builder for chaining.
     */
    public Builder setRouter(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00800000;
      router_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearRouter() {
      bitField0_ = (bitField0_ & ~0x00800000);
      router_ = getDefaultInstance().getRouter();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network &amp; region within which the Cloud Router is configured.
     * </pre>
     *
     * <code>string router = 148608841;</code>
     *
     * @param value The bytes for router to set.
     * @return This builder for chaining.
     */
    public Builder setRouterBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00800000;
      router_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object selfLink_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return Whether the selfLink field is set.
     */
    public boolean hasSelfLink() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The selfLink.
     */
    public java.lang.String getSelfLink() {
      java.lang.Object ref = selfLink_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        selfLink_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The bytes for selfLink.
     */
    public com.google.protobuf.ByteString getSelfLinkBytes() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        selfLink_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLink(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x01000000;
      selfLink_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSelfLink() {
      bitField0_ = (bitField0_ & ~0x01000000);
      selfLink_ = getDefaultInstance().getSelfLink();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The bytes for selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLinkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x01000000;
      selfLink_ = value;
      onChanged();
      return this;
    }

    private int state_ = 0;
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @return Whether the state field is set.
     */
    @java.lang.Override
    public boolean hasState() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override
    public int getStateValue() {
      return state_;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @param value The enum numeric value on the wire for state to set.
     * @return This builder for chaining.
     */
    public Builder setStateValue(int value) {
      bitField0_ |= 0x02000000;
      state_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @return The state.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.State getState() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.State result =
          com.google.cloud.compute.v1.InterconnectAttachment.State.valueOf(state_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.State.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @param value The state to set.
     * @return This builder for chaining.
     */
    public Builder setState(com.google.cloud.compute.v1.InterconnectAttachment.State value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x02000000;
      state_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values:
     * - ACTIVE: The attachment has been turned up and is ready to use.
     * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
     * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side.
     * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
     * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it.
     * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.State state = 109757585;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearState() {
      bitField0_ = (bitField0_ & ~0x02000000);
      state_ = 0;
      onChanged();
      return this;
    }

    private int type_ = 0;
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override
    public int getTypeValue() {
      return type_;
    }
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @param value The enum numeric value on the wire for type to set.
     * @return This builder for chaining.
     */
    public Builder setTypeValue(int value) {
      bitField0_ |= 0x04000000;
      type_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @return The type.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.InterconnectAttachment.Type getType() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.InterconnectAttachment.Type result =
          com.google.cloud.compute.v1.InterconnectAttachment.Type.valueOf(type_);
      return result == null
          ? com.google.cloud.compute.v1.InterconnectAttachment.Type.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @param value The type to set.
     * @return This builder for chaining.
     */
    public Builder setType(com.google.cloud.compute.v1.InterconnectAttachment.Type value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x04000000;
      type_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The type of interconnect attachment this is, which can take one of the following values:
     * - DEDICATED: an attachment to a Dedicated Interconnect.
     * - PARTNER: an attachment to a Partner Interconnect, created by the customer.
     * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.InterconnectAttachment.Type type = 3575610;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearType() {
      bitField0_ = (bitField0_ & ~0x04000000);
      type_ = 0;
      onChanged();
      return this;
    }

    private int vlanTag8021Q_;
    /**
     *
     *
     * <pre>
     * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
     * </pre>
     *
     * <code>int32 vlan_tag8021q = 119927836;</code>
     *
     * @return Whether the vlanTag8021q field is set.
     */
    @java.lang.Override
    public boolean hasVlanTag8021Q() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
     * </pre>
     *
     * <code>int32 vlan_tag8021q = 119927836;</code>
     *
     * @return The vlanTag8021q.
     */
    @java.lang.Override
    public int getVlanTag8021Q() {
      return vlanTag8021Q_;
    }
    /**
     *
     *
     * <pre>
     * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
     * </pre>
     *
     * <code>int32 vlan_tag8021q = 119927836;</code>
     *
     * @param value The vlanTag8021q to set.
     * @return This builder for chaining.
     */
    public Builder setVlanTag8021Q(int value) {
      bitField0_ |= 0x08000000;
      vlanTag8021Q_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only specified at creation time.
     * </pre>
     *
     * <code>int32 vlan_tag8021q = 119927836;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearVlanTag8021Q() {
      bitField0_ = (bitField0_ & ~0x08000000);
      vlanTag8021Q_ = 0;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.InterconnectAttachment)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.InterconnectAttachment)
  private static final com.google.cloud.compute.v1.InterconnectAttachment DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.InterconnectAttachment();
  }

  public static com.google.cloud.compute.v1.InterconnectAttachment getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<InterconnectAttachment> PARSER =
      new com.google.protobuf.AbstractParser<InterconnectAttachment>() {
        @java.lang.Override
        public InterconnectAttachment parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new InterconnectAttachment(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<InterconnectAttachment> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<InterconnectAttachment> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.InterconnectAttachment getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
