/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

// Protobuf Java Version: 3.25.5
package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures}
 */
public final class NetworkProfileNetworkFeatures extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
    NetworkProfileNetworkFeaturesOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use NetworkProfileNetworkFeatures.newBuilder() to construct.
  private NetworkProfileNetworkFeatures(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private NetworkProfileNetworkFeatures() {
    addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    allowAliasIpRanges_ = "";
    allowAutoModeSubnet_ = "";
    allowClassDFirewalls_ = "";
    allowCloudNat_ = "";
    allowCloudRouter_ = "";
    allowExternalIpAccess_ = "";
    allowInterconnect_ = "";
    allowLoadBalancing_ = "";
    allowMultiNicInSameNetwork_ = "";
    allowPacketMirroring_ = "";
    allowPrivateGoogleAccess_ = "";
    allowPsc_ = "";
    allowSameNetworkUnicast_ = "";
    allowStaticRoutes_ = "";
    allowSubInterfaces_ = "";
    allowVpcPeering_ = "";
    allowVpn_ = "";
    interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    unicast_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new NetworkProfileNetworkFeatures();
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.class,
            com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AddressPurposes}
   */
  public enum AddressPurposes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ADDRESS_PURPOSES = 0;</code>
     */
    UNDEFINED_ADDRESS_PURPOSES(0),
    /**
     *
     *
     * <pre>
     * DNS resolver address in the subnetwork.
     * </pre>
     *
     * <code>DNS_RESOLVER = 476114556;</code>
     */
    DNS_RESOLVER(476114556),
    /**
     *
     *
     * <pre>
     * VM internal/alias IP, Internal LB service IP, etc.
     * </pre>
     *
     * <code>GCE_ENDPOINT = 230515243;</code>
     */
    GCE_ENDPOINT(230515243),
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for the VLAN attachment that is used in HA VPN over Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachment’s IP address range.
     * </pre>
     *
     * <code>IPSEC_INTERCONNECT = 340437251;</code>
     */
    IPSEC_INTERCONNECT(340437251),
    /**
     *
     *
     * <pre>
     * External IP automatically reserved for Cloud NAT.
     * </pre>
     *
     * <code>NAT_AUTO = 163666477;</code>
     */
    NAT_AUTO(163666477),
    /**
     *
     *
     * <pre>
     * A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
     * </pre>
     *
     * <code>PRIVATE_SERVICE_CONNECT = 48134724;</code>
     */
    PRIVATE_SERVICE_CONNECT(48134724),
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for Serverless.
     * </pre>
     *
     * <code>SERVERLESS = 270492508;</code>
     */
    SERVERLESS(270492508),
    /**
     *
     *
     * <pre>
     * A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
     * </pre>
     *
     * <code>SHARED_LOADBALANCER_VIP = 294447572;</code>
     */
    SHARED_LOADBALANCER_VIP(294447572),
    /**
     *
     *
     * <pre>
     * IP range for peer networks.
     * </pre>
     *
     * <code>VPC_PEERING = 400800170;</code>
     */
    VPC_PEERING(400800170),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ADDRESS_PURPOSES = 0;</code>
     */
    public static final int UNDEFINED_ADDRESS_PURPOSES_VALUE = 0;
    /**
     *
     *
     * <pre>
     * DNS resolver address in the subnetwork.
     * </pre>
     *
     * <code>DNS_RESOLVER = 476114556;</code>
     */
    public static final int DNS_RESOLVER_VALUE = 476114556;
    /**
     *
     *
     * <pre>
     * VM internal/alias IP, Internal LB service IP, etc.
     * </pre>
     *
     * <code>GCE_ENDPOINT = 230515243;</code>
     */
    public static final int GCE_ENDPOINT_VALUE = 230515243;
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for the VLAN attachment that is used in HA VPN over Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachment’s IP address range.
     * </pre>
     *
     * <code>IPSEC_INTERCONNECT = 340437251;</code>
     */
    public static final int IPSEC_INTERCONNECT_VALUE = 340437251;
    /**
     *
     *
     * <pre>
     * External IP automatically reserved for Cloud NAT.
     * </pre>
     *
     * <code>NAT_AUTO = 163666477;</code>
     */
    public static final int NAT_AUTO_VALUE = 163666477;
    /**
     *
     *
     * <pre>
     * A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
     * </pre>
     *
     * <code>PRIVATE_SERVICE_CONNECT = 48134724;</code>
     */
    public static final int PRIVATE_SERVICE_CONNECT_VALUE = 48134724;
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for Serverless.
     * </pre>
     *
     * <code>SERVERLESS = 270492508;</code>
     */
    public static final int SERVERLESS_VALUE = 270492508;
    /**
     *
     *
     * <pre>
     * A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
     * </pre>
     *
     * <code>SHARED_LOADBALANCER_VIP = 294447572;</code>
     */
    public static final int SHARED_LOADBALANCER_VIP_VALUE = 294447572;
    /**
     *
     *
     * <pre>
     * IP range for peer networks.
     * </pre>
     *
     * <code>VPC_PEERING = 400800170;</code>
     */
    public static final int VPC_PEERING_VALUE = 400800170;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AddressPurposes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AddressPurposes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ADDRESS_PURPOSES;
        case 476114556:
          return DNS_RESOLVER;
        case 230515243:
          return GCE_ENDPOINT;
        case 340437251:
          return IPSEC_INTERCONNECT;
        case 163666477:
          return NAT_AUTO;
        case 48134724:
          return PRIVATE_SERVICE_CONNECT;
        case 270492508:
          return SERVERLESS;
        case 294447572:
          return SHARED_LOADBALANCER_VIP;
        case 400800170:
          return VPC_PEERING;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AddressPurposes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AddressPurposes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AddressPurposes>() {
              public AddressPurposes findValueByNumber(int number) {
                return AddressPurposes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(0);
    }

    private static final AddressPurposes[] VALUES = values();

    public static AddressPurposes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AddressPurposes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AddressPurposes)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAliasIpRanges}
   */
  public enum AllowAliasIpRanges implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ALIAS_IP_RANGES = 0;</code>
     */
    UNDEFINED_ALLOW_ALIAS_IP_RANGES(0),
    /** <code>ALIAS_IP_RANGES_ALLOWED = 464867048;</code> */
    ALIAS_IP_RANGES_ALLOWED(464867048),
    /** <code>ALIAS_IP_RANGES_BLOCKED = 281030444;</code> */
    ALIAS_IP_RANGES_BLOCKED(281030444),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ALIAS_IP_RANGES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_ALIAS_IP_RANGES_VALUE = 0;
    /** <code>ALIAS_IP_RANGES_ALLOWED = 464867048;</code> */
    public static final int ALIAS_IP_RANGES_ALLOWED_VALUE = 464867048;
    /** <code>ALIAS_IP_RANGES_BLOCKED = 281030444;</code> */
    public static final int ALIAS_IP_RANGES_BLOCKED_VALUE = 281030444;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowAliasIpRanges valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowAliasIpRanges forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_ALIAS_IP_RANGES;
        case 464867048:
          return ALIAS_IP_RANGES_ALLOWED;
        case 281030444:
          return ALIAS_IP_RANGES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>() {
              public AllowAliasIpRanges findValueByNumber(int number) {
                return AllowAliasIpRanges.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(1);
    }

    private static final AllowAliasIpRanges[] VALUES = values();

    public static AllowAliasIpRanges valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowAliasIpRanges(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAliasIpRanges)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAutoModeSubnet}
   */
  public enum AllowAutoModeSubnet implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_AUTO_MODE_SUBNET = 0;</code>
     */
    UNDEFINED_ALLOW_AUTO_MODE_SUBNET(0),
    /** <code>AUTO_MODE_SUBNET_ALLOWED = 391042610;</code> */
    AUTO_MODE_SUBNET_ALLOWED(391042610),
    /** <code>AUTO_MODE_SUBNET_BLOCKED = 207206006;</code> */
    AUTO_MODE_SUBNET_BLOCKED(207206006),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_AUTO_MODE_SUBNET = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_AUTO_MODE_SUBNET_VALUE = 0;
    /** <code>AUTO_MODE_SUBNET_ALLOWED = 391042610;</code> */
    public static final int AUTO_MODE_SUBNET_ALLOWED_VALUE = 391042610;
    /** <code>AUTO_MODE_SUBNET_BLOCKED = 207206006;</code> */
    public static final int AUTO_MODE_SUBNET_BLOCKED_VALUE = 207206006;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowAutoModeSubnet valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowAutoModeSubnet forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_AUTO_MODE_SUBNET;
        case 391042610:
          return AUTO_MODE_SUBNET_ALLOWED;
        case 207206006:
          return AUTO_MODE_SUBNET_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>() {
              public AllowAutoModeSubnet findValueByNumber(int number) {
                return AllowAutoModeSubnet.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(2);
    }

    private static final AllowAutoModeSubnet[] VALUES = values();

    public static AllowAutoModeSubnet valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowAutoModeSubnet(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAutoModeSubnet)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowClassDFirewalls}
   */
  public enum AllowClassDFirewalls implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLASS_D_FIREWALLS = 0;</code>
     */
    UNDEFINED_ALLOW_CLASS_D_FIREWALLS(0),
    /** <code>CLASS_D_FIREWALLS_ALLOWED = 348219386;</code> */
    CLASS_D_FIREWALLS_ALLOWED(348219386),
    /** <code>CLASS_D_FIREWALLS_BLOCKED = 164382782;</code> */
    CLASS_D_FIREWALLS_BLOCKED(164382782),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLASS_D_FIREWALLS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLASS_D_FIREWALLS_VALUE = 0;
    /** <code>CLASS_D_FIREWALLS_ALLOWED = 348219386;</code> */
    public static final int CLASS_D_FIREWALLS_ALLOWED_VALUE = 348219386;
    /** <code>CLASS_D_FIREWALLS_BLOCKED = 164382782;</code> */
    public static final int CLASS_D_FIREWALLS_BLOCKED_VALUE = 164382782;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowClassDFirewalls valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowClassDFirewalls forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLASS_D_FIREWALLS;
        case 348219386:
          return CLASS_D_FIREWALLS_ALLOWED;
        case 164382782:
          return CLASS_D_FIREWALLS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>() {
              public AllowClassDFirewalls findValueByNumber(int number) {
                return AllowClassDFirewalls.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(3);
    }

    private static final AllowClassDFirewalls[] VALUES = values();

    public static AllowClassDFirewalls valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowClassDFirewalls(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowClassDFirewalls)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudNat}
   */
  public enum AllowCloudNat implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_NAT = 0;</code>
     */
    UNDEFINED_ALLOW_CLOUD_NAT(0),
    /** <code>CLOUD_NAT_ALLOWED = 245931296;</code> */
    CLOUD_NAT_ALLOWED(245931296),
    /** <code>CLOUD_NAT_BLOCKED = 62094692;</code> */
    CLOUD_NAT_BLOCKED(62094692),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_NAT = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLOUD_NAT_VALUE = 0;
    /** <code>CLOUD_NAT_ALLOWED = 245931296;</code> */
    public static final int CLOUD_NAT_ALLOWED_VALUE = 245931296;
    /** <code>CLOUD_NAT_BLOCKED = 62094692;</code> */
    public static final int CLOUD_NAT_BLOCKED_VALUE = 62094692;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowCloudNat valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowCloudNat forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLOUD_NAT;
        case 245931296:
          return CLOUD_NAT_ALLOWED;
        case 62094692:
          return CLOUD_NAT_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat>() {
          public AllowCloudNat findValueByNumber(int number) {
            return AllowCloudNat.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(4);
    }

    private static final AllowCloudNat[] VALUES = values();

    public static AllowCloudNat valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowCloudNat(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudNat)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudRouter}
   */
  public enum AllowCloudRouter implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_ROUTER = 0;</code>
     */
    UNDEFINED_ALLOW_CLOUD_ROUTER(0),
    /** <code>CLOUD_ROUTER_ALLOWED = 365388284;</code> */
    CLOUD_ROUTER_ALLOWED(365388284),
    /** <code>CLOUD_ROUTER_BLOCKED = 181551680;</code> */
    CLOUD_ROUTER_BLOCKED(181551680),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_ROUTER = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLOUD_ROUTER_VALUE = 0;
    /** <code>CLOUD_ROUTER_ALLOWED = 365388284;</code> */
    public static final int CLOUD_ROUTER_ALLOWED_VALUE = 365388284;
    /** <code>CLOUD_ROUTER_BLOCKED = 181551680;</code> */
    public static final int CLOUD_ROUTER_BLOCKED_VALUE = 181551680;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowCloudRouter valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowCloudRouter forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLOUD_ROUTER;
        case 365388284:
          return CLOUD_ROUTER_ALLOWED;
        case 181551680:
          return CLOUD_ROUTER_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter>() {
              public AllowCloudRouter findValueByNumber(int number) {
                return AllowCloudRouter.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(5);
    }

    private static final AllowCloudRouter[] VALUES = values();

    public static AllowCloudRouter valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowCloudRouter(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudRouter)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowExternalIpAccess}
   */
  public enum AllowExternalIpAccess implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS = 0;</code>
     */
    UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS(0),
    /** <code>EXTERNAL_IP_ACCESS_ALLOWED = 109530193;</code> */
    EXTERNAL_IP_ACCESS_ALLOWED(109530193),
    /** <code>EXTERNAL_IP_ACCESS_BLOCKED = 462564501;</code> */
    EXTERNAL_IP_ACCESS_BLOCKED(462564501),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS_VALUE = 0;
    /** <code>EXTERNAL_IP_ACCESS_ALLOWED = 109530193;</code> */
    public static final int EXTERNAL_IP_ACCESS_ALLOWED_VALUE = 109530193;
    /** <code>EXTERNAL_IP_ACCESS_BLOCKED = 462564501;</code> */
    public static final int EXTERNAL_IP_ACCESS_BLOCKED_VALUE = 462564501;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowExternalIpAccess valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowExternalIpAccess forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS;
        case 109530193:
          return EXTERNAL_IP_ACCESS_ALLOWED;
        case 462564501:
          return EXTERNAL_IP_ACCESS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>() {
              public AllowExternalIpAccess findValueByNumber(int number) {
                return AllowExternalIpAccess.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(6);
    }

    private static final AllowExternalIpAccess[] VALUES = values();

    public static AllowExternalIpAccess valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowExternalIpAccess(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowExternalIpAccess)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowInterconnect}
   */
  public enum AllowInterconnect implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_INTERCONNECT = 0;</code>
     */
    UNDEFINED_ALLOW_INTERCONNECT(0),
    /** <code>INTERCONNECT_ALLOWED = 162845399;</code> */
    INTERCONNECT_ALLOWED(162845399),
    /** <code>INTERCONNECT_BLOCKED = 515879707;</code> */
    INTERCONNECT_BLOCKED(515879707),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_INTERCONNECT = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_INTERCONNECT_VALUE = 0;
    /** <code>INTERCONNECT_ALLOWED = 162845399;</code> */
    public static final int INTERCONNECT_ALLOWED_VALUE = 162845399;
    /** <code>INTERCONNECT_BLOCKED = 515879707;</code> */
    public static final int INTERCONNECT_BLOCKED_VALUE = 515879707;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowInterconnect valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowInterconnect forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_INTERCONNECT;
        case 162845399:
          return INTERCONNECT_ALLOWED;
        case 515879707:
          return INTERCONNECT_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>() {
              public AllowInterconnect findValueByNumber(int number) {
                return AllowInterconnect.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(7);
    }

    private static final AllowInterconnect[] VALUES = values();

    public static AllowInterconnect valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowInterconnect(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowInterconnect)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowLoadBalancing}
   */
  public enum AllowLoadBalancing implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_LOAD_BALANCING = 0;</code>
     */
    UNDEFINED_ALLOW_LOAD_BALANCING(0),
    /** <code>LOAD_BALANCING_ALLOWED = 28407977;</code> */
    LOAD_BALANCING_ALLOWED(28407977),
    /** <code>LOAD_BALANCING_BLOCKED = 381442285;</code> */
    LOAD_BALANCING_BLOCKED(381442285),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_LOAD_BALANCING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_LOAD_BALANCING_VALUE = 0;
    /** <code>LOAD_BALANCING_ALLOWED = 28407977;</code> */
    public static final int LOAD_BALANCING_ALLOWED_VALUE = 28407977;
    /** <code>LOAD_BALANCING_BLOCKED = 381442285;</code> */
    public static final int LOAD_BALANCING_BLOCKED_VALUE = 381442285;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowLoadBalancing valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowLoadBalancing forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_LOAD_BALANCING;
        case 28407977:
          return LOAD_BALANCING_ALLOWED;
        case 381442285:
          return LOAD_BALANCING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>() {
              public AllowLoadBalancing findValueByNumber(int number) {
                return AllowLoadBalancing.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(8);
    }

    private static final AllowLoadBalancing[] VALUES = values();

    public static AllowLoadBalancing valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowLoadBalancing(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowLoadBalancing)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameNetwork}
   */
  public enum AllowMultiNicInSameNetwork implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK = 0;</code>
     */
    UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK(0),
    /** <code>MULTI_NIC_IN_SAME_NETWORK_ALLOWED = 457555419;</code> */
    MULTI_NIC_IN_SAME_NETWORK_ALLOWED(457555419),
    /** <code>MULTI_NIC_IN_SAME_NETWORK_BLOCKED = 273718815;</code> */
    MULTI_NIC_IN_SAME_NETWORK_BLOCKED(273718815),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK_VALUE = 0;
    /** <code>MULTI_NIC_IN_SAME_NETWORK_ALLOWED = 457555419;</code> */
    public static final int MULTI_NIC_IN_SAME_NETWORK_ALLOWED_VALUE = 457555419;
    /** <code>MULTI_NIC_IN_SAME_NETWORK_BLOCKED = 273718815;</code> */
    public static final int MULTI_NIC_IN_SAME_NETWORK_BLOCKED_VALUE = 273718815;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowMultiNicInSameNetwork valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowMultiNicInSameNetwork forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK;
        case 457555419:
          return MULTI_NIC_IN_SAME_NETWORK_ALLOWED;
        case 273718815:
          return MULTI_NIC_IN_SAME_NETWORK_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>() {
              public AllowMultiNicInSameNetwork findValueByNumber(int number) {
                return AllowMultiNicInSameNetwork.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(9);
    }

    private static final AllowMultiNicInSameNetwork[] VALUES = values();

    public static AllowMultiNicInSameNetwork valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowMultiNicInSameNetwork(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameNetwork)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPacketMirroring}
   */
  public enum AllowPacketMirroring implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PACKET_MIRRORING = 0;</code>
     */
    UNDEFINED_ALLOW_PACKET_MIRRORING(0),
    /** <code>PACKET_MIRRORING_ALLOWED = 92416245;</code> */
    PACKET_MIRRORING_ALLOWED(92416245),
    /** <code>PACKET_MIRRORING_BLOCKED = 445450553;</code> */
    PACKET_MIRRORING_BLOCKED(445450553),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PACKET_MIRRORING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PACKET_MIRRORING_VALUE = 0;
    /** <code>PACKET_MIRRORING_ALLOWED = 92416245;</code> */
    public static final int PACKET_MIRRORING_ALLOWED_VALUE = 92416245;
    /** <code>PACKET_MIRRORING_BLOCKED = 445450553;</code> */
    public static final int PACKET_MIRRORING_BLOCKED_VALUE = 445450553;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPacketMirroring valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPacketMirroring forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PACKET_MIRRORING;
        case 92416245:
          return PACKET_MIRRORING_ALLOWED;
        case 445450553:
          return PACKET_MIRRORING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>() {
              public AllowPacketMirroring findValueByNumber(int number) {
                return AllowPacketMirroring.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(10);
    }

    private static final AllowPacketMirroring[] VALUES = values();

    public static AllowPacketMirroring valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPacketMirroring(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPacketMirroring)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPrivateGoogleAccess}
   */
  public enum AllowPrivateGoogleAccess implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS = 0;</code>
     */
    UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS(0),
    /** <code>PRIVATE_GOOGLE_ACCESS_ALLOWED = 220787351;</code> */
    PRIVATE_GOOGLE_ACCESS_ALLOWED(220787351),
    /** <code>PRIVATE_GOOGLE_ACCESS_BLOCKED = 36950747;</code> */
    PRIVATE_GOOGLE_ACCESS_BLOCKED(36950747),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS_VALUE = 0;
    /** <code>PRIVATE_GOOGLE_ACCESS_ALLOWED = 220787351;</code> */
    public static final int PRIVATE_GOOGLE_ACCESS_ALLOWED_VALUE = 220787351;
    /** <code>PRIVATE_GOOGLE_ACCESS_BLOCKED = 36950747;</code> */
    public static final int PRIVATE_GOOGLE_ACCESS_BLOCKED_VALUE = 36950747;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPrivateGoogleAccess valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPrivateGoogleAccess forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS;
        case 220787351:
          return PRIVATE_GOOGLE_ACCESS_ALLOWED;
        case 36950747:
          return PRIVATE_GOOGLE_ACCESS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>() {
              public AllowPrivateGoogleAccess findValueByNumber(int number) {
                return AllowPrivateGoogleAccess.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(11);
    }

    private static final AllowPrivateGoogleAccess[] VALUES = values();

    public static AllowPrivateGoogleAccess valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPrivateGoogleAccess(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPrivateGoogleAccess)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPsc}
   */
  public enum AllowPsc implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PSC = 0;</code>
     */
    UNDEFINED_ALLOW_PSC(0),
    /** <code>PSC_ALLOWED = 171559657;</code> */
    PSC_ALLOWED(171559657),
    /** <code>PSC_BLOCKED = 524593965;</code> */
    PSC_BLOCKED(524593965),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PSC = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PSC_VALUE = 0;
    /** <code>PSC_ALLOWED = 171559657;</code> */
    public static final int PSC_ALLOWED_VALUE = 171559657;
    /** <code>PSC_BLOCKED = 524593965;</code> */
    public static final int PSC_BLOCKED_VALUE = 524593965;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPsc valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPsc forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PSC;
        case 171559657:
          return PSC_ALLOWED;
        case 524593965:
          return PSC_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPsc> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPsc> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowPsc>() {
          public AllowPsc findValueByNumber(int number) {
            return AllowPsc.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(12);
    }

    private static final AllowPsc[] VALUES = values();

    public static AllowPsc valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPsc(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPsc)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSameNetworkUnicast}
   */
  public enum AllowSameNetworkUnicast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SAME_NETWORK_UNICAST = 0;</code>
     */
    UNDEFINED_ALLOW_SAME_NETWORK_UNICAST(0),
    /** <code>SAME_NETWORK_UNICAST_ALLOWED = 159732814;</code> */
    SAME_NETWORK_UNICAST_ALLOWED(159732814),
    /** <code>SAME_NETWORK_UNICAST_BLOCKED = 512767122;</code> */
    SAME_NETWORK_UNICAST_BLOCKED(512767122),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SAME_NETWORK_UNICAST = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_SAME_NETWORK_UNICAST_VALUE = 0;
    /** <code>SAME_NETWORK_UNICAST_ALLOWED = 159732814;</code> */
    public static final int SAME_NETWORK_UNICAST_ALLOWED_VALUE = 159732814;
    /** <code>SAME_NETWORK_UNICAST_BLOCKED = 512767122;</code> */
    public static final int SAME_NETWORK_UNICAST_BLOCKED_VALUE = 512767122;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowSameNetworkUnicast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowSameNetworkUnicast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_SAME_NETWORK_UNICAST;
        case 159732814:
          return SAME_NETWORK_UNICAST_ALLOWED;
        case 512767122:
          return SAME_NETWORK_UNICAST_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>() {
              public AllowSameNetworkUnicast findValueByNumber(int number) {
                return AllowSameNetworkUnicast.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(13);
    }

    private static final AllowSameNetworkUnicast[] VALUES = values();

    public static AllowSameNetworkUnicast valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowSameNetworkUnicast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSameNetworkUnicast)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowStaticRoutes}
   */
  public enum AllowStaticRoutes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_STATIC_ROUTES = 0;</code>
     */
    UNDEFINED_ALLOW_STATIC_ROUTES(0),
    /** <code>STATIC_ROUTES_ALLOWED = 409048964;</code> */
    STATIC_ROUTES_ALLOWED(409048964),
    /** <code>STATIC_ROUTES_BLOCKED = 225212360;</code> */
    STATIC_ROUTES_BLOCKED(225212360),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_STATIC_ROUTES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_STATIC_ROUTES_VALUE = 0;
    /** <code>STATIC_ROUTES_ALLOWED = 409048964;</code> */
    public static final int STATIC_ROUTES_ALLOWED_VALUE = 409048964;
    /** <code>STATIC_ROUTES_BLOCKED = 225212360;</code> */
    public static final int STATIC_ROUTES_BLOCKED_VALUE = 225212360;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowStaticRoutes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowStaticRoutes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_STATIC_ROUTES;
        case 409048964:
          return STATIC_ROUTES_ALLOWED;
        case 225212360:
          return STATIC_ROUTES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>() {
              public AllowStaticRoutes findValueByNumber(int number) {
                return AllowStaticRoutes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(14);
    }

    private static final AllowStaticRoutes[] VALUES = values();

    public static AllowStaticRoutes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowStaticRoutes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowStaticRoutes)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubInterfaces}
   */
  public enum AllowSubInterfaces implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUB_INTERFACES = 0;</code>
     */
    UNDEFINED_ALLOW_SUB_INTERFACES(0),
    /** <code>SUBINTERFACES_ALLOWED = 158685891;</code> */
    SUBINTERFACES_ALLOWED(158685891),
    /** <code>SUBINTERFACES_BLOCKED = 511720199;</code> */
    SUBINTERFACES_BLOCKED(511720199),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUB_INTERFACES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_SUB_INTERFACES_VALUE = 0;
    /** <code>SUBINTERFACES_ALLOWED = 158685891;</code> */
    public static final int SUBINTERFACES_ALLOWED_VALUE = 158685891;
    /** <code>SUBINTERFACES_BLOCKED = 511720199;</code> */
    public static final int SUBINTERFACES_BLOCKED_VALUE = 511720199;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowSubInterfaces valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowSubInterfaces forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_SUB_INTERFACES;
        case 158685891:
          return SUBINTERFACES_ALLOWED;
        case 511720199:
          return SUBINTERFACES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>() {
              public AllowSubInterfaces findValueByNumber(int number) {
                return AllowSubInterfaces.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(15);
    }

    private static final AllowSubInterfaces[] VALUES = values();

    public static AllowSubInterfaces valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowSubInterfaces(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubInterfaces)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcPeering}
   */
  public enum AllowVpcPeering implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_PEERING = 0;</code>
     */
    UNDEFINED_ALLOW_VPC_PEERING(0),
    /** <code>VPC_PEERING_ALLOWED = 261465075;</code> */
    VPC_PEERING_ALLOWED(261465075),
    /** <code>VPC_PEERING_BLOCKED = 77628471;</code> */
    VPC_PEERING_BLOCKED(77628471),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_PEERING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_VPC_PEERING_VALUE = 0;
    /** <code>VPC_PEERING_ALLOWED = 261465075;</code> */
    public static final int VPC_PEERING_ALLOWED_VALUE = 261465075;
    /** <code>VPC_PEERING_BLOCKED = 77628471;</code> */
    public static final int VPC_PEERING_BLOCKED_VALUE = 77628471;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowVpcPeering valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowVpcPeering forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_VPC_PEERING;
        case 261465075:
          return VPC_PEERING_ALLOWED;
        case 77628471:
          return VPC_PEERING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering>() {
              public AllowVpcPeering findValueByNumber(int number) {
                return AllowVpcPeering.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(16);
    }

    private static final AllowVpcPeering[] VALUES = values();

    public static AllowVpcPeering valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowVpcPeering(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcPeering)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpn}
   */
  public enum AllowVpn implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPN = 0;</code>
     */
    UNDEFINED_ALLOW_VPN(0),
    /** <code>VPN_ALLOWED = 162163997;</code> */
    VPN_ALLOWED(162163997),
    /** <code>VPN_BLOCKED = 515198305;</code> */
    VPN_BLOCKED(515198305),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPN = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_VPN_VALUE = 0;
    /** <code>VPN_ALLOWED = 162163997;</code> */
    public static final int VPN_ALLOWED_VALUE = 162163997;
    /** <code>VPN_BLOCKED = 515198305;</code> */
    public static final int VPN_BLOCKED_VALUE = 515198305;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowVpn valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowVpn forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_VPN;
        case 162163997:
          return VPN_ALLOWED;
        case 515198305:
          return VPN_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowVpn> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowVpn> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowVpn>() {
          public AllowVpn findValueByNumber(int number) {
            return AllowVpn.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(17);
    }

    private static final AllowVpn[] VALUES = values();

    public static AllowVpn valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowVpn(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpn)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.InterfaceTypes}
   */
  public enum InterfaceTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_INTERFACE_TYPES = 0;</code>
     */
    UNDEFINED_INTERFACE_TYPES(0),
    /**
     *
     *
     * <pre>
     * GVNIC
     * </pre>
     *
     * <code>GVNIC = 68209305;</code>
     */
    GVNIC(68209305),
    /**
     *
     *
     * <pre>
     * IDPF
     * </pre>
     *
     * <code>IDPF = 2242641;</code>
     */
    IDPF(2242641),
    /**
     *
     *
     * <pre>
     * IRDMA
     * </pre>
     *
     * <code>IRDMA = 69927695;</code>
     */
    IRDMA(69927695),
    /**
     *
     *
     * <pre>
     * MRDMA
     * </pre>
     *
     * <code>MRDMA = 73621779;</code>
     */
    MRDMA(73621779),
    /**
     *
     *
     * <pre>
     * No type specified.
     * </pre>
     *
     * <code>UNSPECIFIED_NIC_TYPE = 67411801;</code>
     */
    UNSPECIFIED_NIC_TYPE(67411801),
    /**
     *
     *
     * <pre>
     * VIRTIO
     * </pre>
     *
     * <code>VIRTIO_NET = 452123481;</code>
     */
    VIRTIO_NET(452123481),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_INTERFACE_TYPES = 0;</code>
     */
    public static final int UNDEFINED_INTERFACE_TYPES_VALUE = 0;
    /**
     *
     *
     * <pre>
     * GVNIC
     * </pre>
     *
     * <code>GVNIC = 68209305;</code>
     */
    public static final int GVNIC_VALUE = 68209305;
    /**
     *
     *
     * <pre>
     * IDPF
     * </pre>
     *
     * <code>IDPF = 2242641;</code>
     */
    public static final int IDPF_VALUE = 2242641;
    /**
     *
     *
     * <pre>
     * IRDMA
     * </pre>
     *
     * <code>IRDMA = 69927695;</code>
     */
    public static final int IRDMA_VALUE = 69927695;
    /**
     *
     *
     * <pre>
     * MRDMA
     * </pre>
     *
     * <code>MRDMA = 73621779;</code>
     */
    public static final int MRDMA_VALUE = 73621779;
    /**
     *
     *
     * <pre>
     * No type specified.
     * </pre>
     *
     * <code>UNSPECIFIED_NIC_TYPE = 67411801;</code>
     */
    public static final int UNSPECIFIED_NIC_TYPE_VALUE = 67411801;
    /**
     *
     *
     * <pre>
     * VIRTIO
     * </pre>
     *
     * <code>VIRTIO_NET = 452123481;</code>
     */
    public static final int VIRTIO_NET_VALUE = 452123481;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InterfaceTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static InterfaceTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_INTERFACE_TYPES;
        case 68209305:
          return GVNIC;
        case 2242641:
          return IDPF;
        case 69927695:
          return IRDMA;
        case 73621779:
          return MRDMA;
        case 67411801:
          return UNSPECIFIED_NIC_TYPE;
        case 452123481:
          return VIRTIO_NET;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes>() {
          public InterfaceTypes findValueByNumber(int number) {
            return InterfaceTypes.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(18);
    }

    private static final InterfaceTypes[] VALUES = values();

    public static InterfaceTypes valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InterfaceTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.InterfaceTypes)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetPurposes}
   */
  public enum SubnetPurposes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_PURPOSES = 0;</code>
     */
    UNDEFINED_SUBNET_PURPOSES(0),
    /** <code>SUBNET_PURPOSE_CUSTOM_HARDWARE = 283160275;</code> */
    SUBNET_PURPOSE_CUSTOM_HARDWARE(283160275),
    /** <code>SUBNET_PURPOSE_PRIVATE = 404371008;</code> */
    SUBNET_PURPOSE_PRIVATE(404371008),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_PURPOSES = 0;</code>
     */
    public static final int UNDEFINED_SUBNET_PURPOSES_VALUE = 0;
    /** <code>SUBNET_PURPOSE_CUSTOM_HARDWARE = 283160275;</code> */
    public static final int SUBNET_PURPOSE_CUSTOM_HARDWARE_VALUE = 283160275;
    /** <code>SUBNET_PURPOSE_PRIVATE = 404371008;</code> */
    public static final int SUBNET_PURPOSE_PRIVATE_VALUE = 404371008;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetPurposes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetPurposes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNET_PURPOSES;
        case 283160275:
          return SUBNET_PURPOSE_CUSTOM_HARDWARE;
        case 404371008:
          return SUBNET_PURPOSE_PRIVATE;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes>() {
          public SubnetPurposes findValueByNumber(int number) {
            return SubnetPurposes.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(19);
    }

    private static final SubnetPurposes[] VALUES = values();

    public static SubnetPurposes valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetPurposes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetPurposes)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetStackTypes}
   */
  public enum SubnetStackTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_STACK_TYPES = 0;</code>
     */
    UNDEFINED_SUBNET_STACK_TYPES(0),
    /** <code>SUBNET_STACK_TYPE_IPV4_IPV6 = 41454485;</code> */
    SUBNET_STACK_TYPE_IPV4_IPV6(41454485),
    /** <code>SUBNET_STACK_TYPE_IPV4_ONLY = 41631034;</code> */
    SUBNET_STACK_TYPE_IPV4_ONLY(41631034),
    /** <code>SUBNET_STACK_TYPE_IPV6_ONLY = 98889336;</code> */
    SUBNET_STACK_TYPE_IPV6_ONLY(98889336),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_STACK_TYPES = 0;</code>
     */
    public static final int UNDEFINED_SUBNET_STACK_TYPES_VALUE = 0;
    /** <code>SUBNET_STACK_TYPE_IPV4_IPV6 = 41454485;</code> */
    public static final int SUBNET_STACK_TYPE_IPV4_IPV6_VALUE = 41454485;
    /** <code>SUBNET_STACK_TYPE_IPV4_ONLY = 41631034;</code> */
    public static final int SUBNET_STACK_TYPE_IPV4_ONLY_VALUE = 41631034;
    /** <code>SUBNET_STACK_TYPE_IPV6_ONLY = 98889336;</code> */
    public static final int SUBNET_STACK_TYPE_IPV6_ONLY_VALUE = 98889336;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetStackTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetStackTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNET_STACK_TYPES;
        case 41454485:
          return SUBNET_STACK_TYPE_IPV4_IPV6;
        case 41631034:
          return SUBNET_STACK_TYPE_IPV4_ONLY;
        case 98889336:
          return SUBNET_STACK_TYPE_IPV6_ONLY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes>() {
              public SubnetStackTypes findValueByNumber(int number) {
                return SubnetStackTypes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(20);
    }

    private static final SubnetStackTypes[] VALUES = values();

    public static SubnetStackTypes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetStackTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetStackTypes)
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.Unicast}
   */
  public enum Unicast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_UNICAST = 0;</code>
     */
    UNDEFINED_UNICAST(0),
    /** <code>UNICAST_SDN = 379954157;</code> */
    UNICAST_SDN(379954157),
    /** <code>UNICAST_ULL = 379956325;</code> */
    UNICAST_ULL(379956325),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_UNICAST = 0;</code>
     */
    public static final int UNDEFINED_UNICAST_VALUE = 0;
    /** <code>UNICAST_SDN = 379954157;</code> */
    public static final int UNICAST_SDN_VALUE = 379954157;
    /** <code>UNICAST_ULL = 379956325;</code> */
    public static final int UNICAST_ULL_VALUE = 379956325;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Unicast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Unicast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_UNICAST;
        case 379954157:
          return UNICAST_SDN;
        case 379956325:
          return UNICAST_ULL;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Unicast> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Unicast> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Unicast>() {
          public Unicast findValueByNumber(int number) {
            return Unicast.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(21);
    }

    private static final Unicast[] VALUES = values();

    public static Unicast valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Unicast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.Unicast)
  }

  private int bitField0_;
  public static final int ADDRESS_PURPOSES_FIELD_NUMBER = 433024768;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList addressPurposes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();
  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @return A list containing the addressPurposes.
   */
  public com.google.protobuf.ProtocolStringList getAddressPurposesList() {
    return addressPurposes_;
  }
  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @return The count of addressPurposes.
   */
  public int getAddressPurposesCount() {
    return addressPurposes_.size();
  }
  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @param index The index of the element to return.
   * @return The addressPurposes at the given index.
   */
  public java.lang.String getAddressPurposes(int index) {
    return addressPurposes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the addressPurposes at the given index.
   */
  public com.google.protobuf.ByteString getAddressPurposesBytes(int index) {
    return addressPurposes_.getByteString(index);
  }

  public static final int ALLOW_ALIAS_IP_RANGES_FIELD_NUMBER = 457984201;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowAliasIpRanges_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return Whether the allowAliasIpRanges field is set.
   */
  @java.lang.Override
  public boolean hasAllowAliasIpRanges() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return The allowAliasIpRanges.
   */
  @java.lang.Override
  public java.lang.String getAllowAliasIpRanges() {
    java.lang.Object ref = allowAliasIpRanges_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowAliasIpRanges_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return The bytes for allowAliasIpRanges.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowAliasIpRangesBytes() {
    java.lang.Object ref = allowAliasIpRanges_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowAliasIpRanges_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_AUTO_MODE_SUBNET_FIELD_NUMBER = 152191263;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowAutoModeSubnet_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return Whether the allowAutoModeSubnet field is set.
   */
  @java.lang.Override
  public boolean hasAllowAutoModeSubnet() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return The allowAutoModeSubnet.
   */
  @java.lang.Override
  public java.lang.String getAllowAutoModeSubnet() {
    java.lang.Object ref = allowAutoModeSubnet_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowAutoModeSubnet_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return The bytes for allowAutoModeSubnet.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowAutoModeSubnetBytes() {
    java.lang.Object ref = allowAutoModeSubnet_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowAutoModeSubnet_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLASS_D_FIREWALLS_FIELD_NUMBER = 131608987;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowClassDFirewalls_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return Whether the allowClassDFirewalls field is set.
   */
  @java.lang.Override
  public boolean hasAllowClassDFirewalls() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return The allowClassDFirewalls.
   */
  @java.lang.Override
  public java.lang.String getAllowClassDFirewalls() {
    java.lang.Object ref = allowClassDFirewalls_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowClassDFirewalls_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return The bytes for allowClassDFirewalls.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowClassDFirewallsBytes() {
    java.lang.Object ref = allowClassDFirewalls_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowClassDFirewalls_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLOUD_NAT_FIELD_NUMBER = 254831265;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowCloudNat_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return Whether the allowCloudNat field is set.
   */
  @java.lang.Override
  public boolean hasAllowCloudNat() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return The allowCloudNat.
   */
  @java.lang.Override
  public java.lang.String getAllowCloudNat() {
    java.lang.Object ref = allowCloudNat_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowCloudNat_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return The bytes for allowCloudNat.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowCloudNatBytes() {
    java.lang.Object ref = allowCloudNat_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowCloudNat_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLOUD_ROUTER_FIELD_NUMBER = 451110345;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowCloudRouter_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return Whether the allowCloudRouter field is set.
   */
  @java.lang.Override
  public boolean hasAllowCloudRouter() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return The allowCloudRouter.
   */
  @java.lang.Override
  public java.lang.String getAllowCloudRouter() {
    java.lang.Object ref = allowCloudRouter_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowCloudRouter_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return The bytes for allowCloudRouter.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowCloudRouterBytes() {
    java.lang.Object ref = allowCloudRouter_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowCloudRouter_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_EXTERNAL_IP_ACCESS_FIELD_NUMBER = 131538110;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowExternalIpAccess_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return Whether the allowExternalIpAccess field is set.
   */
  @java.lang.Override
  public boolean hasAllowExternalIpAccess() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return The allowExternalIpAccess.
   */
  @java.lang.Override
  public java.lang.String getAllowExternalIpAccess() {
    java.lang.Object ref = allowExternalIpAccess_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowExternalIpAccess_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return The bytes for allowExternalIpAccess.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowExternalIpAccessBytes() {
    java.lang.Object ref = allowExternalIpAccess_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowExternalIpAccess_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_INTERCONNECT_FIELD_NUMBER = 280512964;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowInterconnect_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return Whether the allowInterconnect field is set.
   */
  @java.lang.Override
  public boolean hasAllowInterconnect() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return The allowInterconnect.
   */
  @java.lang.Override
  public java.lang.String getAllowInterconnect() {
    java.lang.Object ref = allowInterconnect_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowInterconnect_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return The bytes for allowInterconnect.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowInterconnectBytes() {
    java.lang.Object ref = allowInterconnect_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowInterconnect_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_LOAD_BALANCING_FIELD_NUMBER = 223366198;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowLoadBalancing_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return Whether the allowLoadBalancing field is set.
   */
  @java.lang.Override
  public boolean hasAllowLoadBalancing() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return The allowLoadBalancing.
   */
  @java.lang.Override
  public java.lang.String getAllowLoadBalancing() {
    java.lang.Object ref = allowLoadBalancing_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowLoadBalancing_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return The bytes for allowLoadBalancing.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowLoadBalancingBytes() {
    java.lang.Object ref = allowLoadBalancing_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowLoadBalancing_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_MULTI_NIC_IN_SAME_NETWORK_FIELD_NUMBER = 88251004;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowMultiNicInSameNetwork_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return Whether the allowMultiNicInSameNetwork field is set.
   */
  @java.lang.Override
  public boolean hasAllowMultiNicInSameNetwork() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return The allowMultiNicInSameNetwork.
   */
  @java.lang.Override
  public java.lang.String getAllowMultiNicInSameNetwork() {
    java.lang.Object ref = allowMultiNicInSameNetwork_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowMultiNicInSameNetwork_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return The bytes for allowMultiNicInSameNetwork.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowMultiNicInSameNetworkBytes() {
    java.lang.Object ref = allowMultiNicInSameNetwork_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowMultiNicInSameNetwork_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PACKET_MIRRORING_FIELD_NUMBER = 512227074;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPacketMirroring_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return Whether the allowPacketMirroring field is set.
   */
  @java.lang.Override
  public boolean hasAllowPacketMirroring() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return The allowPacketMirroring.
   */
  @java.lang.Override
  public java.lang.String getAllowPacketMirroring() {
    java.lang.Object ref = allowPacketMirroring_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPacketMirroring_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return The bytes for allowPacketMirroring.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPacketMirroringBytes() {
    java.lang.Object ref = allowPacketMirroring_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPacketMirroring_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PRIVATE_GOOGLE_ACCESS_FIELD_NUMBER = 374702072;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPrivateGoogleAccess_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return Whether the allowPrivateGoogleAccess field is set.
   */
  @java.lang.Override
  public boolean hasAllowPrivateGoogleAccess() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return The allowPrivateGoogleAccess.
   */
  @java.lang.Override
  public java.lang.String getAllowPrivateGoogleAccess() {
    java.lang.Object ref = allowPrivateGoogleAccess_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPrivateGoogleAccess_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return The bytes for allowPrivateGoogleAccess.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPrivateGoogleAccessBytes() {
    java.lang.Object ref = allowPrivateGoogleAccess_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPrivateGoogleAccess_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PSC_FIELD_NUMBER = 372357322;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPsc_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return Whether the allowPsc field is set.
   */
  @java.lang.Override
  public boolean hasAllowPsc() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return The allowPsc.
   */
  @java.lang.Override
  public java.lang.String getAllowPsc() {
    java.lang.Object ref = allowPsc_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPsc_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return The bytes for allowPsc.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPscBytes() {
    java.lang.Object ref = allowPsc_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPsc_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_SAME_NETWORK_UNICAST_FIELD_NUMBER = 167531643;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowSameNetworkUnicast_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return Whether the allowSameNetworkUnicast field is set.
   */
  @java.lang.Override
  public boolean hasAllowSameNetworkUnicast() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return The allowSameNetworkUnicast.
   */
  @java.lang.Override
  public java.lang.String getAllowSameNetworkUnicast() {
    java.lang.Object ref = allowSameNetworkUnicast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowSameNetworkUnicast_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return The bytes for allowSameNetworkUnicast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowSameNetworkUnicastBytes() {
    java.lang.Object ref = allowSameNetworkUnicast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowSameNetworkUnicast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_STATIC_ROUTES_FIELD_NUMBER = 185257925;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowStaticRoutes_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return Whether the allowStaticRoutes field is set.
   */
  @java.lang.Override
  public boolean hasAllowStaticRoutes() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return The allowStaticRoutes.
   */
  @java.lang.Override
  public java.lang.String getAllowStaticRoutes() {
    java.lang.Object ref = allowStaticRoutes_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowStaticRoutes_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return The bytes for allowStaticRoutes.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowStaticRoutesBytes() {
    java.lang.Object ref = allowStaticRoutes_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowStaticRoutes_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_SUB_INTERFACES_FIELD_NUMBER = 247208303;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowSubInterfaces_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return Whether the allowSubInterfaces field is set.
   */
  @java.lang.Override
  public boolean hasAllowSubInterfaces() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return The allowSubInterfaces.
   */
  @java.lang.Override
  public java.lang.String getAllowSubInterfaces() {
    java.lang.Object ref = allowSubInterfaces_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowSubInterfaces_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return The bytes for allowSubInterfaces.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowSubInterfacesBytes() {
    java.lang.Object ref = allowSubInterfaces_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowSubInterfaces_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_VPC_PEERING_FIELD_NUMBER = 115402228;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowVpcPeering_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return Whether the allowVpcPeering field is set.
   */
  @java.lang.Override
  public boolean hasAllowVpcPeering() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return The allowVpcPeering.
   */
  @java.lang.Override
  public java.lang.String getAllowVpcPeering() {
    java.lang.Object ref = allowVpcPeering_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowVpcPeering_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return The bytes for allowVpcPeering.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowVpcPeeringBytes() {
    java.lang.Object ref = allowVpcPeering_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowVpcPeering_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_VPN_FIELD_NUMBER = 372363006;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowVpn_ = "";
  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return Whether the allowVpn field is set.
   */
  @java.lang.Override
  public boolean hasAllowVpn() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return The allowVpn.
   */
  @java.lang.Override
  public java.lang.String getAllowVpn() {
    java.lang.Object ref = allowVpn_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowVpn_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return The bytes for allowVpn.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowVpnBytes() {
    java.lang.Object ref = allowVpn_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowVpn_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int INTERFACE_TYPES_FIELD_NUMBER = 157981171;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList interfaceTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();
  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @return A list containing the interfaceTypes.
   */
  public com.google.protobuf.ProtocolStringList getInterfaceTypesList() {
    return interfaceTypes_;
  }
  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @return The count of interfaceTypes.
   */
  public int getInterfaceTypesCount() {
    return interfaceTypes_.size();
  }
  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @param index The index of the element to return.
   * @return The interfaceTypes at the given index.
   */
  public java.lang.String getInterfaceTypes(int index) {
    return interfaceTypes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the interfaceTypes at the given index.
   */
  public com.google.protobuf.ByteString getInterfaceTypesBytes(int index) {
    return interfaceTypes_.getByteString(index);
  }

  public static final int SUBNET_PURPOSES_FIELD_NUMBER = 301338039;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetPurposes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @return A list containing the subnetPurposes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetPurposesList() {
    return subnetPurposes_;
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @return The count of subnetPurposes.
   */
  public int getSubnetPurposesCount() {
    return subnetPurposes_.size();
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetPurposes at the given index.
   */
  public java.lang.String getSubnetPurposes(int index) {
    return subnetPurposes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetPurposes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetPurposesBytes(int index) {
    return subnetPurposes_.getByteString(index);
  }

  public static final int SUBNET_STACK_TYPES_FIELD_NUMBER = 521008672;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetStackTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @return A list containing the subnetStackTypes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetStackTypesList() {
    return subnetStackTypes_;
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @return The count of subnetStackTypes.
   */
  public int getSubnetStackTypesCount() {
    return subnetStackTypes_.size();
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetStackTypes at the given index.
   */
  public java.lang.String getSubnetStackTypes(int index) {
    return subnetStackTypes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetStackTypes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetStackTypesBytes(int index) {
    return subnetStackTypes_.getByteString(index);
  }

  public static final int UNICAST_FIELD_NUMBER = 249841711;

  @SuppressWarnings("serial")
  private volatile java.lang.Object unicast_ = "";
  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return Whether the unicast field is set.
   */
  @java.lang.Override
  public boolean hasUnicast() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return The unicast.
   */
  @java.lang.Override
  public java.lang.String getUnicast() {
    java.lang.Object ref = unicast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      unicast_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return The bytes for unicast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getUnicastBytes() {
    java.lang.Object ref = unicast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      unicast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000100) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 88251004, allowMultiNicInSameNetwork_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 115402228, allowVpcPeering_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 131538110, allowExternalIpAccess_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 131608987, allowClassDFirewalls_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 152191263, allowAutoModeSubnet_);
    }
    for (int i = 0; i < interfaceTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 157981171, interfaceTypes_.getRaw(i));
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 167531643, allowSameNetworkUnicast_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 185257925, allowStaticRoutes_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 223366198, allowLoadBalancing_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 247208303, allowSubInterfaces_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 249841711, unicast_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 254831265, allowCloudNat_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 280512964, allowInterconnect_);
    }
    for (int i = 0; i < subnetPurposes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 301338039, subnetPurposes_.getRaw(i));
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 372357322, allowPsc_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 372363006, allowVpn_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 374702072, allowPrivateGoogleAccess_);
    }
    for (int i = 0; i < addressPurposes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 433024768, addressPurposes_.getRaw(i));
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 451110345, allowCloudRouter_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 457984201, allowAliasIpRanges_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 512227074, allowPacketMirroring_);
    }
    for (int i = 0; i < subnetStackTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 521008672, subnetStackTypes_.getRaw(i));
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000100) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              88251004, allowMultiNicInSameNetwork_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(115402228, allowVpcPeering_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              131538110, allowExternalIpAccess_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              131608987, allowClassDFirewalls_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(152191263, allowAutoModeSubnet_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < interfaceTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(interfaceTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getInterfaceTypesList().size();
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              167531643, allowSameNetworkUnicast_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(185257925, allowStaticRoutes_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(223366198, allowLoadBalancing_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(247208303, allowSubInterfaces_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(249841711, unicast_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(254831265, allowCloudNat_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(280512964, allowInterconnect_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetPurposes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetPurposes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetPurposesList().size();
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(372357322, allowPsc_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(372363006, allowVpn_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              374702072, allowPrivateGoogleAccess_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < addressPurposes_.size(); i++) {
        dataSize += computeStringSizeNoTag(addressPurposes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getAddressPurposesList().size();
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(451110345, allowCloudRouter_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(457984201, allowAliasIpRanges_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              512227074, allowPacketMirroring_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetStackTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetStackTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetStackTypesList().size();
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.NetworkProfileNetworkFeatures)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.NetworkProfileNetworkFeatures other =
        (com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) obj;

    if (!getAddressPurposesList().equals(other.getAddressPurposesList())) return false;
    if (hasAllowAliasIpRanges() != other.hasAllowAliasIpRanges()) return false;
    if (hasAllowAliasIpRanges()) {
      if (!getAllowAliasIpRanges().equals(other.getAllowAliasIpRanges())) return false;
    }
    if (hasAllowAutoModeSubnet() != other.hasAllowAutoModeSubnet()) return false;
    if (hasAllowAutoModeSubnet()) {
      if (!getAllowAutoModeSubnet().equals(other.getAllowAutoModeSubnet())) return false;
    }
    if (hasAllowClassDFirewalls() != other.hasAllowClassDFirewalls()) return false;
    if (hasAllowClassDFirewalls()) {
      if (!getAllowClassDFirewalls().equals(other.getAllowClassDFirewalls())) return false;
    }
    if (hasAllowCloudNat() != other.hasAllowCloudNat()) return false;
    if (hasAllowCloudNat()) {
      if (!getAllowCloudNat().equals(other.getAllowCloudNat())) return false;
    }
    if (hasAllowCloudRouter() != other.hasAllowCloudRouter()) return false;
    if (hasAllowCloudRouter()) {
      if (!getAllowCloudRouter().equals(other.getAllowCloudRouter())) return false;
    }
    if (hasAllowExternalIpAccess() != other.hasAllowExternalIpAccess()) return false;
    if (hasAllowExternalIpAccess()) {
      if (!getAllowExternalIpAccess().equals(other.getAllowExternalIpAccess())) return false;
    }
    if (hasAllowInterconnect() != other.hasAllowInterconnect()) return false;
    if (hasAllowInterconnect()) {
      if (!getAllowInterconnect().equals(other.getAllowInterconnect())) return false;
    }
    if (hasAllowLoadBalancing() != other.hasAllowLoadBalancing()) return false;
    if (hasAllowLoadBalancing()) {
      if (!getAllowLoadBalancing().equals(other.getAllowLoadBalancing())) return false;
    }
    if (hasAllowMultiNicInSameNetwork() != other.hasAllowMultiNicInSameNetwork()) return false;
    if (hasAllowMultiNicInSameNetwork()) {
      if (!getAllowMultiNicInSameNetwork().equals(other.getAllowMultiNicInSameNetwork()))
        return false;
    }
    if (hasAllowPacketMirroring() != other.hasAllowPacketMirroring()) return false;
    if (hasAllowPacketMirroring()) {
      if (!getAllowPacketMirroring().equals(other.getAllowPacketMirroring())) return false;
    }
    if (hasAllowPrivateGoogleAccess() != other.hasAllowPrivateGoogleAccess()) return false;
    if (hasAllowPrivateGoogleAccess()) {
      if (!getAllowPrivateGoogleAccess().equals(other.getAllowPrivateGoogleAccess())) return false;
    }
    if (hasAllowPsc() != other.hasAllowPsc()) return false;
    if (hasAllowPsc()) {
      if (!getAllowPsc().equals(other.getAllowPsc())) return false;
    }
    if (hasAllowSameNetworkUnicast() != other.hasAllowSameNetworkUnicast()) return false;
    if (hasAllowSameNetworkUnicast()) {
      if (!getAllowSameNetworkUnicast().equals(other.getAllowSameNetworkUnicast())) return false;
    }
    if (hasAllowStaticRoutes() != other.hasAllowStaticRoutes()) return false;
    if (hasAllowStaticRoutes()) {
      if (!getAllowStaticRoutes().equals(other.getAllowStaticRoutes())) return false;
    }
    if (hasAllowSubInterfaces() != other.hasAllowSubInterfaces()) return false;
    if (hasAllowSubInterfaces()) {
      if (!getAllowSubInterfaces().equals(other.getAllowSubInterfaces())) return false;
    }
    if (hasAllowVpcPeering() != other.hasAllowVpcPeering()) return false;
    if (hasAllowVpcPeering()) {
      if (!getAllowVpcPeering().equals(other.getAllowVpcPeering())) return false;
    }
    if (hasAllowVpn() != other.hasAllowVpn()) return false;
    if (hasAllowVpn()) {
      if (!getAllowVpn().equals(other.getAllowVpn())) return false;
    }
    if (!getInterfaceTypesList().equals(other.getInterfaceTypesList())) return false;
    if (!getSubnetPurposesList().equals(other.getSubnetPurposesList())) return false;
    if (!getSubnetStackTypesList().equals(other.getSubnetStackTypesList())) return false;
    if (hasUnicast() != other.hasUnicast()) return false;
    if (hasUnicast()) {
      if (!getUnicast().equals(other.getUnicast())) return false;
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getAddressPurposesCount() > 0) {
      hash = (37 * hash) + ADDRESS_PURPOSES_FIELD_NUMBER;
      hash = (53 * hash) + getAddressPurposesList().hashCode();
    }
    if (hasAllowAliasIpRanges()) {
      hash = (37 * hash) + ALLOW_ALIAS_IP_RANGES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowAliasIpRanges().hashCode();
    }
    if (hasAllowAutoModeSubnet()) {
      hash = (37 * hash) + ALLOW_AUTO_MODE_SUBNET_FIELD_NUMBER;
      hash = (53 * hash) + getAllowAutoModeSubnet().hashCode();
    }
    if (hasAllowClassDFirewalls()) {
      hash = (37 * hash) + ALLOW_CLASS_D_FIREWALLS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowClassDFirewalls().hashCode();
    }
    if (hasAllowCloudNat()) {
      hash = (37 * hash) + ALLOW_CLOUD_NAT_FIELD_NUMBER;
      hash = (53 * hash) + getAllowCloudNat().hashCode();
    }
    if (hasAllowCloudRouter()) {
      hash = (37 * hash) + ALLOW_CLOUD_ROUTER_FIELD_NUMBER;
      hash = (53 * hash) + getAllowCloudRouter().hashCode();
    }
    if (hasAllowExternalIpAccess()) {
      hash = (37 * hash) + ALLOW_EXTERNAL_IP_ACCESS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowExternalIpAccess().hashCode();
    }
    if (hasAllowInterconnect()) {
      hash = (37 * hash) + ALLOW_INTERCONNECT_FIELD_NUMBER;
      hash = (53 * hash) + getAllowInterconnect().hashCode();
    }
    if (hasAllowLoadBalancing()) {
      hash = (37 * hash) + ALLOW_LOAD_BALANCING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowLoadBalancing().hashCode();
    }
    if (hasAllowMultiNicInSameNetwork()) {
      hash = (37 * hash) + ALLOW_MULTI_NIC_IN_SAME_NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getAllowMultiNicInSameNetwork().hashCode();
    }
    if (hasAllowPacketMirroring()) {
      hash = (37 * hash) + ALLOW_PACKET_MIRRORING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPacketMirroring().hashCode();
    }
    if (hasAllowPrivateGoogleAccess()) {
      hash = (37 * hash) + ALLOW_PRIVATE_GOOGLE_ACCESS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPrivateGoogleAccess().hashCode();
    }
    if (hasAllowPsc()) {
      hash = (37 * hash) + ALLOW_PSC_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPsc().hashCode();
    }
    if (hasAllowSameNetworkUnicast()) {
      hash = (37 * hash) + ALLOW_SAME_NETWORK_UNICAST_FIELD_NUMBER;
      hash = (53 * hash) + getAllowSameNetworkUnicast().hashCode();
    }
    if (hasAllowStaticRoutes()) {
      hash = (37 * hash) + ALLOW_STATIC_ROUTES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowStaticRoutes().hashCode();
    }
    if (hasAllowSubInterfaces()) {
      hash = (37 * hash) + ALLOW_SUB_INTERFACES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowSubInterfaces().hashCode();
    }
    if (hasAllowVpcPeering()) {
      hash = (37 * hash) + ALLOW_VPC_PEERING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowVpcPeering().hashCode();
    }
    if (hasAllowVpn()) {
      hash = (37 * hash) + ALLOW_VPN_FIELD_NUMBER;
      hash = (53 * hash) + getAllowVpn().hashCode();
    }
    if (getInterfaceTypesCount() > 0) {
      hash = (37 * hash) + INTERFACE_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getInterfaceTypesList().hashCode();
    }
    if (getSubnetPurposesCount() > 0) {
      hash = (37 * hash) + SUBNET_PURPOSES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetPurposesList().hashCode();
    }
    if (getSubnetStackTypesCount() > 0) {
      hash = (37 * hash) + SUBNET_STACK_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetStackTypesList().hashCode();
    }
    if (hasUnicast()) {
      hash = (37 * hash) + UNICAST_FIELD_NUMBER;
      hash = (53 * hash) + getUnicast().hashCode();
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
      com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.class,
              com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.newBuilder()
    private Builder() {}

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      allowAliasIpRanges_ = "";
      allowAutoModeSubnet_ = "";
      allowClassDFirewalls_ = "";
      allowCloudNat_ = "";
      allowCloudRouter_ = "";
      allowExternalIpAccess_ = "";
      allowInterconnect_ = "";
      allowLoadBalancing_ = "";
      allowMultiNicInSameNetwork_ = "";
      allowPacketMirroring_ = "";
      allowPrivateGoogleAccess_ = "";
      allowPsc_ = "";
      allowSameNetworkUnicast_ = "";
      allowStaticRoutes_ = "";
      allowSubInterfaces_ = "";
      allowVpcPeering_ = "";
      allowVpn_ = "";
      interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      unicast_ = "";
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures build() {
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures buildPartial() {
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result =
          new com.google.cloud.compute.v1.NetworkProfileNetworkFeatures(this);
      if (bitField0_ != 0) {
        buildPartial0(result);
      }
      onBuilt();
      return result;
    }

    private void buildPartial0(com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        addressPurposes_.makeImmutable();
        result.addressPurposes_ = addressPurposes_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.allowAliasIpRanges_ = allowAliasIpRanges_;
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.allowAutoModeSubnet_ = allowAutoModeSubnet_;
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.allowClassDFirewalls_ = allowClassDFirewalls_;
        to_bitField0_ |= 0x00000004;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.allowCloudNat_ = allowCloudNat_;
        to_bitField0_ |= 0x00000008;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.allowCloudRouter_ = allowCloudRouter_;
        to_bitField0_ |= 0x00000010;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.allowExternalIpAccess_ = allowExternalIpAccess_;
        to_bitField0_ |= 0x00000020;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.allowInterconnect_ = allowInterconnect_;
        to_bitField0_ |= 0x00000040;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.allowLoadBalancing_ = allowLoadBalancing_;
        to_bitField0_ |= 0x00000080;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.allowMultiNicInSameNetwork_ = allowMultiNicInSameNetwork_;
        to_bitField0_ |= 0x00000100;
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.allowPacketMirroring_ = allowPacketMirroring_;
        to_bitField0_ |= 0x00000200;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.allowPrivateGoogleAccess_ = allowPrivateGoogleAccess_;
        to_bitField0_ |= 0x00000400;
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        result.allowPsc_ = allowPsc_;
        to_bitField0_ |= 0x00000800;
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.allowSameNetworkUnicast_ = allowSameNetworkUnicast_;
        to_bitField0_ |= 0x00001000;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.allowStaticRoutes_ = allowStaticRoutes_;
        to_bitField0_ |= 0x00002000;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.allowSubInterfaces_ = allowSubInterfaces_;
        to_bitField0_ |= 0x00004000;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.allowVpcPeering_ = allowVpcPeering_;
        to_bitField0_ |= 0x00008000;
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.allowVpn_ = allowVpn_;
        to_bitField0_ |= 0x00010000;
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        interfaceTypes_.makeImmutable();
        result.interfaceTypes_ = interfaceTypes_;
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        subnetPurposes_.makeImmutable();
        result.subnetPurposes_ = subnetPurposes_;
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        subnetStackTypes_.makeImmutable();
        result.subnetStackTypes_ = subnetStackTypes_;
      }
      if (((from_bitField0_ & 0x00200000) != 0)) {
        result.unicast_ = unicast_;
        to_bitField0_ |= 0x00020000;
      }
      result.bitField0_ |= to_bitField0_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) {
        return mergeFrom((com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.NetworkProfileNetworkFeatures other) {
      if (other == com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDefaultInstance())
        return this;
      if (!other.addressPurposes_.isEmpty()) {
        if (addressPurposes_.isEmpty()) {
          addressPurposes_ = other.addressPurposes_;
          bitField0_ |= 0x00000001;
        } else {
          ensureAddressPurposesIsMutable();
          addressPurposes_.addAll(other.addressPurposes_);
        }
        onChanged();
      }
      if (other.hasAllowAliasIpRanges()) {
        allowAliasIpRanges_ = other.allowAliasIpRanges_;
        bitField0_ |= 0x00000002;
        onChanged();
      }
      if (other.hasAllowAutoModeSubnet()) {
        allowAutoModeSubnet_ = other.allowAutoModeSubnet_;
        bitField0_ |= 0x00000004;
        onChanged();
      }
      if (other.hasAllowClassDFirewalls()) {
        allowClassDFirewalls_ = other.allowClassDFirewalls_;
        bitField0_ |= 0x00000008;
        onChanged();
      }
      if (other.hasAllowCloudNat()) {
        allowCloudNat_ = other.allowCloudNat_;
        bitField0_ |= 0x00000010;
        onChanged();
      }
      if (other.hasAllowCloudRouter()) {
        allowCloudRouter_ = other.allowCloudRouter_;
        bitField0_ |= 0x00000020;
        onChanged();
      }
      if (other.hasAllowExternalIpAccess()) {
        allowExternalIpAccess_ = other.allowExternalIpAccess_;
        bitField0_ |= 0x00000040;
        onChanged();
      }
      if (other.hasAllowInterconnect()) {
        allowInterconnect_ = other.allowInterconnect_;
        bitField0_ |= 0x00000080;
        onChanged();
      }
      if (other.hasAllowLoadBalancing()) {
        allowLoadBalancing_ = other.allowLoadBalancing_;
        bitField0_ |= 0x00000100;
        onChanged();
      }
      if (other.hasAllowMultiNicInSameNetwork()) {
        allowMultiNicInSameNetwork_ = other.allowMultiNicInSameNetwork_;
        bitField0_ |= 0x00000200;
        onChanged();
      }
      if (other.hasAllowPacketMirroring()) {
        allowPacketMirroring_ = other.allowPacketMirroring_;
        bitField0_ |= 0x00000400;
        onChanged();
      }
      if (other.hasAllowPrivateGoogleAccess()) {
        allowPrivateGoogleAccess_ = other.allowPrivateGoogleAccess_;
        bitField0_ |= 0x00000800;
        onChanged();
      }
      if (other.hasAllowPsc()) {
        allowPsc_ = other.allowPsc_;
        bitField0_ |= 0x00001000;
        onChanged();
      }
      if (other.hasAllowSameNetworkUnicast()) {
        allowSameNetworkUnicast_ = other.allowSameNetworkUnicast_;
        bitField0_ |= 0x00002000;
        onChanged();
      }
      if (other.hasAllowStaticRoutes()) {
        allowStaticRoutes_ = other.allowStaticRoutes_;
        bitField0_ |= 0x00004000;
        onChanged();
      }
      if (other.hasAllowSubInterfaces()) {
        allowSubInterfaces_ = other.allowSubInterfaces_;
        bitField0_ |= 0x00008000;
        onChanged();
      }
      if (other.hasAllowVpcPeering()) {
        allowVpcPeering_ = other.allowVpcPeering_;
        bitField0_ |= 0x00010000;
        onChanged();
      }
      if (other.hasAllowVpn()) {
        allowVpn_ = other.allowVpn_;
        bitField0_ |= 0x00020000;
        onChanged();
      }
      if (!other.interfaceTypes_.isEmpty()) {
        if (interfaceTypes_.isEmpty()) {
          interfaceTypes_ = other.interfaceTypes_;
          bitField0_ |= 0x00040000;
        } else {
          ensureInterfaceTypesIsMutable();
          interfaceTypes_.addAll(other.interfaceTypes_);
        }
        onChanged();
      }
      if (!other.subnetPurposes_.isEmpty()) {
        if (subnetPurposes_.isEmpty()) {
          subnetPurposes_ = other.subnetPurposes_;
          bitField0_ |= 0x00080000;
        } else {
          ensureSubnetPurposesIsMutable();
          subnetPurposes_.addAll(other.subnetPurposes_);
        }
        onChanged();
      }
      if (!other.subnetStackTypes_.isEmpty()) {
        if (subnetStackTypes_.isEmpty()) {
          subnetStackTypes_ = other.subnetStackTypes_;
          bitField0_ |= 0x00100000;
        } else {
          ensureSubnetStackTypesIsMutable();
          subnetStackTypes_.addAll(other.subnetStackTypes_);
        }
        onChanged();
      }
      if (other.hasUnicast()) {
        unicast_ = other.unicast_;
        bitField0_ |= 0x00200000;
        onChanged();
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 706008034:
              {
                allowMultiNicInSameNetwork_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000200;
                break;
              } // case 706008034
            case 923217826:
              {
                allowVpcPeering_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00010000;
                break;
              } // case 923217826
            case 1052304882:
              {
                allowExternalIpAccess_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case 1052304882
            case 1052871898:
              {
                allowClassDFirewalls_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 1052871898
            case 1217530106:
              {
                allowAutoModeSubnet_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 1217530106
            case 1263849370:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureInterfaceTypesIsMutable();
                interfaceTypes_.add(s);
                break;
              } // case 1263849370
            case 1340253146:
              {
                allowSameNetworkUnicast_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00002000;
                break;
              } // case 1340253146
            case 1482063402:
              {
                allowStaticRoutes_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00004000;
                break;
              } // case 1482063402
            case 1786929586:
              {
                allowLoadBalancing_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 1786929586
            case 1977666426:
              {
                allowSubInterfaces_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00008000;
                break;
              } // case 1977666426
            case 1998733690:
              {
                unicast_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00200000;
                break;
              } // case 1998733690
            case 2038650122:
              {
                allowCloudNat_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 2038650122
            case -2050863582:
              {
                allowInterconnect_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case -2050863582
            case -1884262982:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetPurposesIsMutable();
                subnetPurposes_.add(s);
                break;
              } // case -1884262982
            case -1316108718:
              {
                allowPsc_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00001000;
                break;
              } // case -1316108718
            case -1316063246:
              {
                allowVpn_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00020000;
                break;
              } // case -1316063246
            case -1297350718:
              {
                allowPrivateGoogleAccess_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000800;
                break;
              } // case -1297350718
            case -830769150:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureAddressPurposesIsMutable();
                addressPurposes_.add(s);
                break;
              } // case -830769150
            case -686084534:
              {
                allowCloudRouter_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case -686084534
            case -631093686:
              {
                allowAliasIpRanges_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case -631093686
            case -197150702:
              {
                allowPacketMirroring_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000400;
                break;
              } // case -197150702
            case -126897918:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetStackTypesIsMutable();
                subnetStackTypes_.add(s);
                break;
              } // case -126897918
            default:
              {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }

    private int bitField0_;

    private com.google.protobuf.LazyStringArrayList addressPurposes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureAddressPurposesIsMutable() {
      if (!addressPurposes_.isModifiable()) {
        addressPurposes_ = new com.google.protobuf.LazyStringArrayList(addressPurposes_);
      }
      bitField0_ |= 0x00000001;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return A list containing the addressPurposes.
     */
    public com.google.protobuf.ProtocolStringList getAddressPurposesList() {
      addressPurposes_.makeImmutable();
      return addressPurposes_;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return The count of addressPurposes.
     */
    public int getAddressPurposesCount() {
      return addressPurposes_.size();
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index of the element to return.
     * @return The addressPurposes at the given index.
     */
    public java.lang.String getAddressPurposes(int index) {
      return addressPurposes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the addressPurposes at the given index.
     */
    public com.google.protobuf.ByteString getAddressPurposesBytes(int index) {
      return addressPurposes_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index to set the value at.
     * @param value The addressPurposes to set.
     * @return This builder for chaining.
     */
    public Builder setAddressPurposes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAddressPurposesIsMutable();
      addressPurposes_.set(index, value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param value The addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAddressPurposes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAddressPurposesIsMutable();
      addressPurposes_.add(value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param values The addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAllAddressPurposes(java.lang.Iterable<java.lang.String> values) {
      ensureAddressPurposesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, addressPurposes_);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAddressPurposes() {
      addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x00000001);
      ;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param value The bytes of the addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAddressPurposesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureAddressPurposesIsMutable();
      addressPurposes_.add(value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    private java.lang.Object allowAliasIpRanges_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return Whether the allowAliasIpRanges field is set.
     */
    public boolean hasAllowAliasIpRanges() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return The allowAliasIpRanges.
     */
    public java.lang.String getAllowAliasIpRanges() {
      java.lang.Object ref = allowAliasIpRanges_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowAliasIpRanges_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return The bytes for allowAliasIpRanges.
     */
    public com.google.protobuf.ByteString getAllowAliasIpRangesBytes() {
      java.lang.Object ref = allowAliasIpRanges_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowAliasIpRanges_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @param value The allowAliasIpRanges to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAliasIpRanges(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowAliasIpRanges_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowAliasIpRanges() {
      allowAliasIpRanges_ = getDefaultInstance().getAllowAliasIpRanges();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @param value The bytes for allowAliasIpRanges to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAliasIpRangesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowAliasIpRanges_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    private java.lang.Object allowAutoModeSubnet_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return Whether the allowAutoModeSubnet field is set.
     */
    public boolean hasAllowAutoModeSubnet() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return The allowAutoModeSubnet.
     */
    public java.lang.String getAllowAutoModeSubnet() {
      java.lang.Object ref = allowAutoModeSubnet_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowAutoModeSubnet_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return The bytes for allowAutoModeSubnet.
     */
    public com.google.protobuf.ByteString getAllowAutoModeSubnetBytes() {
      java.lang.Object ref = allowAutoModeSubnet_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowAutoModeSubnet_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @param value The allowAutoModeSubnet to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAutoModeSubnet(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowAutoModeSubnet_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowAutoModeSubnet() {
      allowAutoModeSubnet_ = getDefaultInstance().getAllowAutoModeSubnet();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @param value The bytes for allowAutoModeSubnet to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAutoModeSubnetBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowAutoModeSubnet_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    private java.lang.Object allowClassDFirewalls_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return Whether the allowClassDFirewalls field is set.
     */
    public boolean hasAllowClassDFirewalls() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return The allowClassDFirewalls.
     */
    public java.lang.String getAllowClassDFirewalls() {
      java.lang.Object ref = allowClassDFirewalls_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowClassDFirewalls_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return The bytes for allowClassDFirewalls.
     */
    public com.google.protobuf.ByteString getAllowClassDFirewallsBytes() {
      java.lang.Object ref = allowClassDFirewalls_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowClassDFirewalls_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @param value The allowClassDFirewalls to set.
     * @return This builder for chaining.
     */
    public Builder setAllowClassDFirewalls(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowClassDFirewalls_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowClassDFirewalls() {
      allowClassDFirewalls_ = getDefaultInstance().getAllowClassDFirewalls();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @param value The bytes for allowClassDFirewalls to set.
     * @return This builder for chaining.
     */
    public Builder setAllowClassDFirewallsBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowClassDFirewalls_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    private java.lang.Object allowCloudNat_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return Whether the allowCloudNat field is set.
     */
    public boolean hasAllowCloudNat() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return The allowCloudNat.
     */
    public java.lang.String getAllowCloudNat() {
      java.lang.Object ref = allowCloudNat_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowCloudNat_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return The bytes for allowCloudNat.
     */
    public com.google.protobuf.ByteString getAllowCloudNatBytes() {
      java.lang.Object ref = allowCloudNat_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowCloudNat_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @param value The allowCloudNat to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudNat(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowCloudNat_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowCloudNat() {
      allowCloudNat_ = getDefaultInstance().getAllowCloudNat();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @param value The bytes for allowCloudNat to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudNatBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowCloudNat_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    private java.lang.Object allowCloudRouter_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return Whether the allowCloudRouter field is set.
     */
    public boolean hasAllowCloudRouter() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return The allowCloudRouter.
     */
    public java.lang.String getAllowCloudRouter() {
      java.lang.Object ref = allowCloudRouter_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowCloudRouter_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return The bytes for allowCloudRouter.
     */
    public com.google.protobuf.ByteString getAllowCloudRouterBytes() {
      java.lang.Object ref = allowCloudRouter_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowCloudRouter_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @param value The allowCloudRouter to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudRouter(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowCloudRouter_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowCloudRouter() {
      allowCloudRouter_ = getDefaultInstance().getAllowCloudRouter();
      bitField0_ = (bitField0_ & ~0x00000020);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @param value The bytes for allowCloudRouter to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudRouterBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowCloudRouter_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    private java.lang.Object allowExternalIpAccess_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return Whether the allowExternalIpAccess field is set.
     */
    public boolean hasAllowExternalIpAccess() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return The allowExternalIpAccess.
     */
    public java.lang.String getAllowExternalIpAccess() {
      java.lang.Object ref = allowExternalIpAccess_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowExternalIpAccess_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return The bytes for allowExternalIpAccess.
     */
    public com.google.protobuf.ByteString getAllowExternalIpAccessBytes() {
      java.lang.Object ref = allowExternalIpAccess_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowExternalIpAccess_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @param value The allowExternalIpAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowExternalIpAccess(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowExternalIpAccess_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowExternalIpAccess() {
      allowExternalIpAccess_ = getDefaultInstance().getAllowExternalIpAccess();
      bitField0_ = (bitField0_ & ~0x00000040);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @param value The bytes for allowExternalIpAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowExternalIpAccessBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowExternalIpAccess_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    private java.lang.Object allowInterconnect_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return Whether the allowInterconnect field is set.
     */
    public boolean hasAllowInterconnect() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return The allowInterconnect.
     */
    public java.lang.String getAllowInterconnect() {
      java.lang.Object ref = allowInterconnect_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowInterconnect_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return The bytes for allowInterconnect.
     */
    public com.google.protobuf.ByteString getAllowInterconnectBytes() {
      java.lang.Object ref = allowInterconnect_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowInterconnect_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @param value The allowInterconnect to set.
     * @return This builder for chaining.
     */
    public Builder setAllowInterconnect(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowInterconnect_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowInterconnect() {
      allowInterconnect_ = getDefaultInstance().getAllowInterconnect();
      bitField0_ = (bitField0_ & ~0x00000080);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @param value The bytes for allowInterconnect to set.
     * @return This builder for chaining.
     */
    public Builder setAllowInterconnectBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowInterconnect_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }

    private java.lang.Object allowLoadBalancing_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return Whether the allowLoadBalancing field is set.
     */
    public boolean hasAllowLoadBalancing() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return The allowLoadBalancing.
     */
    public java.lang.String getAllowLoadBalancing() {
      java.lang.Object ref = allowLoadBalancing_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowLoadBalancing_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return The bytes for allowLoadBalancing.
     */
    public com.google.protobuf.ByteString getAllowLoadBalancingBytes() {
      java.lang.Object ref = allowLoadBalancing_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowLoadBalancing_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @param value The allowLoadBalancing to set.
     * @return This builder for chaining.
     */
    public Builder setAllowLoadBalancing(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowLoadBalancing_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowLoadBalancing() {
      allowLoadBalancing_ = getDefaultInstance().getAllowLoadBalancing();
      bitField0_ = (bitField0_ & ~0x00000100);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @param value The bytes for allowLoadBalancing to set.
     * @return This builder for chaining.
     */
    public Builder setAllowLoadBalancingBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowLoadBalancing_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }

    private java.lang.Object allowMultiNicInSameNetwork_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return Whether the allowMultiNicInSameNetwork field is set.
     */
    public boolean hasAllowMultiNicInSameNetwork() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return The allowMultiNicInSameNetwork.
     */
    public java.lang.String getAllowMultiNicInSameNetwork() {
      java.lang.Object ref = allowMultiNicInSameNetwork_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowMultiNicInSameNetwork_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return The bytes for allowMultiNicInSameNetwork.
     */
    public com.google.protobuf.ByteString getAllowMultiNicInSameNetworkBytes() {
      java.lang.Object ref = allowMultiNicInSameNetwork_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowMultiNicInSameNetwork_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @param value The allowMultiNicInSameNetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameNetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowMultiNicInSameNetwork_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowMultiNicInSameNetwork() {
      allowMultiNicInSameNetwork_ = getDefaultInstance().getAllowMultiNicInSameNetwork();
      bitField0_ = (bitField0_ & ~0x00000200);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @param value The bytes for allowMultiNicInSameNetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameNetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowMultiNicInSameNetwork_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }

    private java.lang.Object allowPacketMirroring_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return Whether the allowPacketMirroring field is set.
     */
    public boolean hasAllowPacketMirroring() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return The allowPacketMirroring.
     */
    public java.lang.String getAllowPacketMirroring() {
      java.lang.Object ref = allowPacketMirroring_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPacketMirroring_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return The bytes for allowPacketMirroring.
     */
    public com.google.protobuf.ByteString getAllowPacketMirroringBytes() {
      java.lang.Object ref = allowPacketMirroring_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPacketMirroring_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @param value The allowPacketMirroring to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPacketMirroring(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPacketMirroring_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPacketMirroring() {
      allowPacketMirroring_ = getDefaultInstance().getAllowPacketMirroring();
      bitField0_ = (bitField0_ & ~0x00000400);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @param value The bytes for allowPacketMirroring to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPacketMirroringBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPacketMirroring_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }

    private java.lang.Object allowPrivateGoogleAccess_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return Whether the allowPrivateGoogleAccess field is set.
     */
    public boolean hasAllowPrivateGoogleAccess() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return The allowPrivateGoogleAccess.
     */
    public java.lang.String getAllowPrivateGoogleAccess() {
      java.lang.Object ref = allowPrivateGoogleAccess_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPrivateGoogleAccess_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return The bytes for allowPrivateGoogleAccess.
     */
    public com.google.protobuf.ByteString getAllowPrivateGoogleAccessBytes() {
      java.lang.Object ref = allowPrivateGoogleAccess_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPrivateGoogleAccess_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @param value The allowPrivateGoogleAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPrivateGoogleAccess(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPrivateGoogleAccess_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPrivateGoogleAccess() {
      allowPrivateGoogleAccess_ = getDefaultInstance().getAllowPrivateGoogleAccess();
      bitField0_ = (bitField0_ & ~0x00000800);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @param value The bytes for allowPrivateGoogleAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPrivateGoogleAccessBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPrivateGoogleAccess_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }

    private java.lang.Object allowPsc_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return Whether the allowPsc field is set.
     */
    public boolean hasAllowPsc() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return The allowPsc.
     */
    public java.lang.String getAllowPsc() {
      java.lang.Object ref = allowPsc_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPsc_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return The bytes for allowPsc.
     */
    public com.google.protobuf.ByteString getAllowPscBytes() {
      java.lang.Object ref = allowPsc_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPsc_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @param value The allowPsc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPsc(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPsc_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPsc() {
      allowPsc_ = getDefaultInstance().getAllowPsc();
      bitField0_ = (bitField0_ & ~0x00001000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @param value The bytes for allowPsc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPscBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPsc_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }

    private java.lang.Object allowSameNetworkUnicast_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return Whether the allowSameNetworkUnicast field is set.
     */
    public boolean hasAllowSameNetworkUnicast() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return The allowSameNetworkUnicast.
     */
    public java.lang.String getAllowSameNetworkUnicast() {
      java.lang.Object ref = allowSameNetworkUnicast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowSameNetworkUnicast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return The bytes for allowSameNetworkUnicast.
     */
    public com.google.protobuf.ByteString getAllowSameNetworkUnicastBytes() {
      java.lang.Object ref = allowSameNetworkUnicast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowSameNetworkUnicast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @param value The allowSameNetworkUnicast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSameNetworkUnicast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowSameNetworkUnicast_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowSameNetworkUnicast() {
      allowSameNetworkUnicast_ = getDefaultInstance().getAllowSameNetworkUnicast();
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @param value The bytes for allowSameNetworkUnicast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSameNetworkUnicastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowSameNetworkUnicast_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }

    private java.lang.Object allowStaticRoutes_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return Whether the allowStaticRoutes field is set.
     */
    public boolean hasAllowStaticRoutes() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return The allowStaticRoutes.
     */
    public java.lang.String getAllowStaticRoutes() {
      java.lang.Object ref = allowStaticRoutes_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowStaticRoutes_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return The bytes for allowStaticRoutes.
     */
    public com.google.protobuf.ByteString getAllowStaticRoutesBytes() {
      java.lang.Object ref = allowStaticRoutes_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowStaticRoutes_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @param value The allowStaticRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setAllowStaticRoutes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowStaticRoutes_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowStaticRoutes() {
      allowStaticRoutes_ = getDefaultInstance().getAllowStaticRoutes();
      bitField0_ = (bitField0_ & ~0x00004000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @param value The bytes for allowStaticRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setAllowStaticRoutesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowStaticRoutes_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }

    private java.lang.Object allowSubInterfaces_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return Whether the allowSubInterfaces field is set.
     */
    public boolean hasAllowSubInterfaces() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return The allowSubInterfaces.
     */
    public java.lang.String getAllowSubInterfaces() {
      java.lang.Object ref = allowSubInterfaces_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowSubInterfaces_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return The bytes for allowSubInterfaces.
     */
    public com.google.protobuf.ByteString getAllowSubInterfacesBytes() {
      java.lang.Object ref = allowSubInterfaces_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowSubInterfaces_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @param value The allowSubInterfaces to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubInterfaces(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowSubInterfaces_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowSubInterfaces() {
      allowSubInterfaces_ = getDefaultInstance().getAllowSubInterfaces();
      bitField0_ = (bitField0_ & ~0x00008000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @param value The bytes for allowSubInterfaces to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubInterfacesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowSubInterfaces_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    private java.lang.Object allowVpcPeering_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return Whether the allowVpcPeering field is set.
     */
    public boolean hasAllowVpcPeering() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return The allowVpcPeering.
     */
    public java.lang.String getAllowVpcPeering() {
      java.lang.Object ref = allowVpcPeering_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowVpcPeering_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return The bytes for allowVpcPeering.
     */
    public com.google.protobuf.ByteString getAllowVpcPeeringBytes() {
      java.lang.Object ref = allowVpcPeering_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowVpcPeering_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @param value The allowVpcPeering to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcPeering(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowVpcPeering_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowVpcPeering() {
      allowVpcPeering_ = getDefaultInstance().getAllowVpcPeering();
      bitField0_ = (bitField0_ & ~0x00010000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @param value The bytes for allowVpcPeering to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcPeeringBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowVpcPeering_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }

    private java.lang.Object allowVpn_ = "";
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return Whether the allowVpn field is set.
     */
    public boolean hasAllowVpn() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return The allowVpn.
     */
    public java.lang.String getAllowVpn() {
      java.lang.Object ref = allowVpn_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowVpn_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return The bytes for allowVpn.
     */
    public com.google.protobuf.ByteString getAllowVpnBytes() {
      java.lang.Object ref = allowVpn_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowVpn_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @param value The allowVpn to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpn(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowVpn_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowVpn() {
      allowVpn_ = getDefaultInstance().getAllowVpn();
      bitField0_ = (bitField0_ & ~0x00020000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @param value The bytes for allowVpn to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpnBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowVpn_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList interfaceTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureInterfaceTypesIsMutable() {
      if (!interfaceTypes_.isModifiable()) {
        interfaceTypes_ = new com.google.protobuf.LazyStringArrayList(interfaceTypes_);
      }
      bitField0_ |= 0x00040000;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return A list containing the interfaceTypes.
     */
    public com.google.protobuf.ProtocolStringList getInterfaceTypesList() {
      interfaceTypes_.makeImmutable();
      return interfaceTypes_;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return The count of interfaceTypes.
     */
    public int getInterfaceTypesCount() {
      return interfaceTypes_.size();
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index of the element to return.
     * @return The interfaceTypes at the given index.
     */
    public java.lang.String getInterfaceTypes(int index) {
      return interfaceTypes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the interfaceTypes at the given index.
     */
    public com.google.protobuf.ByteString getInterfaceTypesBytes(int index) {
      return interfaceTypes_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index to set the value at.
     * @param value The interfaceTypes to set.
     * @return This builder for chaining.
     */
    public Builder setInterfaceTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.set(index, value);
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param value The interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addInterfaceTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.add(value);
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param values The interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllInterfaceTypes(java.lang.Iterable<java.lang.String> values) {
      ensureInterfaceTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, interfaceTypes_);
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearInterfaceTypes() {
      interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x00040000);
      ;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param value The bytes of the interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addInterfaceTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.add(value);
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList subnetPurposes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetPurposesIsMutable() {
      if (!subnetPurposes_.isModifiable()) {
        subnetPurposes_ = new com.google.protobuf.LazyStringArrayList(subnetPurposes_);
      }
      bitField0_ |= 0x00080000;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return A list containing the subnetPurposes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetPurposesList() {
      subnetPurposes_.makeImmutable();
      return subnetPurposes_;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return The count of subnetPurposes.
     */
    public int getSubnetPurposesCount() {
      return subnetPurposes_.size();
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetPurposes at the given index.
     */
    public java.lang.String getSubnetPurposes(int index) {
      return subnetPurposes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetPurposes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetPurposesBytes(int index) {
      return subnetPurposes_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetPurposes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetPurposes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.set(index, value);
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param value The subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetPurposes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.add(value);
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param values The subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetPurposes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetPurposesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetPurposes_);
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetPurposes() {
      subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x00080000);
      ;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param value The bytes of the subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetPurposesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.add(value);
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList subnetStackTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetStackTypesIsMutable() {
      if (!subnetStackTypes_.isModifiable()) {
        subnetStackTypes_ = new com.google.protobuf.LazyStringArrayList(subnetStackTypes_);
      }
      bitField0_ |= 0x00100000;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return A list containing the subnetStackTypes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetStackTypesList() {
      subnetStackTypes_.makeImmutable();
      return subnetStackTypes_;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return The count of subnetStackTypes.
     */
    public int getSubnetStackTypesCount() {
      return subnetStackTypes_.size();
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetStackTypes at the given index.
     */
    public java.lang.String getSubnetStackTypes(int index) {
      return subnetStackTypes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetStackTypes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetStackTypesBytes(int index) {
      return subnetStackTypes_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetStackTypes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetStackTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.set(index, value);
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param value The subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetStackTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.add(value);
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param values The subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetStackTypes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetStackTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetStackTypes_);
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetStackTypes() {
      subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x00100000);
      ;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param value The bytes of the subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetStackTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.add(value);
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }

    private java.lang.Object unicast_ = "";
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return Whether the unicast field is set.
     */
    public boolean hasUnicast() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return The unicast.
     */
    public java.lang.String getUnicast() {
      java.lang.Object ref = unicast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        unicast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return The bytes for unicast.
     */
    public com.google.protobuf.ByteString getUnicastBytes() {
      java.lang.Object ref = unicast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        unicast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @param value The unicast to set.
     * @return This builder for chaining.
     */
    public Builder setUnicast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      unicast_ = value;
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearUnicast() {
      unicast_ = getDefaultInstance().getUnicast();
      bitField0_ = (bitField0_ & ~0x00200000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @param value The bytes for unicast to set.
     * @return This builder for chaining.
     */
    public Builder setUnicastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      unicast_ = value;
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
  private static final com.google.cloud.compute.v1.NetworkProfileNetworkFeatures DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.NetworkProfileNetworkFeatures();
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<NetworkProfileNetworkFeatures> PARSER =
      new com.google.protobuf.AbstractParser<NetworkProfileNetworkFeatures>() {
        @java.lang.Override
        public NetworkProfileNetworkFeatures parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

  public static com.google.protobuf.Parser<NetworkProfileNetworkFeatures> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<NetworkProfileNetworkFeatures> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
