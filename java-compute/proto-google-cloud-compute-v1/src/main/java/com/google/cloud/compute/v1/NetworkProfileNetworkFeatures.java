/*
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

// Protobuf Java Version: 3.25.8
package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures}
 */
public final class NetworkProfileNetworkFeatures extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
    NetworkProfileNetworkFeaturesOrBuilder {
  private static final long serialVersionUID = 0L;

  // Use NetworkProfileNetworkFeatures.newBuilder() to construct.
  private NetworkProfileNetworkFeatures(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private NetworkProfileNetworkFeatures() {
    addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    allowAddressCreation_ = "";
    allowAliasIpRanges_ = "";
    allowAutoModeSubnet_ = "";
    allowClassDFirewalls_ = "";
    allowCloudNat_ = "";
    allowCloudRouter_ = "";
    allowDefaultNicAttachment_ = "";
    allowExternalIpAccess_ = "";
    allowFirewallPolicy_ = "";
    allowInterconnect_ = "";
    allowIpForwarding_ = "";
    allowLoadBalancing_ = "";
    allowMultiNicInSameNetwork_ = "";
    allowMultiNicInSameSubnetwork_ = "";
    allowMulticast_ = "";
    allowNcc_ = "";
    allowNetworkMigration_ = "";
    allowPacketMirroring_ = "";
    allowPrivateGoogleAccess_ = "";
    allowPsc_ = "";
    allowSameNetworkUnicast_ = "";
    allowStaticRoutes_ = "";
    allowSubInterfaces_ = "";
    allowSubnetworkCreation_ = "";
    allowVpcFirewallRules_ = "";
    allowVpcPeering_ = "";
    allowVpn_ = "";
    firewallPolicyTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    multicast_ = "";
    predefinedNetworkInternalIpv6Range_ = "";
    predefinedSubnetworkRanges_ = java.util.Collections.emptyList();
    subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    subnetworkPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    subnetworkStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
    unicast_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new NetworkProfileNetworkFeatures();
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.class,
            com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.Builder.class);
  }

  /**
   *
   *
   * <pre>
   *
   * Additional supported values which may be not listed in the enum directly due to technical reasons:
   * PRIVATE_SERVICE_CONNECT
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AddressPurposes}
   */
  public enum AddressPurposes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ADDRESS_PURPOSES = 0;</code>
     */
    UNDEFINED_ADDRESS_PURPOSES(0),
    /**
     *
     *
     * <pre>
     * DNS resolver address in the subnetwork.
     * </pre>
     *
     * <code>DNS_RESOLVER = 476114556;</code>
     */
    DNS_RESOLVER(476114556),
    /**
     *
     *
     * <pre>
     * VM internal/alias IP, Internal LB service IP, etc.
     * </pre>
     *
     * <code>GCE_ENDPOINT = 230515243;</code>
     */
    GCE_ENDPOINT(230515243),
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for the VLAN attachment
     * that is used in HA VPN over Cloud Interconnect. This regional
     * internal IP address range must not overlap with any IP address range
     * of subnet/route in the VPC network and its peering networks. After the
     * VLAN attachment is created with the reserved IP address range, when
     * creating a new VPN gateway, its interface IP address is allocated
     * from the associated VLAN attachment’s IP address range.
     * </pre>
     *
     * <code>IPSEC_INTERCONNECT = 340437251;</code>
     */
    IPSEC_INTERCONNECT(340437251),
    /**
     *
     *
     * <pre>
     * External IP automatically reserved for Cloud NAT.
     * </pre>
     *
     * <code>NAT_AUTO = 163666477;</code>
     */
    NAT_AUTO(163666477),
    /** <code>PRIVATE_SERVICE_CONNECT = 48134724;</code> */
    PRIVATE_SERVICE_CONNECT(48134724),
    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for Serverless.
     * </pre>
     *
     * <code>SERVERLESS = 270492508;</code>
     */
    SERVERLESS(270492508),
    /**
     *
     *
     * <pre>
     * A private network IP address that can be shared by multiple Internal
     * Load Balancer forwarding rules.
     * </pre>
     *
     * <code>SHARED_LOADBALANCER_VIP = 294447572;</code>
     */
    SHARED_LOADBALANCER_VIP(294447572),
    /**
     *
     *
     * <pre>
     * IP range for peer networks.
     * </pre>
     *
     * <code>VPC_PEERING = 400800170;</code>
     */
    VPC_PEERING(400800170),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ADDRESS_PURPOSES = 0;</code>
     */
    public static final int UNDEFINED_ADDRESS_PURPOSES_VALUE = 0;

    /**
     *
     *
     * <pre>
     * DNS resolver address in the subnetwork.
     * </pre>
     *
     * <code>DNS_RESOLVER = 476114556;</code>
     */
    public static final int DNS_RESOLVER_VALUE = 476114556;

    /**
     *
     *
     * <pre>
     * VM internal/alias IP, Internal LB service IP, etc.
     * </pre>
     *
     * <code>GCE_ENDPOINT = 230515243;</code>
     */
    public static final int GCE_ENDPOINT_VALUE = 230515243;

    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for the VLAN attachment
     * that is used in HA VPN over Cloud Interconnect. This regional
     * internal IP address range must not overlap with any IP address range
     * of subnet/route in the VPC network and its peering networks. After the
     * VLAN attachment is created with the reserved IP address range, when
     * creating a new VPN gateway, its interface IP address is allocated
     * from the associated VLAN attachment’s IP address range.
     * </pre>
     *
     * <code>IPSEC_INTERCONNECT = 340437251;</code>
     */
    public static final int IPSEC_INTERCONNECT_VALUE = 340437251;

    /**
     *
     *
     * <pre>
     * External IP automatically reserved for Cloud NAT.
     * </pre>
     *
     * <code>NAT_AUTO = 163666477;</code>
     */
    public static final int NAT_AUTO_VALUE = 163666477;

    /** <code>PRIVATE_SERVICE_CONNECT = 48134724;</code> */
    public static final int PRIVATE_SERVICE_CONNECT_VALUE = 48134724;

    /**
     *
     *
     * <pre>
     * A regional internal IP address range reserved for Serverless.
     * </pre>
     *
     * <code>SERVERLESS = 270492508;</code>
     */
    public static final int SERVERLESS_VALUE = 270492508;

    /**
     *
     *
     * <pre>
     * A private network IP address that can be shared by multiple Internal
     * Load Balancer forwarding rules.
     * </pre>
     *
     * <code>SHARED_LOADBALANCER_VIP = 294447572;</code>
     */
    public static final int SHARED_LOADBALANCER_VIP_VALUE = 294447572;

    /**
     *
     *
     * <pre>
     * IP range for peer networks.
     * </pre>
     *
     * <code>VPC_PEERING = 400800170;</code>
     */
    public static final int VPC_PEERING_VALUE = 400800170;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AddressPurposes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AddressPurposes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ADDRESS_PURPOSES;
        case 476114556:
          return DNS_RESOLVER;
        case 230515243:
          return GCE_ENDPOINT;
        case 340437251:
          return IPSEC_INTERCONNECT;
        case 163666477:
          return NAT_AUTO;
        case 48134724:
          return PRIVATE_SERVICE_CONNECT;
        case 270492508:
          return SERVERLESS;
        case 294447572:
          return SHARED_LOADBALANCER_VIP;
        case 400800170:
          return VPC_PEERING;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AddressPurposes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AddressPurposes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AddressPurposes>() {
              public AddressPurposes findValueByNumber(int number) {
                return AddressPurposes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(0);
    }

    private static final AddressPurposes[] VALUES = values();

    public static AddressPurposes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AddressPurposes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AddressPurposes)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether address creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAddressCreation}
   */
  public enum AllowAddressCreation implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ADDRESS_CREATION = 0;</code>
     */
    UNDEFINED_ALLOW_ADDRESS_CREATION(0),
    /** <code>ADDRESS_CREATION_ALLOWED = 181903667;</code> */
    ADDRESS_CREATION_ALLOWED(181903667),
    /** <code>ADDRESS_CREATION_BLOCKED = 534937975;</code> */
    ADDRESS_CREATION_BLOCKED(534937975),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ADDRESS_CREATION = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_ADDRESS_CREATION_VALUE = 0;

    /** <code>ADDRESS_CREATION_ALLOWED = 181903667;</code> */
    public static final int ADDRESS_CREATION_ALLOWED_VALUE = 181903667;

    /** <code>ADDRESS_CREATION_BLOCKED = 534937975;</code> */
    public static final int ADDRESS_CREATION_BLOCKED_VALUE = 534937975;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowAddressCreation valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowAddressCreation forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_ADDRESS_CREATION;
        case 181903667:
          return ADDRESS_CREATION_ALLOWED;
        case 534937975:
          return ADDRESS_CREATION_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowAddressCreation>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowAddressCreation>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowAddressCreation>() {
              public AllowAddressCreation findValueByNumber(int number) {
                return AllowAddressCreation.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(1);
    }

    private static final AllowAddressCreation[] VALUES = values();

    public static AllowAddressCreation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowAddressCreation(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAddressCreation)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are
   * allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAliasIpRanges}
   */
  public enum AllowAliasIpRanges implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ALIAS_IP_RANGES = 0;</code>
     */
    UNDEFINED_ALLOW_ALIAS_IP_RANGES(0),
    /** <code>ALIAS_IP_RANGES_ALLOWED = 464867048;</code> */
    ALIAS_IP_RANGES_ALLOWED(464867048),
    /** <code>ALIAS_IP_RANGES_BLOCKED = 281030444;</code> */
    ALIAS_IP_RANGES_BLOCKED(281030444),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_ALIAS_IP_RANGES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_ALIAS_IP_RANGES_VALUE = 0;

    /** <code>ALIAS_IP_RANGES_ALLOWED = 464867048;</code> */
    public static final int ALIAS_IP_RANGES_ALLOWED_VALUE = 464867048;

    /** <code>ALIAS_IP_RANGES_BLOCKED = 281030444;</code> */
    public static final int ALIAS_IP_RANGES_BLOCKED_VALUE = 281030444;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowAliasIpRanges valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowAliasIpRanges forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_ALIAS_IP_RANGES;
        case 464867048:
          return ALIAS_IP_RANGES_ALLOWED;
        case 281030444:
          return ALIAS_IP_RANGES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowAliasIpRanges>() {
              public AllowAliasIpRanges findValueByNumber(int number) {
                return AllowAliasIpRanges.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(2);
    }

    private static final AllowAliasIpRanges[] VALUES = values();

    public static AllowAliasIpRanges valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowAliasIpRanges(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAliasIpRanges)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAutoModeSubnet}
   */
  public enum AllowAutoModeSubnet implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_AUTO_MODE_SUBNET = 0;</code>
     */
    UNDEFINED_ALLOW_AUTO_MODE_SUBNET(0),
    /** <code>AUTO_MODE_SUBNET_ALLOWED = 391042610;</code> */
    AUTO_MODE_SUBNET_ALLOWED(391042610),
    /** <code>AUTO_MODE_SUBNET_BLOCKED = 207206006;</code> */
    AUTO_MODE_SUBNET_BLOCKED(207206006),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_AUTO_MODE_SUBNET = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_AUTO_MODE_SUBNET_VALUE = 0;

    /** <code>AUTO_MODE_SUBNET_ALLOWED = 391042610;</code> */
    public static final int AUTO_MODE_SUBNET_ALLOWED_VALUE = 391042610;

    /** <code>AUTO_MODE_SUBNET_BLOCKED = 207206006;</code> */
    public static final int AUTO_MODE_SUBNET_BLOCKED_VALUE = 207206006;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowAutoModeSubnet valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowAutoModeSubnet forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_AUTO_MODE_SUBNET;
        case 391042610:
          return AUTO_MODE_SUBNET_ALLOWED;
        case 207206006:
          return AUTO_MODE_SUBNET_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowAutoModeSubnet>() {
              public AllowAutoModeSubnet findValueByNumber(int number) {
                return AllowAutoModeSubnet.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(3);
    }

    private static final AllowAutoModeSubnet[] VALUES = values();

    public static AllowAutoModeSubnet valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowAutoModeSubnet(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowAutoModeSubnet)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowClassDFirewalls}
   */
  public enum AllowClassDFirewalls implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLASS_D_FIREWALLS = 0;</code>
     */
    UNDEFINED_ALLOW_CLASS_D_FIREWALLS(0),
    /** <code>CLASS_D_FIREWALLS_ALLOWED = 348219386;</code> */
    CLASS_D_FIREWALLS_ALLOWED(348219386),
    /** <code>CLASS_D_FIREWALLS_BLOCKED = 164382782;</code> */
    CLASS_D_FIREWALLS_BLOCKED(164382782),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLASS_D_FIREWALLS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLASS_D_FIREWALLS_VALUE = 0;

    /** <code>CLASS_D_FIREWALLS_ALLOWED = 348219386;</code> */
    public static final int CLASS_D_FIREWALLS_ALLOWED_VALUE = 348219386;

    /** <code>CLASS_D_FIREWALLS_BLOCKED = 164382782;</code> */
    public static final int CLASS_D_FIREWALLS_BLOCKED_VALUE = 164382782;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowClassDFirewalls valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowClassDFirewalls forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLASS_D_FIREWALLS;
        case 348219386:
          return CLASS_D_FIREWALLS_ALLOWED;
        case 164382782:
          return CLASS_D_FIREWALLS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowClassDFirewalls>() {
              public AllowClassDFirewalls findValueByNumber(int number) {
                return AllowClassDFirewalls.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(4);
    }

    private static final AllowClassDFirewalls[] VALUES = values();

    public static AllowClassDFirewalls valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowClassDFirewalls(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowClassDFirewalls)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudNat}
   */
  public enum AllowCloudNat implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_NAT = 0;</code>
     */
    UNDEFINED_ALLOW_CLOUD_NAT(0),
    /** <code>CLOUD_NAT_ALLOWED = 245931296;</code> */
    CLOUD_NAT_ALLOWED(245931296),
    /** <code>CLOUD_NAT_BLOCKED = 62094692;</code> */
    CLOUD_NAT_BLOCKED(62094692),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_NAT = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLOUD_NAT_VALUE = 0;

    /** <code>CLOUD_NAT_ALLOWED = 245931296;</code> */
    public static final int CLOUD_NAT_ALLOWED_VALUE = 245931296;

    /** <code>CLOUD_NAT_BLOCKED = 62094692;</code> */
    public static final int CLOUD_NAT_BLOCKED_VALUE = 62094692;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowCloudNat valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowCloudNat forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLOUD_NAT;
        case 245931296:
          return CLOUD_NAT_ALLOWED;
        case 62094692:
          return CLOUD_NAT_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowCloudNat>() {
          public AllowCloudNat findValueByNumber(int number) {
            return AllowCloudNat.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(5);
    }

    private static final AllowCloudNat[] VALUES = values();

    public static AllowCloudNat valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowCloudNat(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudNat)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudRouter}
   */
  public enum AllowCloudRouter implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_ROUTER = 0;</code>
     */
    UNDEFINED_ALLOW_CLOUD_ROUTER(0),
    /** <code>CLOUD_ROUTER_ALLOWED = 365388284;</code> */
    CLOUD_ROUTER_ALLOWED(365388284),
    /** <code>CLOUD_ROUTER_BLOCKED = 181551680;</code> */
    CLOUD_ROUTER_BLOCKED(181551680),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_CLOUD_ROUTER = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_CLOUD_ROUTER_VALUE = 0;

    /** <code>CLOUD_ROUTER_ALLOWED = 365388284;</code> */
    public static final int CLOUD_ROUTER_ALLOWED_VALUE = 365388284;

    /** <code>CLOUD_ROUTER_BLOCKED = 181551680;</code> */
    public static final int CLOUD_ROUTER_BLOCKED_VALUE = 181551680;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowCloudRouter valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowCloudRouter forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_CLOUD_ROUTER;
        case 365388284:
          return CLOUD_ROUTER_ALLOWED;
        case 181551680:
          return CLOUD_ROUTER_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowCloudRouter>() {
              public AllowCloudRouter findValueByNumber(int number) {
                return AllowCloudRouter.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(6);
    }

    private static final AllowCloudRouter[] VALUES = values();

    public static AllowCloudRouter valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowCloudRouter(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowCloudRouter)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether default NIC attachment is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowDefaultNicAttachment}
   */
  public enum AllowDefaultNicAttachment implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_DEFAULT_NIC_ATTACHMENT = 0;</code>
     */
    UNDEFINED_ALLOW_DEFAULT_NIC_ATTACHMENT(0),
    /** <code>DEFAULT_NIC_ATTACHMENT_ALLOWED = 11570689;</code> */
    DEFAULT_NIC_ATTACHMENT_ALLOWED(11570689),
    /** <code>DEFAULT_NIC_ATTACHMENT_BLOCKED = 364604997;</code> */
    DEFAULT_NIC_ATTACHMENT_BLOCKED(364604997),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_DEFAULT_NIC_ATTACHMENT = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_DEFAULT_NIC_ATTACHMENT_VALUE = 0;

    /** <code>DEFAULT_NIC_ATTACHMENT_ALLOWED = 11570689;</code> */
    public static final int DEFAULT_NIC_ATTACHMENT_ALLOWED_VALUE = 11570689;

    /** <code>DEFAULT_NIC_ATTACHMENT_BLOCKED = 364604997;</code> */
    public static final int DEFAULT_NIC_ATTACHMENT_BLOCKED_VALUE = 364604997;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowDefaultNicAttachment valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowDefaultNicAttachment forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_DEFAULT_NIC_ATTACHMENT;
        case 11570689:
          return DEFAULT_NIC_ATTACHMENT_ALLOWED;
        case 364604997:
          return DEFAULT_NIC_ATTACHMENT_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowDefaultNicAttachment>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowDefaultNicAttachment>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowDefaultNicAttachment>() {
              public AllowDefaultNicAttachment findValueByNumber(int number) {
                return AllowDefaultNicAttachment.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(7);
    }

    private static final AllowDefaultNicAttachment[] VALUES = values();

    public static AllowDefaultNicAttachment valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowDefaultNicAttachment(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowDefaultNicAttachment)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network
   * interfaces connected to this VPC.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowExternalIpAccess}
   */
  public enum AllowExternalIpAccess implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS = 0;</code>
     */
    UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS(0),
    /** <code>EXTERNAL_IP_ACCESS_ALLOWED = 109530193;</code> */
    EXTERNAL_IP_ACCESS_ALLOWED(109530193),
    /** <code>EXTERNAL_IP_ACCESS_BLOCKED = 462564501;</code> */
    EXTERNAL_IP_ACCESS_BLOCKED(462564501),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS_VALUE = 0;

    /** <code>EXTERNAL_IP_ACCESS_ALLOWED = 109530193;</code> */
    public static final int EXTERNAL_IP_ACCESS_ALLOWED_VALUE = 109530193;

    /** <code>EXTERNAL_IP_ACCESS_BLOCKED = 462564501;</code> */
    public static final int EXTERNAL_IP_ACCESS_BLOCKED_VALUE = 462564501;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowExternalIpAccess valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowExternalIpAccess forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_EXTERNAL_IP_ACCESS;
        case 109530193:
          return EXTERNAL_IP_ACCESS_ALLOWED;
        case 462564501:
          return EXTERNAL_IP_ACCESS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowExternalIpAccess>() {
              public AllowExternalIpAccess findValueByNumber(int number) {
                return AllowExternalIpAccess.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(8);
    }

    private static final AllowExternalIpAccess[] VALUES = values();

    public static AllowExternalIpAccess valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowExternalIpAccess(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowExternalIpAccess)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewall policy can be attached to the network.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowFirewallPolicy}
   */
  public enum AllowFirewallPolicy implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_FIREWALL_POLICY = 0;</code>
     */
    UNDEFINED_ALLOW_FIREWALL_POLICY(0),
    /** <code>FIREWALL_POLICY_ALLOWED = 388488346;</code> */
    FIREWALL_POLICY_ALLOWED(388488346),
    /** <code>FIREWALL_POLICY_BLOCKED = 204651742;</code> */
    FIREWALL_POLICY_BLOCKED(204651742),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_FIREWALL_POLICY = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_FIREWALL_POLICY_VALUE = 0;

    /** <code>FIREWALL_POLICY_ALLOWED = 388488346;</code> */
    public static final int FIREWALL_POLICY_ALLOWED_VALUE = 388488346;

    /** <code>FIREWALL_POLICY_BLOCKED = 204651742;</code> */
    public static final int FIREWALL_POLICY_BLOCKED_VALUE = 204651742;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowFirewallPolicy valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowFirewallPolicy forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_FIREWALL_POLICY;
        case 388488346:
          return FIREWALL_POLICY_ALLOWED;
        case 204651742:
          return FIREWALL_POLICY_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowFirewallPolicy>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowFirewallPolicy>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowFirewallPolicy>() {
              public AllowFirewallPolicy findValueByNumber(int number) {
                return AllowFirewallPolicy.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(9);
    }

    private static final AllowFirewallPolicy[] VALUES = values();

    public static AllowFirewallPolicy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowFirewallPolicy(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowFirewallPolicy)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowInterconnect}
   */
  public enum AllowInterconnect implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_INTERCONNECT = 0;</code>
     */
    UNDEFINED_ALLOW_INTERCONNECT(0),
    /** <code>INTERCONNECT_ALLOWED = 162845399;</code> */
    INTERCONNECT_ALLOWED(162845399),
    /** <code>INTERCONNECT_BLOCKED = 515879707;</code> */
    INTERCONNECT_BLOCKED(515879707),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_INTERCONNECT = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_INTERCONNECT_VALUE = 0;

    /** <code>INTERCONNECT_ALLOWED = 162845399;</code> */
    public static final int INTERCONNECT_ALLOWED_VALUE = 162845399;

    /** <code>INTERCONNECT_BLOCKED = 515879707;</code> */
    public static final int INTERCONNECT_BLOCKED_VALUE = 515879707;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowInterconnect valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowInterconnect forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_INTERCONNECT;
        case 162845399:
          return INTERCONNECT_ALLOWED;
        case 515879707:
          return INTERCONNECT_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowInterconnect>() {
              public AllowInterconnect findValueByNumber(int number) {
                return AllowInterconnect.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(10);
    }

    private static final AllowInterconnect[] VALUES = values();

    public static AllowInterconnect valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowInterconnect(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowInterconnect)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether IP forwarding is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowIpForwarding}
   */
  public enum AllowIpForwarding implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_IP_FORWARDING = 0;</code>
     */
    UNDEFINED_ALLOW_IP_FORWARDING(0),
    /** <code>IP_FORWARDING_ALLOWED = 152595550;</code> */
    IP_FORWARDING_ALLOWED(152595550),
    /** <code>IP_FORWARDING_BLOCKED = 505629858;</code> */
    IP_FORWARDING_BLOCKED(505629858),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_IP_FORWARDING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_IP_FORWARDING_VALUE = 0;

    /** <code>IP_FORWARDING_ALLOWED = 152595550;</code> */
    public static final int IP_FORWARDING_ALLOWED_VALUE = 152595550;

    /** <code>IP_FORWARDING_BLOCKED = 505629858;</code> */
    public static final int IP_FORWARDING_BLOCKED_VALUE = 505629858;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowIpForwarding valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowIpForwarding forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_IP_FORWARDING;
        case 152595550:
          return IP_FORWARDING_ALLOWED;
        case 505629858:
          return IP_FORWARDING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowIpForwarding>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowIpForwarding>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowIpForwarding>() {
              public AllowIpForwarding findValueByNumber(int number) {
                return AllowIpForwarding.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(11);
    }

    private static final AllowIpForwarding[] VALUES = values();

    public static AllowIpForwarding valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowIpForwarding(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowIpForwarding)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowLoadBalancing}
   */
  public enum AllowLoadBalancing implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_LOAD_BALANCING = 0;</code>
     */
    UNDEFINED_ALLOW_LOAD_BALANCING(0),
    /** <code>LOAD_BALANCING_ALLOWED = 28407977;</code> */
    LOAD_BALANCING_ALLOWED(28407977),
    /** <code>LOAD_BALANCING_BLOCKED = 381442285;</code> */
    LOAD_BALANCING_BLOCKED(381442285),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_LOAD_BALANCING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_LOAD_BALANCING_VALUE = 0;

    /** <code>LOAD_BALANCING_ALLOWED = 28407977;</code> */
    public static final int LOAD_BALANCING_ALLOWED_VALUE = 28407977;

    /** <code>LOAD_BALANCING_BLOCKED = 381442285;</code> */
    public static final int LOAD_BALANCING_BLOCKED_VALUE = 381442285;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowLoadBalancing valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowLoadBalancing forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_LOAD_BALANCING;
        case 28407977:
          return LOAD_BALANCING_ALLOWED;
        case 381442285:
          return LOAD_BALANCING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowLoadBalancing>() {
              public AllowLoadBalancing findValueByNumber(int number) {
                return AllowLoadBalancing.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(12);
    }

    private static final AllowLoadBalancing[] VALUES = values();

    public static AllowLoadBalancing valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowLoadBalancing(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowLoadBalancing)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameNetwork}
   */
  public enum AllowMultiNicInSameNetwork implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK = 0;</code>
     */
    UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK(0),
    /** <code>MULTI_NIC_IN_SAME_NETWORK_ALLOWED = 457555419;</code> */
    MULTI_NIC_IN_SAME_NETWORK_ALLOWED(457555419),
    /** <code>MULTI_NIC_IN_SAME_NETWORK_BLOCKED = 273718815;</code> */
    MULTI_NIC_IN_SAME_NETWORK_BLOCKED(273718815),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK_VALUE = 0;

    /** <code>MULTI_NIC_IN_SAME_NETWORK_ALLOWED = 457555419;</code> */
    public static final int MULTI_NIC_IN_SAME_NETWORK_ALLOWED_VALUE = 457555419;

    /** <code>MULTI_NIC_IN_SAME_NETWORK_BLOCKED = 273718815;</code> */
    public static final int MULTI_NIC_IN_SAME_NETWORK_BLOCKED_VALUE = 273718815;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowMultiNicInSameNetwork valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowMultiNicInSameNetwork forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_NETWORK;
        case 457555419:
          return MULTI_NIC_IN_SAME_NETWORK_ALLOWED;
        case 273718815:
          return MULTI_NIC_IN_SAME_NETWORK_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameNetwork>() {
              public AllowMultiNicInSameNetwork findValueByNumber(int number) {
                return AllowMultiNicInSameNetwork.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(13);
    }

    private static final AllowMultiNicInSameNetwork[] VALUES = values();

    public static AllowMultiNicInSameNetwork valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowMultiNicInSameNetwork(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameNetwork)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same subnetwork is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameSubnetwork}
   */
  public enum AllowMultiNicInSameSubnetwork implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK = 0;</code>
     */
    UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK(0),
    /** <code>MULTI_NIC_IN_SAME_SUBNETWORK_ALLOWED = 288044595;</code> */
    MULTI_NIC_IN_SAME_SUBNETWORK_ALLOWED(288044595),
    /** <code>MULTI_NIC_IN_SAME_SUBNETWORK_BLOCKED = 104207991;</code> */
    MULTI_NIC_IN_SAME_SUBNETWORK_BLOCKED(104207991),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK_VALUE = 0;

    /** <code>MULTI_NIC_IN_SAME_SUBNETWORK_ALLOWED = 288044595;</code> */
    public static final int MULTI_NIC_IN_SAME_SUBNETWORK_ALLOWED_VALUE = 288044595;

    /** <code>MULTI_NIC_IN_SAME_SUBNETWORK_BLOCKED = 104207991;</code> */
    public static final int MULTI_NIC_IN_SAME_SUBNETWORK_BLOCKED_VALUE = 104207991;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowMultiNicInSameSubnetwork valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowMultiNicInSameSubnetwork forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK;
        case 288044595:
          return MULTI_NIC_IN_SAME_SUBNETWORK_ALLOWED;
        case 104207991:
          return MULTI_NIC_IN_SAME_SUBNETWORK_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameSubnetwork>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameSubnetwork>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowMultiNicInSameSubnetwork>() {
              public AllowMultiNicInSameSubnetwork findValueByNumber(int number) {
                return AllowMultiNicInSameSubnetwork.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(14);
    }

    private static final AllowMultiNicInSameSubnetwork[] VALUES = values();

    public static AllowMultiNicInSameSubnetwork valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowMultiNicInSameSubnetwork(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMultiNicInSameSubnetwork)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multicast is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMulticast}
   */
  public enum AllowMulticast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTICAST = 0;</code>
     */
    UNDEFINED_ALLOW_MULTICAST(0),
    /** <code>MULTICAST_ALLOWED = 44693537;</code> */
    MULTICAST_ALLOWED(44693537),
    /** <code>MULTICAST_BLOCKED = 397727845;</code> */
    MULTICAST_BLOCKED(397727845),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_MULTICAST = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_MULTICAST_VALUE = 0;

    /** <code>MULTICAST_ALLOWED = 44693537;</code> */
    public static final int MULTICAST_ALLOWED_VALUE = 44693537;

    /** <code>MULTICAST_BLOCKED = 397727845;</code> */
    public static final int MULTICAST_BLOCKED_VALUE = 397727845;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowMulticast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowMulticast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_MULTICAST;
        case 44693537:
          return MULTICAST_ALLOWED;
        case 397727845:
          return MULTICAST_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowMulticast> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowMulticast> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowMulticast>() {
          public AllowMulticast findValueByNumber(int number) {
            return AllowMulticast.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(15);
    }

    private static final AllowMulticast[] VALUES = values();

    public static AllowMulticast valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowMulticast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowMulticast)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether NCC is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowNcc}
   */
  public enum AllowNcc implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_NCC = 0;</code>
     */
    UNDEFINED_ALLOW_NCC(0),
    /** <code>NCC_ALLOWED = 467227511;</code> */
    NCC_ALLOWED(467227511),
    /** <code>NCC_BLOCKED = 283390907;</code> */
    NCC_BLOCKED(283390907),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_NCC = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_NCC_VALUE = 0;

    /** <code>NCC_ALLOWED = 467227511;</code> */
    public static final int NCC_ALLOWED_VALUE = 467227511;

    /** <code>NCC_BLOCKED = 283390907;</code> */
    public static final int NCC_BLOCKED_VALUE = 283390907;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowNcc valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowNcc forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_NCC;
        case 467227511:
          return NCC_ALLOWED;
        case 283390907:
          return NCC_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowNcc> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowNcc> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowNcc>() {
          public AllowNcc findValueByNumber(int number) {
            return AllowNcc.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(16);
    }

    private static final AllowNcc[] VALUES = values();

    public static AllowNcc valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowNcc(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowNcc)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VM network migration is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowNetworkMigration}
   */
  public enum AllowNetworkMigration implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_NETWORK_MIGRATION = 0;</code>
     */
    UNDEFINED_ALLOW_NETWORK_MIGRATION(0),
    /** <code>NETWORK_MIGRATION_ALLOWED = 14389766;</code> */
    NETWORK_MIGRATION_ALLOWED(14389766),
    /** <code>NETWORK_MIGRATION_BLOCKED = 367424074;</code> */
    NETWORK_MIGRATION_BLOCKED(367424074),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_NETWORK_MIGRATION = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_NETWORK_MIGRATION_VALUE = 0;

    /** <code>NETWORK_MIGRATION_ALLOWED = 14389766;</code> */
    public static final int NETWORK_MIGRATION_ALLOWED_VALUE = 14389766;

    /** <code>NETWORK_MIGRATION_BLOCKED = 367424074;</code> */
    public static final int NETWORK_MIGRATION_BLOCKED_VALUE = 367424074;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowNetworkMigration valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowNetworkMigration forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_NETWORK_MIGRATION;
        case 14389766:
          return NETWORK_MIGRATION_ALLOWED;
        case 367424074:
          return NETWORK_MIGRATION_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowNetworkMigration>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowNetworkMigration>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowNetworkMigration>() {
              public AllowNetworkMigration findValueByNumber(int number) {
                return AllowNetworkMigration.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(17);
    }

    private static final AllowNetworkMigration[] VALUES = values();

    public static AllowNetworkMigration valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowNetworkMigration(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowNetworkMigration)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPacketMirroring}
   */
  public enum AllowPacketMirroring implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PACKET_MIRRORING = 0;</code>
     */
    UNDEFINED_ALLOW_PACKET_MIRRORING(0),
    /** <code>PACKET_MIRRORING_ALLOWED = 92416245;</code> */
    PACKET_MIRRORING_ALLOWED(92416245),
    /** <code>PACKET_MIRRORING_BLOCKED = 445450553;</code> */
    PACKET_MIRRORING_BLOCKED(445450553),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PACKET_MIRRORING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PACKET_MIRRORING_VALUE = 0;

    /** <code>PACKET_MIRRORING_ALLOWED = 92416245;</code> */
    public static final int PACKET_MIRRORING_ALLOWED_VALUE = 92416245;

    /** <code>PACKET_MIRRORING_BLOCKED = 445450553;</code> */
    public static final int PACKET_MIRRORING_BLOCKED_VALUE = 445450553;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPacketMirroring valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPacketMirroring forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PACKET_MIRRORING;
        case 92416245:
          return PACKET_MIRRORING_ALLOWED;
        case 445450553:
          return PACKET_MIRRORING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowPacketMirroring>() {
              public AllowPacketMirroring findValueByNumber(int number) {
                return AllowPacketMirroring.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(18);
    }

    private static final AllowPacketMirroring[] VALUES = values();

    public static AllowPacketMirroring valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPacketMirroring(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPacketMirroring)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPrivateGoogleAccess}
   */
  public enum AllowPrivateGoogleAccess implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS = 0;</code>
     */
    UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS(0),
    /** <code>PRIVATE_GOOGLE_ACCESS_ALLOWED = 220787351;</code> */
    PRIVATE_GOOGLE_ACCESS_ALLOWED(220787351),
    /** <code>PRIVATE_GOOGLE_ACCESS_BLOCKED = 36950747;</code> */
    PRIVATE_GOOGLE_ACCESS_BLOCKED(36950747),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS_VALUE = 0;

    /** <code>PRIVATE_GOOGLE_ACCESS_ALLOWED = 220787351;</code> */
    public static final int PRIVATE_GOOGLE_ACCESS_ALLOWED_VALUE = 220787351;

    /** <code>PRIVATE_GOOGLE_ACCESS_BLOCKED = 36950747;</code> */
    public static final int PRIVATE_GOOGLE_ACCESS_BLOCKED_VALUE = 36950747;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPrivateGoogleAccess valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPrivateGoogleAccess forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PRIVATE_GOOGLE_ACCESS;
        case 220787351:
          return PRIVATE_GOOGLE_ACCESS_ALLOWED;
        case 36950747:
          return PRIVATE_GOOGLE_ACCESS_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowPrivateGoogleAccess>() {
              public AllowPrivateGoogleAccess findValueByNumber(int number) {
                return AllowPrivateGoogleAccess.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(19);
    }

    private static final AllowPrivateGoogleAccess[] VALUES = values();

    public static AllowPrivateGoogleAccess valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPrivateGoogleAccess(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPrivateGoogleAccess)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPsc}
   */
  public enum AllowPsc implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PSC = 0;</code>
     */
    UNDEFINED_ALLOW_PSC(0),
    /** <code>PSC_ALLOWED = 171559657;</code> */
    PSC_ALLOWED(171559657),
    /** <code>PSC_BLOCKED = 524593965;</code> */
    PSC_BLOCKED(524593965),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_PSC = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_PSC_VALUE = 0;

    /** <code>PSC_ALLOWED = 171559657;</code> */
    public static final int PSC_ALLOWED_VALUE = 171559657;

    /** <code>PSC_BLOCKED = 524593965;</code> */
    public static final int PSC_BLOCKED_VALUE = 524593965;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowPsc valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowPsc forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_PSC;
        case 171559657:
          return PSC_ALLOWED;
        case 524593965:
          return PSC_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowPsc> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowPsc> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowPsc>() {
          public AllowPsc findValueByNumber(int number) {
            return AllowPsc.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(20);
    }

    private static final AllowPsc[] VALUES = values();

    public static AllowPsc valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowPsc(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowPsc)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSameNetworkUnicast}
   */
  public enum AllowSameNetworkUnicast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SAME_NETWORK_UNICAST = 0;</code>
     */
    UNDEFINED_ALLOW_SAME_NETWORK_UNICAST(0),
    /** <code>SAME_NETWORK_UNICAST_ALLOWED = 159732814;</code> */
    SAME_NETWORK_UNICAST_ALLOWED(159732814),
    /** <code>SAME_NETWORK_UNICAST_BLOCKED = 512767122;</code> */
    SAME_NETWORK_UNICAST_BLOCKED(512767122),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SAME_NETWORK_UNICAST = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_SAME_NETWORK_UNICAST_VALUE = 0;

    /** <code>SAME_NETWORK_UNICAST_ALLOWED = 159732814;</code> */
    public static final int SAME_NETWORK_UNICAST_ALLOWED_VALUE = 159732814;

    /** <code>SAME_NETWORK_UNICAST_BLOCKED = 512767122;</code> */
    public static final int SAME_NETWORK_UNICAST_BLOCKED_VALUE = 512767122;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowSameNetworkUnicast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowSameNetworkUnicast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_SAME_NETWORK_UNICAST;
        case 159732814:
          return SAME_NETWORK_UNICAST_ALLOWED;
        case 512767122:
          return SAME_NETWORK_UNICAST_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowSameNetworkUnicast>() {
              public AllowSameNetworkUnicast findValueByNumber(int number) {
                return AllowSameNetworkUnicast.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(21);
    }

    private static final AllowSameNetworkUnicast[] VALUES = values();

    public static AllowSameNetworkUnicast valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowSameNetworkUnicast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSameNetworkUnicast)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowStaticRoutes}
   */
  public enum AllowStaticRoutes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_STATIC_ROUTES = 0;</code>
     */
    UNDEFINED_ALLOW_STATIC_ROUTES(0),
    /** <code>STATIC_ROUTES_ALLOWED = 409048964;</code> */
    STATIC_ROUTES_ALLOWED(409048964),
    /** <code>STATIC_ROUTES_BLOCKED = 225212360;</code> */
    STATIC_ROUTES_BLOCKED(225212360),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_STATIC_ROUTES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_STATIC_ROUTES_VALUE = 0;

    /** <code>STATIC_ROUTES_ALLOWED = 409048964;</code> */
    public static final int STATIC_ROUTES_ALLOWED_VALUE = 409048964;

    /** <code>STATIC_ROUTES_BLOCKED = 225212360;</code> */
    public static final int STATIC_ROUTES_BLOCKED_VALUE = 225212360;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowStaticRoutes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowStaticRoutes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_STATIC_ROUTES;
        case 409048964:
          return STATIC_ROUTES_ALLOWED;
        case 225212360:
          return STATIC_ROUTES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowStaticRoutes>() {
              public AllowStaticRoutes findValueByNumber(int number) {
                return AllowStaticRoutes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(22);
    }

    private static final AllowStaticRoutes[] VALUES = values();

    public static AllowStaticRoutes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowStaticRoutes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowStaticRoutes)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubInterfaces}
   */
  public enum AllowSubInterfaces implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUB_INTERFACES = 0;</code>
     */
    UNDEFINED_ALLOW_SUB_INTERFACES(0),
    /** <code>SUBINTERFACES_ALLOWED = 158685891;</code> */
    SUBINTERFACES_ALLOWED(158685891),
    /** <code>SUBINTERFACES_BLOCKED = 511720199;</code> */
    SUBINTERFACES_BLOCKED(511720199),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUB_INTERFACES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_SUB_INTERFACES_VALUE = 0;

    /** <code>SUBINTERFACES_ALLOWED = 158685891;</code> */
    public static final int SUBINTERFACES_ALLOWED_VALUE = 158685891;

    /** <code>SUBINTERFACES_BLOCKED = 511720199;</code> */
    public static final int SUBINTERFACES_BLOCKED_VALUE = 511720199;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowSubInterfaces valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowSubInterfaces forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_SUB_INTERFACES;
        case 158685891:
          return SUBINTERFACES_ALLOWED;
        case 511720199:
          return SUBINTERFACES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowSubInterfaces>() {
              public AllowSubInterfaces findValueByNumber(int number) {
                return AllowSubInterfaces.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(23);
    }

    private static final AllowSubInterfaces[] VALUES = values();

    public static AllowSubInterfaces valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowSubInterfaces(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubInterfaces)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether subnetwork creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubnetworkCreation}
   */
  public enum AllowSubnetworkCreation implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUBNETWORK_CREATION = 0;</code>
     */
    UNDEFINED_ALLOW_SUBNETWORK_CREATION(0),
    /** <code>SUBNETWORK_CREATION_ALLOWED = 158580825;</code> */
    SUBNETWORK_CREATION_ALLOWED(158580825),
    /** <code>SUBNETWORK_CREATION_BLOCKED = 511615133;</code> */
    SUBNETWORK_CREATION_BLOCKED(511615133),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_SUBNETWORK_CREATION = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_SUBNETWORK_CREATION_VALUE = 0;

    /** <code>SUBNETWORK_CREATION_ALLOWED = 158580825;</code> */
    public static final int SUBNETWORK_CREATION_ALLOWED_VALUE = 158580825;

    /** <code>SUBNETWORK_CREATION_BLOCKED = 511615133;</code> */
    public static final int SUBNETWORK_CREATION_BLOCKED_VALUE = 511615133;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowSubnetworkCreation valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowSubnetworkCreation forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_SUBNETWORK_CREATION;
        case 158580825:
          return SUBNETWORK_CREATION_ALLOWED;
        case 511615133:
          return SUBNETWORK_CREATION_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowSubnetworkCreation>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowSubnetworkCreation>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowSubnetworkCreation>() {
              public AllowSubnetworkCreation findValueByNumber(int number) {
                return AllowSubnetworkCreation.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(24);
    }

    private static final AllowSubnetworkCreation[] VALUES = values();

    public static AllowSubnetworkCreation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowSubnetworkCreation(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowSubnetworkCreation)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC firewall rules can be created under the network.
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcFirewallRules}
   */
  public enum AllowVpcFirewallRules implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_FIREWALL_RULES = 0;</code>
     */
    UNDEFINED_ALLOW_VPC_FIREWALL_RULES(0),
    /** <code>VPC_FIREWALL_RULES_ALLOWED = 489586007;</code> */
    VPC_FIREWALL_RULES_ALLOWED(489586007),
    /** <code>VPC_FIREWALL_RULES_BLOCKED = 305749403;</code> */
    VPC_FIREWALL_RULES_BLOCKED(305749403),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_FIREWALL_RULES = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_VPC_FIREWALL_RULES_VALUE = 0;

    /** <code>VPC_FIREWALL_RULES_ALLOWED = 489586007;</code> */
    public static final int VPC_FIREWALL_RULES_ALLOWED_VALUE = 489586007;

    /** <code>VPC_FIREWALL_RULES_BLOCKED = 305749403;</code> */
    public static final int VPC_FIREWALL_RULES_BLOCKED_VALUE = 305749403;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowVpcFirewallRules valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowVpcFirewallRules forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_VPC_FIREWALL_RULES;
        case 489586007:
          return VPC_FIREWALL_RULES_ALLOWED;
        case 305749403:
          return VPC_FIREWALL_RULES_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowVpcFirewallRules>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowVpcFirewallRules>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowVpcFirewallRules>() {
              public AllowVpcFirewallRules findValueByNumber(int number) {
                return AllowVpcFirewallRules.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(25);
    }

    private static final AllowVpcFirewallRules[] VALUES = values();

    public static AllowVpcFirewallRules valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowVpcFirewallRules(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcFirewallRules)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcPeering}
   */
  public enum AllowVpcPeering implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_PEERING = 0;</code>
     */
    UNDEFINED_ALLOW_VPC_PEERING(0),
    /** <code>VPC_PEERING_ALLOWED = 261465075;</code> */
    VPC_PEERING_ALLOWED(261465075),
    /** <code>VPC_PEERING_BLOCKED = 77628471;</code> */
    VPC_PEERING_BLOCKED(77628471),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPC_PEERING = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_VPC_PEERING_VALUE = 0;

    /** <code>VPC_PEERING_ALLOWED = 261465075;</code> */
    public static final int VPC_PEERING_ALLOWED_VALUE = 261465075;

    /** <code>VPC_PEERING_BLOCKED = 77628471;</code> */
    public static final int VPC_PEERING_BLOCKED_VALUE = 77628471;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowVpcPeering valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowVpcPeering forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_VPC_PEERING;
        case 261465075:
          return VPC_PEERING_ALLOWED;
        case 77628471:
          return VPC_PEERING_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AllowVpcPeering>() {
              public AllowVpcPeering findValueByNumber(int number) {
                return AllowVpcPeering.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(26);
    }

    private static final AllowVpcPeering[] VALUES = values();

    public static AllowVpcPeering valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowVpcPeering(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpcPeering)
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpn}
   */
  public enum AllowVpn implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPN = 0;</code>
     */
    UNDEFINED_ALLOW_VPN(0),
    /** <code>VPN_ALLOWED = 162163997;</code> */
    VPN_ALLOWED(162163997),
    /** <code>VPN_BLOCKED = 515198305;</code> */
    VPN_BLOCKED(515198305),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_ALLOW_VPN = 0;</code>
     */
    public static final int UNDEFINED_ALLOW_VPN_VALUE = 0;

    /** <code>VPN_ALLOWED = 162163997;</code> */
    public static final int VPN_ALLOWED_VALUE = 162163997;

    /** <code>VPN_BLOCKED = 515198305;</code> */
    public static final int VPN_BLOCKED_VALUE = 515198305;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AllowVpn valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AllowVpn forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_ALLOW_VPN;
        case 162163997:
          return VPN_ALLOWED;
        case 515198305:
          return VPN_BLOCKED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AllowVpn> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AllowVpn> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<AllowVpn>() {
          public AllowVpn findValueByNumber(int number) {
            return AllowVpn.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(27);
    }

    private static final AllowVpn[] VALUES = values();

    public static AllowVpn valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AllowVpn(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.AllowVpn)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.FirewallPolicyTypes}
   */
  public enum FirewallPolicyTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_FIREWALL_POLICY_TYPES = 0;</code>
     */
    UNDEFINED_FIREWALL_POLICY_TYPES(0),
    /** <code>RDMA_ROCE_POLICY = 148757145;</code> */
    RDMA_ROCE_POLICY(148757145),
    /** <code>VPC_POLICY = 74319208;</code> */
    VPC_POLICY(74319208),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_FIREWALL_POLICY_TYPES = 0;</code>
     */
    public static final int UNDEFINED_FIREWALL_POLICY_TYPES_VALUE = 0;

    /** <code>RDMA_ROCE_POLICY = 148757145;</code> */
    public static final int RDMA_ROCE_POLICY_VALUE = 148757145;

    /** <code>VPC_POLICY = 74319208;</code> */
    public static final int VPC_POLICY_VALUE = 74319208;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static FirewallPolicyTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static FirewallPolicyTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_FIREWALL_POLICY_TYPES;
        case 148757145:
          return RDMA_ROCE_POLICY;
        case 74319208:
          return VPC_POLICY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<FirewallPolicyTypes>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<FirewallPolicyTypes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FirewallPolicyTypes>() {
              public FirewallPolicyTypes findValueByNumber(int number) {
                return FirewallPolicyTypes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(28);
    }

    private static final FirewallPolicyTypes[] VALUES = values();

    public static FirewallPolicyTypes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private FirewallPolicyTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.FirewallPolicyTypes)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.InterfaceTypes}
   */
  public enum InterfaceTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_INTERFACE_TYPES = 0;</code>
     */
    UNDEFINED_INTERFACE_TYPES(0),
    /**
     *
     *
     * <pre>
     * GVNIC
     * </pre>
     *
     * <code>GVNIC = 68209305;</code>
     */
    GVNIC(68209305),
    /**
     *
     *
     * <pre>
     * IDPF
     * </pre>
     *
     * <code>IDPF = 2242641;</code>
     */
    IDPF(2242641),
    /**
     *
     *
     * <pre>
     * IRDMA
     * </pre>
     *
     * <code>IRDMA = 69927695;</code>
     */
    IRDMA(69927695),
    /**
     *
     *
     * <pre>
     * MRDMA
     * </pre>
     *
     * <code>MRDMA = 73621779;</code>
     */
    MRDMA(73621779),
    /**
     *
     *
     * <pre>
     * No type specified.
     * </pre>
     *
     * <code>UNSPECIFIED_NIC_TYPE = 67411801;</code>
     */
    UNSPECIFIED_NIC_TYPE(67411801),
    /**
     *
     *
     * <pre>
     * VIRTIO
     * </pre>
     *
     * <code>VIRTIO_NET = 452123481;</code>
     */
    VIRTIO_NET(452123481),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_INTERFACE_TYPES = 0;</code>
     */
    public static final int UNDEFINED_INTERFACE_TYPES_VALUE = 0;

    /**
     *
     *
     * <pre>
     * GVNIC
     * </pre>
     *
     * <code>GVNIC = 68209305;</code>
     */
    public static final int GVNIC_VALUE = 68209305;

    /**
     *
     *
     * <pre>
     * IDPF
     * </pre>
     *
     * <code>IDPF = 2242641;</code>
     */
    public static final int IDPF_VALUE = 2242641;

    /**
     *
     *
     * <pre>
     * IRDMA
     * </pre>
     *
     * <code>IRDMA = 69927695;</code>
     */
    public static final int IRDMA_VALUE = 69927695;

    /**
     *
     *
     * <pre>
     * MRDMA
     * </pre>
     *
     * <code>MRDMA = 73621779;</code>
     */
    public static final int MRDMA_VALUE = 73621779;

    /**
     *
     *
     * <pre>
     * No type specified.
     * </pre>
     *
     * <code>UNSPECIFIED_NIC_TYPE = 67411801;</code>
     */
    public static final int UNSPECIFIED_NIC_TYPE_VALUE = 67411801;

    /**
     *
     *
     * <pre>
     * VIRTIO
     * </pre>
     *
     * <code>VIRTIO_NET = 452123481;</code>
     */
    public static final int VIRTIO_NET_VALUE = 452123481;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InterfaceTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static InterfaceTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_INTERFACE_TYPES;
        case 68209305:
          return GVNIC;
        case 2242641:
          return IDPF;
        case 69927695:
          return IRDMA;
        case 73621779:
          return MRDMA;
        case 67411801:
          return UNSPECIFIED_NIC_TYPE;
        case 452123481:
          return VIRTIO_NET;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<InterfaceTypes>() {
          public InterfaceTypes findValueByNumber(int number) {
            return InterfaceTypes.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(29);
    }

    private static final InterfaceTypes[] VALUES = values();

    public static InterfaceTypes valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InterfaceTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.InterfaceTypes)
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of multicast is supported.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.Multicast}
   */
  public enum Multicast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_MULTICAST = 0;</code>
     */
    UNDEFINED_MULTICAST(0),
    /** <code>MULTICAST_SDN = 532209462;</code> */
    MULTICAST_SDN(532209462),
    /** <code>MULTICAST_ULL = 532211630;</code> */
    MULTICAST_ULL(532211630),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_MULTICAST = 0;</code>
     */
    public static final int UNDEFINED_MULTICAST_VALUE = 0;

    /** <code>MULTICAST_SDN = 532209462;</code> */
    public static final int MULTICAST_SDN_VALUE = 532209462;

    /** <code>MULTICAST_ULL = 532211630;</code> */
    public static final int MULTICAST_ULL_VALUE = 532211630;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Multicast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Multicast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_MULTICAST;
        case 532209462:
          return MULTICAST_SDN;
        case 532211630:
          return MULTICAST_ULL;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Multicast> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Multicast> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Multicast>() {
          public Multicast findValueByNumber(int number) {
            return Multicast.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(30);
    }

    private static final Multicast[] VALUES = values();

    public static Multicast valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Multicast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.Multicast)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetPurposes}
   */
  public enum SubnetPurposes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_PURPOSES = 0;</code>
     */
    UNDEFINED_SUBNET_PURPOSES(0),
    /** <code>SUBNET_PURPOSE_CUSTOM_HARDWARE = 283160275;</code> */
    SUBNET_PURPOSE_CUSTOM_HARDWARE(283160275),
    /** <code>SUBNET_PURPOSE_PRIVATE = 404371008;</code> */
    SUBNET_PURPOSE_PRIVATE(404371008),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_PURPOSES = 0;</code>
     */
    public static final int UNDEFINED_SUBNET_PURPOSES_VALUE = 0;

    /** <code>SUBNET_PURPOSE_CUSTOM_HARDWARE = 283160275;</code> */
    public static final int SUBNET_PURPOSE_CUSTOM_HARDWARE_VALUE = 283160275;

    /** <code>SUBNET_PURPOSE_PRIVATE = 404371008;</code> */
    public static final int SUBNET_PURPOSE_PRIVATE_VALUE = 404371008;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetPurposes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetPurposes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNET_PURPOSES;
        case 283160275:
          return SUBNET_PURPOSE_CUSTOM_HARDWARE;
        case 404371008:
          return SUBNET_PURPOSE_PRIVATE;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<SubnetPurposes>() {
          public SubnetPurposes findValueByNumber(int number) {
            return SubnetPurposes.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(31);
    }

    private static final SubnetPurposes[] VALUES = values();

    public static SubnetPurposes valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetPurposes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetPurposes)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetStackTypes}
   */
  public enum SubnetStackTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_STACK_TYPES = 0;</code>
     */
    UNDEFINED_SUBNET_STACK_TYPES(0),
    /** <code>SUBNET_STACK_TYPE_IPV4_IPV6 = 41454485;</code> */
    SUBNET_STACK_TYPE_IPV4_IPV6(41454485),
    /** <code>SUBNET_STACK_TYPE_IPV4_ONLY = 41631034;</code> */
    SUBNET_STACK_TYPE_IPV4_ONLY(41631034),
    /** <code>SUBNET_STACK_TYPE_IPV6_ONLY = 98889336;</code> */
    SUBNET_STACK_TYPE_IPV6_ONLY(98889336),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNET_STACK_TYPES = 0;</code>
     */
    public static final int UNDEFINED_SUBNET_STACK_TYPES_VALUE = 0;

    /** <code>SUBNET_STACK_TYPE_IPV4_IPV6 = 41454485;</code> */
    public static final int SUBNET_STACK_TYPE_IPV4_IPV6_VALUE = 41454485;

    /** <code>SUBNET_STACK_TYPE_IPV4_ONLY = 41631034;</code> */
    public static final int SUBNET_STACK_TYPE_IPV4_ONLY_VALUE = 41631034;

    /** <code>SUBNET_STACK_TYPE_IPV6_ONLY = 98889336;</code> */
    public static final int SUBNET_STACK_TYPE_IPV6_ONLY_VALUE = 98889336;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetStackTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetStackTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNET_STACK_TYPES;
        case 41454485:
          return SUBNET_STACK_TYPE_IPV4_IPV6;
        case 41631034:
          return SUBNET_STACK_TYPE_IPV4_ONLY;
        case 98889336:
          return SUBNET_STACK_TYPE_IPV6_ONLY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SubnetStackTypes>() {
              public SubnetStackTypes findValueByNumber(int number) {
                return SubnetStackTypes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(32);
    }

    private static final SubnetStackTypes[] VALUES = values();

    public static SubnetStackTypes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetStackTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetStackTypes)
  }

  /**
   *
   *
   * <pre>
   *
   * Additional supported values which may be not listed in the enum directly due to technical reasons:
   * PRIVATE_SERVICE_CONNECT
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetworkPurposes}
   */
  public enum SubnetworkPurposes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNETWORK_PURPOSES = 0;</code>
     */
    UNDEFINED_SUBNETWORK_PURPOSES(0),
    /**
     *
     *
     * <pre>
     * Subnet reserved for Global Envoy-based Load Balancing.
     * </pre>
     *
     * <code>GLOBAL_MANAGED_PROXY = 236463602;</code>
     */
    GLOBAL_MANAGED_PROXY(236463602),
    /**
     *
     *
     * <pre>
     * Subnet reserved for Internal HTTP(S) Load Balancing. This is a legacy
     * purpose, please use REGIONAL_MANAGED_PROXY instead.
     * </pre>
     *
     * <code>INTERNAL_HTTPS_LOAD_BALANCER = 248748889;</code>
     */
    INTERNAL_HTTPS_LOAD_BALANCER(248748889),
    /**
     *
     *
     * <pre>
     * Subnetwork will be used for Migration from one peered VPC to another.
     * (a transient state of subnetwork
     * while migrating resources from one project to another).
     * </pre>
     *
     * <code>PEER_MIGRATION = 491902225;</code>
     */
    PEER_MIGRATION(491902225),
    /**
     *
     *
     * <pre>
     * Regular user created or automatically created subnet.
     * </pre>
     *
     * <code>PRIVATE = 403485027;</code>
     */
    PRIVATE(403485027),
    /**
     *
     *
     * <pre>
     * Subnetwork used as source range for Private NAT Gateways.
     * </pre>
     *
     * <code>PRIVATE_NAT = 367764517;</code>
     */
    PRIVATE_NAT(367764517),
    /**
     *
     *
     * <pre>
     * Regular user created or automatically created subnet.
     * </pre>
     *
     * <code>PRIVATE_RFC_1918 = 254902107;</code>
     */
    PRIVATE_RFC_1918(254902107),
    /**
     *
     *
     * <pre>
     * Subnetwork used for Regional Envoy-based Load Balancing.
     * </pre>
     *
     * <code>REGIONAL_MANAGED_PROXY = 153049966;</code>
     */
    REGIONAL_MANAGED_PROXY(153049966),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNETWORK_PURPOSES = 0;</code>
     */
    public static final int UNDEFINED_SUBNETWORK_PURPOSES_VALUE = 0;

    /**
     *
     *
     * <pre>
     * Subnet reserved for Global Envoy-based Load Balancing.
     * </pre>
     *
     * <code>GLOBAL_MANAGED_PROXY = 236463602;</code>
     */
    public static final int GLOBAL_MANAGED_PROXY_VALUE = 236463602;

    /**
     *
     *
     * <pre>
     * Subnet reserved for Internal HTTP(S) Load Balancing. This is a legacy
     * purpose, please use REGIONAL_MANAGED_PROXY instead.
     * </pre>
     *
     * <code>INTERNAL_HTTPS_LOAD_BALANCER = 248748889;</code>
     */
    public static final int INTERNAL_HTTPS_LOAD_BALANCER_VALUE = 248748889;

    /**
     *
     *
     * <pre>
     * Subnetwork will be used for Migration from one peered VPC to another.
     * (a transient state of subnetwork
     * while migrating resources from one project to another).
     * </pre>
     *
     * <code>PEER_MIGRATION = 491902225;</code>
     */
    public static final int PEER_MIGRATION_VALUE = 491902225;

    /**
     *
     *
     * <pre>
     * Regular user created or automatically created subnet.
     * </pre>
     *
     * <code>PRIVATE = 403485027;</code>
     */
    public static final int PRIVATE_VALUE = 403485027;

    /**
     *
     *
     * <pre>
     * Subnetwork used as source range for Private NAT Gateways.
     * </pre>
     *
     * <code>PRIVATE_NAT = 367764517;</code>
     */
    public static final int PRIVATE_NAT_VALUE = 367764517;

    /**
     *
     *
     * <pre>
     * Regular user created or automatically created subnet.
     * </pre>
     *
     * <code>PRIVATE_RFC_1918 = 254902107;</code>
     */
    public static final int PRIVATE_RFC_1918_VALUE = 254902107;

    /**
     *
     *
     * <pre>
     * Subnetwork used for Regional Envoy-based Load Balancing.
     * </pre>
     *
     * <code>REGIONAL_MANAGED_PROXY = 153049966;</code>
     */
    public static final int REGIONAL_MANAGED_PROXY_VALUE = 153049966;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetworkPurposes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetworkPurposes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNETWORK_PURPOSES;
        case 236463602:
          return GLOBAL_MANAGED_PROXY;
        case 248748889:
          return INTERNAL_HTTPS_LOAD_BALANCER;
        case 491902225:
          return PEER_MIGRATION;
        case 403485027:
          return PRIVATE;
        case 367764517:
          return PRIVATE_NAT;
        case 254902107:
          return PRIVATE_RFC_1918;
        case 153049966:
          return REGIONAL_MANAGED_PROXY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetworkPurposes>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetworkPurposes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SubnetworkPurposes>() {
              public SubnetworkPurposes findValueByNumber(int number) {
                return SubnetworkPurposes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(33);
    }

    private static final SubnetworkPurposes[] VALUES = values();

    public static SubnetworkPurposes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetworkPurposes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetworkPurposes)
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf enum {@code
   * google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetworkStackTypes}
   */
  public enum SubnetworkStackTypes implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNETWORK_STACK_TYPES = 0;</code>
     */
    UNDEFINED_SUBNETWORK_STACK_TYPES(0),
    /**
     *
     *
     * <pre>
     * New VMs in this subnet can have both IPv4 and IPv6 addresses.
     * </pre>
     *
     * <code>IPV4_IPV6 = 22197249;</code>
     */
    IPV4_IPV6(22197249),
    /**
     *
     *
     * <pre>
     * New VMs in this subnet will only be assigned IPv4 addresses.
     * </pre>
     *
     * <code>IPV4_ONLY = 22373798;</code>
     */
    IPV4_ONLY(22373798),
    /**
     *
     *
     * <pre>
     * New VMs in this subnet will only  be assigned IPv6 addresses.
     * </pre>
     *
     * <code>IPV6_ONLY = 79632100;</code>
     */
    IPV6_ONLY(79632100),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_SUBNETWORK_STACK_TYPES = 0;</code>
     */
    public static final int UNDEFINED_SUBNETWORK_STACK_TYPES_VALUE = 0;

    /**
     *
     *
     * <pre>
     * New VMs in this subnet can have both IPv4 and IPv6 addresses.
     * </pre>
     *
     * <code>IPV4_IPV6 = 22197249;</code>
     */
    public static final int IPV4_IPV6_VALUE = 22197249;

    /**
     *
     *
     * <pre>
     * New VMs in this subnet will only be assigned IPv4 addresses.
     * </pre>
     *
     * <code>IPV4_ONLY = 22373798;</code>
     */
    public static final int IPV4_ONLY_VALUE = 22373798;

    /**
     *
     *
     * <pre>
     * New VMs in this subnet will only  be assigned IPv6 addresses.
     * </pre>
     *
     * <code>IPV6_ONLY = 79632100;</code>
     */
    public static final int IPV6_ONLY_VALUE = 79632100;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SubnetworkStackTypes valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SubnetworkStackTypes forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_SUBNETWORK_STACK_TYPES;
        case 22197249:
          return IPV4_IPV6;
        case 22373798:
          return IPV4_ONLY;
        case 79632100:
          return IPV6_ONLY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SubnetworkStackTypes>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<SubnetworkStackTypes>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SubnetworkStackTypes>() {
              public SubnetworkStackTypes findValueByNumber(int number) {
                return SubnetworkStackTypes.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(34);
    }

    private static final SubnetworkStackTypes[] VALUES = values();

    public static SubnetworkStackTypes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SubnetworkStackTypes(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.SubnetworkStackTypes)
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures.Unicast}
   */
  public enum Unicast implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_UNICAST = 0;</code>
     */
    UNDEFINED_UNICAST(0),
    /** <code>UNICAST_SDN = 379954157;</code> */
    UNICAST_SDN(379954157),
    /** <code>UNICAST_ULL = 379956325;</code> */
    UNICAST_ULL(379956325),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_UNICAST = 0;</code>
     */
    public static final int UNDEFINED_UNICAST_VALUE = 0;

    /** <code>UNICAST_SDN = 379954157;</code> */
    public static final int UNICAST_SDN_VALUE = 379954157;

    /** <code>UNICAST_ULL = 379956325;</code> */
    public static final int UNICAST_ULL_VALUE = 379956325;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Unicast valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Unicast forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_UNICAST;
        case 379954157:
          return UNICAST_SDN;
        case 379956325:
          return UNICAST_ULL;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Unicast> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<Unicast> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<Unicast>() {
          public Unicast findValueByNumber(int number) {
            return Unicast.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDescriptor()
          .getEnumTypes()
          .get(35);
    }

    private static final Unicast[] VALUES = values();

    public static Unicast valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Unicast(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures.Unicast)
  }

  private int bitField0_;
  public static final int ADDRESS_PURPOSES_FIELD_NUMBER = 433024768;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList addressPurposes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address
   * purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @return A list containing the addressPurposes.
   */
  public com.google.protobuf.ProtocolStringList getAddressPurposesList() {
    return addressPurposes_;
  }

  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address
   * purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @return The count of addressPurposes.
   */
  public int getAddressPurposesCount() {
    return addressPurposes_.size();
  }

  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address
   * purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @param index The index of the element to return.
   * @return The addressPurposes at the given index.
   */
  public java.lang.String getAddressPurposes(int index) {
    return addressPurposes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Specifies what address purposes are supported. If empty, all address
   * purposes are supported.
   * Check the AddressPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string address_purposes = 433024768;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the addressPurposes at the given index.
   */
  public com.google.protobuf.ByteString getAddressPurposesBytes(int index) {
    return addressPurposes_.getByteString(index);
  }

  public static final int ALLOW_ADDRESS_CREATION_FIELD_NUMBER = 450941184;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowAddressCreation_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether address creation is allowed.
   * Check the AllowAddressCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_address_creation = 450941184;</code>
   *
   * @return Whether the allowAddressCreation field is set.
   */
  @java.lang.Override
  public boolean hasAllowAddressCreation() {
    return ((bitField0_ & 0x00000001) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether address creation is allowed.
   * Check the AllowAddressCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_address_creation = 450941184;</code>
   *
   * @return The allowAddressCreation.
   */
  @java.lang.Override
  public java.lang.String getAllowAddressCreation() {
    java.lang.Object ref = allowAddressCreation_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowAddressCreation_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether address creation is allowed.
   * Check the AllowAddressCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_address_creation = 450941184;</code>
   *
   * @return The bytes for allowAddressCreation.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowAddressCreationBytes() {
    java.lang.Object ref = allowAddressCreation_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowAddressCreation_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_ALIAS_IP_RANGES_FIELD_NUMBER = 457984201;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowAliasIpRanges_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are
   * allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return Whether the allowAliasIpRanges field is set.
   */
  @java.lang.Override
  public boolean hasAllowAliasIpRanges() {
    return ((bitField0_ & 0x00000002) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are
   * allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return The allowAliasIpRanges.
   */
  @java.lang.Override
  public java.lang.String getAllowAliasIpRanges() {
    java.lang.Object ref = allowAliasIpRanges_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowAliasIpRanges_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether alias IP ranges (and secondary address ranges) are
   * allowed.
   * Check the AllowAliasIpRanges enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_alias_ip_ranges = 457984201;</code>
   *
   * @return The bytes for allowAliasIpRanges.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowAliasIpRangesBytes() {
    java.lang.Object ref = allowAliasIpRanges_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowAliasIpRanges_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_AUTO_MODE_SUBNET_FIELD_NUMBER = 152191263;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowAutoModeSubnet_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return Whether the allowAutoModeSubnet field is set.
   */
  @java.lang.Override
  public boolean hasAllowAutoModeSubnet() {
    return ((bitField0_ & 0x00000004) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return The allowAutoModeSubnet.
   */
  @java.lang.Override
  public java.lang.String getAllowAutoModeSubnet() {
    java.lang.Object ref = allowAutoModeSubnet_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowAutoModeSubnet_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether auto mode subnet creation is allowed.
   * Check the AllowAutoModeSubnet enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_auto_mode_subnet = 152191263;</code>
   *
   * @return The bytes for allowAutoModeSubnet.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowAutoModeSubnetBytes() {
    java.lang.Object ref = allowAutoModeSubnet_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowAutoModeSubnet_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLASS_D_FIREWALLS_FIELD_NUMBER = 131608987;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowClassDFirewalls_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return Whether the allowClassDFirewalls field is set.
   */
  @java.lang.Override
  public boolean hasAllowClassDFirewalls() {
    return ((bitField0_ & 0x00000008) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return The allowClassDFirewalls.
   */
  @java.lang.Override
  public java.lang.String getAllowClassDFirewalls() {
    java.lang.Object ref = allowClassDFirewalls_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowClassDFirewalls_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewalls for Class D address ranges are supported.
   * Check the AllowClassDFirewalls enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_class_d_firewalls = 131608987;</code>
   *
   * @return The bytes for allowClassDFirewalls.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowClassDFirewallsBytes() {
    java.lang.Object ref = allowClassDFirewalls_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowClassDFirewalls_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLOUD_NAT_FIELD_NUMBER = 254831265;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowCloudNat_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return Whether the allowCloudNat field is set.
   */
  @java.lang.Override
  public boolean hasAllowCloudNat() {
    return ((bitField0_ & 0x00000010) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return The allowCloudNat.
   */
  @java.lang.Override
  public java.lang.String getAllowCloudNat() {
    java.lang.Object ref = allowCloudNat_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowCloudNat_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud NAT creation is allowed.
   * Check the AllowCloudNat enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_nat = 254831265;</code>
   *
   * @return The bytes for allowCloudNat.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowCloudNatBytes() {
    java.lang.Object ref = allowCloudNat_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowCloudNat_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_CLOUD_ROUTER_FIELD_NUMBER = 451110345;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowCloudRouter_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return Whether the allowCloudRouter field is set.
   */
  @java.lang.Override
  public boolean hasAllowCloudRouter() {
    return ((bitField0_ & 0x00000020) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return The allowCloudRouter.
   */
  @java.lang.Override
  public java.lang.String getAllowCloudRouter() {
    java.lang.Object ref = allowCloudRouter_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowCloudRouter_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud router creation is allowed.
   * Check the AllowCloudRouter enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_cloud_router = 451110345;</code>
   *
   * @return The bytes for allowCloudRouter.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowCloudRouterBytes() {
    java.lang.Object ref = allowCloudRouter_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowCloudRouter_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_DEFAULT_NIC_ATTACHMENT_FIELD_NUMBER = 53917486;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowDefaultNicAttachment_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether default NIC attachment is allowed.
   * Check the AllowDefaultNicAttachment enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_default_nic_attachment = 53917486;</code>
   *
   * @return Whether the allowDefaultNicAttachment field is set.
   */
  @java.lang.Override
  public boolean hasAllowDefaultNicAttachment() {
    return ((bitField0_ & 0x00000040) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether default NIC attachment is allowed.
   * Check the AllowDefaultNicAttachment enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_default_nic_attachment = 53917486;</code>
   *
   * @return The allowDefaultNicAttachment.
   */
  @java.lang.Override
  public java.lang.String getAllowDefaultNicAttachment() {
    java.lang.Object ref = allowDefaultNicAttachment_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowDefaultNicAttachment_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether default NIC attachment is allowed.
   * Check the AllowDefaultNicAttachment enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_default_nic_attachment = 53917486;</code>
   *
   * @return The bytes for allowDefaultNicAttachment.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowDefaultNicAttachmentBytes() {
    java.lang.Object ref = allowDefaultNicAttachment_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowDefaultNicAttachment_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_EXTERNAL_IP_ACCESS_FIELD_NUMBER = 131538110;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowExternalIpAccess_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network
   * interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return Whether the allowExternalIpAccess field is set.
   */
  @java.lang.Override
  public boolean hasAllowExternalIpAccess() {
    return ((bitField0_ & 0x00000080) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network
   * interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return The allowExternalIpAccess.
   */
  @java.lang.Override
  public java.lang.String getAllowExternalIpAccess() {
    java.lang.Object ref = allowExternalIpAccess_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowExternalIpAccess_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VMs are allowed to have external IP access on network
   * interfaces connected to this VPC.
   * Check the AllowExternalIpAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_external_ip_access = 131538110;</code>
   *
   * @return The bytes for allowExternalIpAccess.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowExternalIpAccessBytes() {
    java.lang.Object ref = allowExternalIpAccess_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowExternalIpAccess_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_FIREWALL_POLICY_FIELD_NUMBER = 254200923;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowFirewallPolicy_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether firewall policy can be attached to the network.
   * Check the AllowFirewallPolicy enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_firewall_policy = 254200923;</code>
   *
   * @return Whether the allowFirewallPolicy field is set.
   */
  @java.lang.Override
  public boolean hasAllowFirewallPolicy() {
    return ((bitField0_ & 0x00000100) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewall policy can be attached to the network.
   * Check the AllowFirewallPolicy enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_firewall_policy = 254200923;</code>
   *
   * @return The allowFirewallPolicy.
   */
  @java.lang.Override
  public java.lang.String getAllowFirewallPolicy() {
    java.lang.Object ref = allowFirewallPolicy_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowFirewallPolicy_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether firewall policy can be attached to the network.
   * Check the AllowFirewallPolicy enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_firewall_policy = 254200923;</code>
   *
   * @return The bytes for allowFirewallPolicy.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowFirewallPolicyBytes() {
    java.lang.Object ref = allowFirewallPolicy_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowFirewallPolicy_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_INTERCONNECT_FIELD_NUMBER = 280512964;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowInterconnect_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return Whether the allowInterconnect field is set.
   */
  @java.lang.Override
  public boolean hasAllowInterconnect() {
    return ((bitField0_ & 0x00000200) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return The allowInterconnect.
   */
  @java.lang.Override
  public java.lang.String getAllowInterconnect() {
    java.lang.Object ref = allowInterconnect_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowInterconnect_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Cloud Interconnect creation is allowed.
   * Check the AllowInterconnect enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_interconnect = 280512964;</code>
   *
   * @return The bytes for allowInterconnect.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowInterconnectBytes() {
    java.lang.Object ref = allowInterconnect_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowInterconnect_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_IP_FORWARDING_FIELD_NUMBER = 500838047;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowIpForwarding_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether IP forwarding is allowed.
   * Check the AllowIpForwarding enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ip_forwarding = 500838047;</code>
   *
   * @return Whether the allowIpForwarding field is set.
   */
  @java.lang.Override
  public boolean hasAllowIpForwarding() {
    return ((bitField0_ & 0x00000400) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether IP forwarding is allowed.
   * Check the AllowIpForwarding enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ip_forwarding = 500838047;</code>
   *
   * @return The allowIpForwarding.
   */
  @java.lang.Override
  public java.lang.String getAllowIpForwarding() {
    java.lang.Object ref = allowIpForwarding_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowIpForwarding_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether IP forwarding is allowed.
   * Check the AllowIpForwarding enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ip_forwarding = 500838047;</code>
   *
   * @return The bytes for allowIpForwarding.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowIpForwardingBytes() {
    java.lang.Object ref = allowIpForwarding_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowIpForwarding_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_LOAD_BALANCING_FIELD_NUMBER = 223366198;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowLoadBalancing_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return Whether the allowLoadBalancing field is set.
   */
  @java.lang.Override
  public boolean hasAllowLoadBalancing() {
    return ((bitField0_ & 0x00000800) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return The allowLoadBalancing.
   */
  @java.lang.Override
  public java.lang.String getAllowLoadBalancing() {
    java.lang.Object ref = allowLoadBalancing_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowLoadBalancing_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether cloud load balancing is allowed.
   * Check the AllowLoadBalancing enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_load_balancing = 223366198;</code>
   *
   * @return The bytes for allowLoadBalancing.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowLoadBalancingBytes() {
    java.lang.Object ref = allowLoadBalancing_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowLoadBalancing_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_MULTI_NIC_IN_SAME_NETWORK_FIELD_NUMBER = 88251004;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowMultiNicInSameNetwork_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return Whether the allowMultiNicInSameNetwork field is set.
   */
  @java.lang.Override
  public boolean hasAllowMultiNicInSameNetwork() {
    return ((bitField0_ & 0x00001000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return The allowMultiNicInSameNetwork.
   */
  @java.lang.Override
  public java.lang.String getAllowMultiNicInSameNetwork() {
    java.lang.Object ref = allowMultiNicInSameNetwork_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowMultiNicInSameNetwork_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same network is allowed.
   * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
   *
   * @return The bytes for allowMultiNicInSameNetwork.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowMultiNicInSameNetworkBytes() {
    java.lang.Object ref = allowMultiNicInSameNetwork_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowMultiNicInSameNetwork_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK_FIELD_NUMBER = 278087904;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowMultiNicInSameSubnetwork_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same subnetwork is allowed.
   * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
   *
   * @return Whether the allowMultiNicInSameSubnetwork field is set.
   */
  @java.lang.Override
  public boolean hasAllowMultiNicInSameSubnetwork() {
    return ((bitField0_ & 0x00002000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same subnetwork is allowed.
   * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
   *
   * @return The allowMultiNicInSameSubnetwork.
   */
  @java.lang.Override
  public java.lang.String getAllowMultiNicInSameSubnetwork() {
    java.lang.Object ref = allowMultiNicInSameSubnetwork_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowMultiNicInSameSubnetwork_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multi-nic in the same subnetwork is allowed.
   * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
   *
   * @return The bytes for allowMultiNicInSameSubnetwork.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowMultiNicInSameSubnetworkBytes() {
    java.lang.Object ref = allowMultiNicInSameSubnetwork_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowMultiNicInSameSubnetwork_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_MULTICAST_FIELD_NUMBER = 11002498;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowMulticast_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether multicast is allowed.
   * Check the AllowMulticast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multicast = 11002498;</code>
   *
   * @return Whether the allowMulticast field is set.
   */
  @java.lang.Override
  public boolean hasAllowMulticast() {
    return ((bitField0_ & 0x00004000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multicast is allowed.
   * Check the AllowMulticast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multicast = 11002498;</code>
   *
   * @return The allowMulticast.
   */
  @java.lang.Override
  public java.lang.String getAllowMulticast() {
    java.lang.Object ref = allowMulticast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowMulticast_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether multicast is allowed.
   * Check the AllowMulticast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_multicast = 11002498;</code>
   *
   * @return The bytes for allowMulticast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowMulticastBytes() {
    java.lang.Object ref = allowMulticast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowMulticast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_NCC_FIELD_NUMBER = 372354904;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowNcc_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether NCC is allowed.
   * Check the AllowNcc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ncc = 372354904;</code>
   *
   * @return Whether the allowNcc field is set.
   */
  @java.lang.Override
  public boolean hasAllowNcc() {
    return ((bitField0_ & 0x00008000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether NCC is allowed.
   * Check the AllowNcc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ncc = 372354904;</code>
   *
   * @return The allowNcc.
   */
  @java.lang.Override
  public java.lang.String getAllowNcc() {
    java.lang.Object ref = allowNcc_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowNcc_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether NCC is allowed.
   * Check the AllowNcc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_ncc = 372354904;</code>
   *
   * @return The bytes for allowNcc.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowNccBytes() {
    java.lang.Object ref = allowNcc_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowNcc_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_NETWORK_MIGRATION_FIELD_NUMBER = 239588231;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowNetworkMigration_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether VM network migration is allowed.
   * Check the AllowNetworkMigration enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_network_migration = 239588231;</code>
   *
   * @return Whether the allowNetworkMigration field is set.
   */
  @java.lang.Override
  public boolean hasAllowNetworkMigration() {
    return ((bitField0_ & 0x00010000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VM network migration is allowed.
   * Check the AllowNetworkMigration enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_network_migration = 239588231;</code>
   *
   * @return The allowNetworkMigration.
   */
  @java.lang.Override
  public java.lang.String getAllowNetworkMigration() {
    java.lang.Object ref = allowNetworkMigration_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowNetworkMigration_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VM network migration is allowed.
   * Check the AllowNetworkMigration enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_network_migration = 239588231;</code>
   *
   * @return The bytes for allowNetworkMigration.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowNetworkMigrationBytes() {
    java.lang.Object ref = allowNetworkMigration_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowNetworkMigration_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PACKET_MIRRORING_FIELD_NUMBER = 512227074;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPacketMirroring_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return Whether the allowPacketMirroring field is set.
   */
  @java.lang.Override
  public boolean hasAllowPacketMirroring() {
    return ((bitField0_ & 0x00020000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return The allowPacketMirroring.
   */
  @java.lang.Override
  public java.lang.String getAllowPacketMirroring() {
    java.lang.Object ref = allowPacketMirroring_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPacketMirroring_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether Packet Mirroring 1.0 is supported.
   * Check the AllowPacketMirroring enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_packet_mirroring = 512227074;</code>
   *
   * @return The bytes for allowPacketMirroring.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPacketMirroringBytes() {
    java.lang.Object ref = allowPacketMirroring_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPacketMirroring_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PRIVATE_GOOGLE_ACCESS_FIELD_NUMBER = 374702072;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPrivateGoogleAccess_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return Whether the allowPrivateGoogleAccess field is set.
   */
  @java.lang.Override
  public boolean hasAllowPrivateGoogleAccess() {
    return ((bitField0_ & 0x00040000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return The allowPrivateGoogleAccess.
   */
  @java.lang.Override
  public java.lang.String getAllowPrivateGoogleAccess() {
    java.lang.Object ref = allowPrivateGoogleAccess_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPrivateGoogleAccess_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether private Google access is allowed.
   * Check the AllowPrivateGoogleAccess enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_private_google_access = 374702072;</code>
   *
   * @return The bytes for allowPrivateGoogleAccess.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPrivateGoogleAccessBytes() {
    java.lang.Object ref = allowPrivateGoogleAccess_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPrivateGoogleAccess_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_PSC_FIELD_NUMBER = 372357322;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowPsc_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return Whether the allowPsc field is set.
   */
  @java.lang.Override
  public boolean hasAllowPsc() {
    return ((bitField0_ & 0x00080000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return The allowPsc.
   */
  @java.lang.Override
  public java.lang.String getAllowPsc() {
    java.lang.Object ref = allowPsc_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowPsc_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether PSC creation is allowed.
   * Check the AllowPsc enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_psc = 372357322;</code>
   *
   * @return The bytes for allowPsc.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowPscBytes() {
    java.lang.Object ref = allowPsc_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowPsc_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_SAME_NETWORK_UNICAST_FIELD_NUMBER = 167531643;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowSameNetworkUnicast_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return Whether the allowSameNetworkUnicast field is set.
   */
  @java.lang.Override
  public boolean hasAllowSameNetworkUnicast() {
    return ((bitField0_ & 0x00100000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return The allowSameNetworkUnicast.
   */
  @java.lang.Override
  public java.lang.String getAllowSameNetworkUnicast() {
    java.lang.Object ref = allowSameNetworkUnicast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowSameNetworkUnicast_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether unicast within the same network is allowed.
   * Check the AllowSameNetworkUnicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_same_network_unicast = 167531643;</code>
   *
   * @return The bytes for allowSameNetworkUnicast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowSameNetworkUnicastBytes() {
    java.lang.Object ref = allowSameNetworkUnicast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowSameNetworkUnicast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_STATIC_ROUTES_FIELD_NUMBER = 185257925;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowStaticRoutes_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return Whether the allowStaticRoutes field is set.
   */
  @java.lang.Override
  public boolean hasAllowStaticRoutes() {
    return ((bitField0_ & 0x00200000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return The allowStaticRoutes.
   */
  @java.lang.Override
  public java.lang.String getAllowStaticRoutes() {
    java.lang.Object ref = allowStaticRoutes_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowStaticRoutes_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether static route creation is allowed.
   * Check the AllowStaticRoutes enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_static_routes = 185257925;</code>
   *
   * @return The bytes for allowStaticRoutes.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowStaticRoutesBytes() {
    java.lang.Object ref = allowStaticRoutes_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowStaticRoutes_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_SUB_INTERFACES_FIELD_NUMBER = 247208303;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowSubInterfaces_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return Whether the allowSubInterfaces field is set.
   */
  @java.lang.Override
  public boolean hasAllowSubInterfaces() {
    return ((bitField0_ & 0x00400000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return The allowSubInterfaces.
   */
  @java.lang.Override
  public java.lang.String getAllowSubInterfaces() {
    java.lang.Object ref = allowSubInterfaces_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowSubInterfaces_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether sub interfaces are allowed.
   * Check the AllowSubInterfaces enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_sub_interfaces = 247208303;</code>
   *
   * @return The bytes for allowSubInterfaces.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowSubInterfacesBytes() {
    java.lang.Object ref = allowSubInterfaces_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowSubInterfaces_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_SUBNETWORK_CREATION_FIELD_NUMBER = 459328026;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowSubnetworkCreation_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether subnetwork creation is allowed.
   * Check the AllowSubnetworkCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_subnetwork_creation = 459328026;</code>
   *
   * @return Whether the allowSubnetworkCreation field is set.
   */
  @java.lang.Override
  public boolean hasAllowSubnetworkCreation() {
    return ((bitField0_ & 0x00800000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether subnetwork creation is allowed.
   * Check the AllowSubnetworkCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_subnetwork_creation = 459328026;</code>
   *
   * @return The allowSubnetworkCreation.
   */
  @java.lang.Override
  public java.lang.String getAllowSubnetworkCreation() {
    java.lang.Object ref = allowSubnetworkCreation_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowSubnetworkCreation_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether subnetwork creation is allowed.
   * Check the AllowSubnetworkCreation enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_subnetwork_creation = 459328026;</code>
   *
   * @return The bytes for allowSubnetworkCreation.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowSubnetworkCreationBytes() {
    java.lang.Object ref = allowSubnetworkCreation_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowSubnetworkCreation_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_VPC_FIREWALL_RULES_FIELD_NUMBER = 509076420;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowVpcFirewallRules_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether VPC firewall rules can be created under the network.
   * Check the AllowVpcFirewallRules enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
   *
   * @return Whether the allowVpcFirewallRules field is set.
   */
  @java.lang.Override
  public boolean hasAllowVpcFirewallRules() {
    return ((bitField0_ & 0x01000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC firewall rules can be created under the network.
   * Check the AllowVpcFirewallRules enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
   *
   * @return The allowVpcFirewallRules.
   */
  @java.lang.Override
  public java.lang.String getAllowVpcFirewallRules() {
    java.lang.Object ref = allowVpcFirewallRules_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowVpcFirewallRules_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC firewall rules can be created under the network.
   * Check the AllowVpcFirewallRules enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
   *
   * @return The bytes for allowVpcFirewallRules.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowVpcFirewallRulesBytes() {
    java.lang.Object ref = allowVpcFirewallRules_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowVpcFirewallRules_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_VPC_PEERING_FIELD_NUMBER = 115402228;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowVpcPeering_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return Whether the allowVpcPeering field is set.
   */
  @java.lang.Override
  public boolean hasAllowVpcPeering() {
    return ((bitField0_ & 0x02000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return The allowVpcPeering.
   */
  @java.lang.Override
  public java.lang.String getAllowVpcPeering() {
    java.lang.Object ref = allowVpcPeering_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowVpcPeering_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPC peering is allowed.
   * Check the AllowVpcPeering enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpc_peering = 115402228;</code>
   *
   * @return The bytes for allowVpcPeering.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowVpcPeeringBytes() {
    java.lang.Object ref = allowVpcPeering_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowVpcPeering_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALLOW_VPN_FIELD_NUMBER = 372363006;

  @SuppressWarnings("serial")
  private volatile java.lang.Object allowVpn_ = "";

  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return Whether the allowVpn field is set.
   */
  @java.lang.Override
  public boolean hasAllowVpn() {
    return ((bitField0_ & 0x04000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return The allowVpn.
   */
  @java.lang.Override
  public java.lang.String getAllowVpn() {
    java.lang.Object ref = allowVpn_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      allowVpn_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies whether VPN creation is allowed.
   * Check the AllowVpn enum for the list of possible values.
   * </pre>
   *
   * <code>optional string allow_vpn = 372363006;</code>
   *
   * @return The bytes for allowVpn.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getAllowVpnBytes() {
    java.lang.Object ref = allowVpn_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      allowVpn_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int FIREWALL_POLICY_TYPES_FIELD_NUMBER = 390742027;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList firewallPolicyTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   *
   * Check the FirewallPolicyTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string firewall_policy_types = 390742027;</code>
   *
   * @return A list containing the firewallPolicyTypes.
   */
  public com.google.protobuf.ProtocolStringList getFirewallPolicyTypesList() {
    return firewallPolicyTypes_;
  }

  /**
   *
   *
   * <pre>
   *
   * Check the FirewallPolicyTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string firewall_policy_types = 390742027;</code>
   *
   * @return The count of firewallPolicyTypes.
   */
  public int getFirewallPolicyTypesCount() {
    return firewallPolicyTypes_.size();
  }

  /**
   *
   *
   * <pre>
   *
   * Check the FirewallPolicyTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string firewall_policy_types = 390742027;</code>
   *
   * @param index The index of the element to return.
   * @return The firewallPolicyTypes at the given index.
   */
  public java.lang.String getFirewallPolicyTypes(int index) {
    return firewallPolicyTypes_.get(index);
  }

  /**
   *
   *
   * <pre>
   *
   * Check the FirewallPolicyTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string firewall_policy_types = 390742027;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the firewallPolicyTypes at the given index.
   */
  public com.google.protobuf.ByteString getFirewallPolicyTypesBytes(int index) {
    return firewallPolicyTypes_.getByteString(index);
  }

  public static final int INTERFACE_TYPES_FIELD_NUMBER = 157981171;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList interfaceTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If
   * empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @return A list containing the interfaceTypes.
   */
  public com.google.protobuf.ProtocolStringList getInterfaceTypesList() {
    return interfaceTypes_;
  }

  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If
   * empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @return The count of interfaceTypes.
   */
  public int getInterfaceTypesCount() {
    return interfaceTypes_.size();
  }

  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If
   * empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @param index The index of the element to return.
   * @return The interfaceTypes at the given index.
   */
  public java.lang.String getInterfaceTypes(int index) {
    return interfaceTypes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * If set, limits the interface types that the network supports. If
   * empty, all interface types are supported.
   * Check the InterfaceTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string interface_types = 157981171;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the interfaceTypes at the given index.
   */
  public com.google.protobuf.ByteString getInterfaceTypesBytes(int index) {
    return interfaceTypes_.getByteString(index);
  }

  public static final int MULTICAST_FIELD_NUMBER = 404098040;

  @SuppressWarnings("serial")
  private volatile java.lang.Object multicast_ = "";

  /**
   *
   *
   * <pre>
   * Specifies which type of multicast is supported.
   * Check the Multicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string multicast = 404098040;</code>
   *
   * @return Whether the multicast field is set.
   */
  @java.lang.Override
  public boolean hasMulticast() {
    return ((bitField0_ & 0x08000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of multicast is supported.
   * Check the Multicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string multicast = 404098040;</code>
   *
   * @return The multicast.
   */
  @java.lang.Override
  public java.lang.String getMulticast() {
    java.lang.Object ref = multicast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      multicast_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of multicast is supported.
   * Check the Multicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string multicast = 404098040;</code>
   *
   * @return The bytes for multicast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getMulticastBytes() {
    java.lang.Object ref = multicast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      multicast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PREDEFINED_NETWORK_INTERNAL_IPV6_RANGE_FIELD_NUMBER = 527810909;

  @SuppressWarnings("serial")
  private volatile java.lang.Object predefinedNetworkInternalIpv6Range_ = "";

  /**
   *
   *
   * <pre>
   * Specifies a predefined internal IPv6 range for the network.
   * </pre>
   *
   * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
   *
   * @return Whether the predefinedNetworkInternalIpv6Range field is set.
   */
  @java.lang.Override
  public boolean hasPredefinedNetworkInternalIpv6Range() {
    return ((bitField0_ & 0x10000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies a predefined internal IPv6 range for the network.
   * </pre>
   *
   * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
   *
   * @return The predefinedNetworkInternalIpv6Range.
   */
  @java.lang.Override
  public java.lang.String getPredefinedNetworkInternalIpv6Range() {
    java.lang.Object ref = predefinedNetworkInternalIpv6Range_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      predefinedNetworkInternalIpv6Range_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies a predefined internal IPv6 range for the network.
   * </pre>
   *
   * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
   *
   * @return The bytes for predefinedNetworkInternalIpv6Range.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getPredefinedNetworkInternalIpv6RangeBytes() {
    java.lang.Object ref = predefinedNetworkInternalIpv6Range_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      predefinedNetworkInternalIpv6Range_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PREDEFINED_SUBNETWORK_RANGES_FIELD_NUMBER = 408740430;

  @SuppressWarnings("serial")
  private java.util.List<
          com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>
      predefinedSubnetworkRanges_;

  /**
   *
   *
   * <pre>
   * Predefined subnetwork ranges for the network.
   * </pre>
   *
   * <code>
   * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
   * </code>
   */
  @java.lang.Override
  public java.util.List<
          com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>
      getPredefinedSubnetworkRangesList() {
    return predefinedSubnetworkRanges_;
  }

  /**
   *
   *
   * <pre>
   * Predefined subnetwork ranges for the network.
   * </pre>
   *
   * <code>
   * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
   * </code>
   */
  @java.lang.Override
  public java.util.List<
          ? extends
              com.google.cloud.compute.v1
                  .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder>
      getPredefinedSubnetworkRangesOrBuilderList() {
    return predefinedSubnetworkRanges_;
  }

  /**
   *
   *
   * <pre>
   * Predefined subnetwork ranges for the network.
   * </pre>
   *
   * <code>
   * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
   * </code>
   */
  @java.lang.Override
  public int getPredefinedSubnetworkRangesCount() {
    return predefinedSubnetworkRanges_.size();
  }

  /**
   *
   *
   * <pre>
   * Predefined subnetwork ranges for the network.
   * </pre>
   *
   * <code>
   * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
   * </code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
      getPredefinedSubnetworkRanges(int index) {
    return predefinedSubnetworkRanges_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Predefined subnetwork ranges for the network.
   * </pre>
   *
   * <code>
   * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
   * </code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder
      getPredefinedSubnetworkRangesOrBuilder(int index) {
    return predefinedSubnetworkRanges_.get(index);
  }

  public static final int SUBNET_PURPOSES_FIELD_NUMBER = 301338039;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetPurposes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @return A list containing the subnetPurposes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetPurposesList() {
    return subnetPurposes_;
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @return The count of subnetPurposes.
   */
  public int getSubnetPurposesCount() {
    return subnetPurposes_.size();
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetPurposes at the given index.
   */
  public java.lang.String getSubnetPurposes(int index) {
    return subnetPurposes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork purposes are supported.
   * Check the SubnetPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_purposes = 301338039;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetPurposes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetPurposesBytes(int index) {
    return subnetPurposes_.getByteString(index);
  }

  public static final int SUBNET_STACK_TYPES_FIELD_NUMBER = 521008672;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetStackTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @return A list containing the subnetStackTypes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetStackTypesList() {
    return subnetStackTypes_;
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @return The count of subnetStackTypes.
   */
  public int getSubnetStackTypesCount() {
    return subnetStackTypes_.size();
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetStackTypes at the given index.
   */
  public java.lang.String getSubnetStackTypes(int index) {
    return subnetStackTypes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Specifies which subnetwork stack types are supported.
   * Check the SubnetStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnet_stack_types = 521008672;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetStackTypes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetStackTypesBytes(int index) {
    return subnetStackTypes_.getByteString(index);
  }

  public static final int SUBNETWORK_PURPOSES_FIELD_NUMBER = 528240710;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetworkPurposes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork purposes are supported.
   * Check the SubnetworkPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_purposes = 528240710;</code>
   *
   * @return A list containing the subnetworkPurposes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetworkPurposesList() {
    return subnetworkPurposes_;
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork purposes are supported.
   * Check the SubnetworkPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_purposes = 528240710;</code>
   *
   * @return The count of subnetworkPurposes.
   */
  public int getSubnetworkPurposesCount() {
    return subnetworkPurposes_.size();
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork purposes are supported.
   * Check the SubnetworkPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_purposes = 528240710;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetworkPurposes at the given index.
   */
  public java.lang.String getSubnetworkPurposes(int index) {
    return subnetworkPurposes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork purposes are supported.
   * Check the SubnetworkPurposes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_purposes = 528240710;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetworkPurposes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetworkPurposesBytes(int index) {
    return subnetworkPurposes_.getByteString(index);
  }

  public static final int SUBNETWORK_STACK_TYPES_FIELD_NUMBER = 436827441;

  @SuppressWarnings("serial")
  private com.google.protobuf.LazyStringArrayList subnetworkStackTypes_ =
      com.google.protobuf.LazyStringArrayList.emptyList();

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork stack types are supported.
   * Check the SubnetworkStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_stack_types = 436827441;</code>
   *
   * @return A list containing the subnetworkStackTypes.
   */
  public com.google.protobuf.ProtocolStringList getSubnetworkStackTypesList() {
    return subnetworkStackTypes_;
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork stack types are supported.
   * Check the SubnetworkStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_stack_types = 436827441;</code>
   *
   * @return The count of subnetworkStackTypes.
   */
  public int getSubnetworkStackTypesCount() {
    return subnetworkStackTypes_.size();
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork stack types are supported.
   * Check the SubnetworkStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_stack_types = 436827441;</code>
   *
   * @param index The index of the element to return.
   * @return The subnetworkStackTypes at the given index.
   */
  public java.lang.String getSubnetworkStackTypes(int index) {
    return subnetworkStackTypes_.get(index);
  }

  /**
   *
   *
   * <pre>
   * Output only. Specifies which subnetwork stack types are supported.
   * Check the SubnetworkStackTypes enum for the list of possible values.
   * </pre>
   *
   * <code>repeated string subnetwork_stack_types = 436827441;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the subnetworkStackTypes at the given index.
   */
  public com.google.protobuf.ByteString getSubnetworkStackTypesBytes(int index) {
    return subnetworkStackTypes_.getByteString(index);
  }

  public static final int UNICAST_FIELD_NUMBER = 249841711;

  @SuppressWarnings("serial")
  private volatile java.lang.Object unicast_ = "";

  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return Whether the unicast field is set.
   */
  @java.lang.Override
  public boolean hasUnicast() {
    return ((bitField0_ & 0x20000000) != 0);
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return The unicast.
   */
  @java.lang.Override
  public java.lang.String getUnicast() {
    java.lang.Object ref = unicast_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      unicast_ = s;
      return s;
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies which type of unicast is supported.
   * Check the Unicast enum for the list of possible values.
   * </pre>
   *
   * <code>optional string unicast = 249841711;</code>
   *
   * @return The bytes for unicast.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getUnicastBytes() {
    java.lang.Object ref = unicast_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      unicast_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00004000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 11002498, allowMulticast_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 53917486, allowDefaultNicAttachment_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 88251004, allowMultiNicInSameNetwork_);
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 115402228, allowVpcPeering_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 131538110, allowExternalIpAccess_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 131608987, allowClassDFirewalls_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 152191263, allowAutoModeSubnet_);
    }
    for (int i = 0; i < interfaceTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 157981171, interfaceTypes_.getRaw(i));
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 167531643, allowSameNetworkUnicast_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 185257925, allowStaticRoutes_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 223366198, allowLoadBalancing_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 239588231, allowNetworkMigration_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 247208303, allowSubInterfaces_);
    }
    if (((bitField0_ & 0x20000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 249841711, unicast_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 254200923, allowFirewallPolicy_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 254831265, allowCloudNat_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 278087904, allowMultiNicInSameSubnetwork_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 280512964, allowInterconnect_);
    }
    for (int i = 0; i < subnetPurposes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 301338039, subnetPurposes_.getRaw(i));
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 372354904, allowNcc_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 372357322, allowPsc_);
    }
    if (((bitField0_ & 0x04000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 372363006, allowVpn_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 374702072, allowPrivateGoogleAccess_);
    }
    for (int i = 0; i < firewallPolicyTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 390742027, firewallPolicyTypes_.getRaw(i));
    }
    if (((bitField0_ & 0x08000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 404098040, multicast_);
    }
    for (int i = 0; i < predefinedSubnetworkRanges_.size(); i++) {
      output.writeMessage(408740430, predefinedSubnetworkRanges_.get(i));
    }
    for (int i = 0; i < addressPurposes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 433024768, addressPurposes_.getRaw(i));
    }
    for (int i = 0; i < subnetworkStackTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 436827441, subnetworkStackTypes_.getRaw(i));
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 450941184, allowAddressCreation_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 451110345, allowCloudRouter_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 457984201, allowAliasIpRanges_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 459328026, allowSubnetworkCreation_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 500838047, allowIpForwarding_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 509076420, allowVpcFirewallRules_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 512227074, allowPacketMirroring_);
    }
    for (int i = 0; i < subnetStackTypes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 521008672, subnetStackTypes_.getRaw(i));
    }
    if (((bitField0_ & 0x10000000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 527810909, predefinedNetworkInternalIpv6Range_);
    }
    for (int i = 0; i < subnetworkPurposes_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 528240710, subnetworkPurposes_.getRaw(i));
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00004000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11002498, allowMulticast_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              53917486, allowDefaultNicAttachment_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              88251004, allowMultiNicInSameNetwork_);
    }
    if (((bitField0_ & 0x02000000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(115402228, allowVpcPeering_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              131538110, allowExternalIpAccess_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              131608987, allowClassDFirewalls_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(152191263, allowAutoModeSubnet_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < interfaceTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(interfaceTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getInterfaceTypesList().size();
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              167531643, allowSameNetworkUnicast_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(185257925, allowStaticRoutes_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(223366198, allowLoadBalancing_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              239588231, allowNetworkMigration_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(247208303, allowSubInterfaces_);
    }
    if (((bitField0_ & 0x20000000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(249841711, unicast_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(254200923, allowFirewallPolicy_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(254831265, allowCloudNat_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              278087904, allowMultiNicInSameSubnetwork_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(280512964, allowInterconnect_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetPurposes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetPurposes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetPurposesList().size();
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(372354904, allowNcc_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(372357322, allowPsc_);
    }
    if (((bitField0_ & 0x04000000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(372363006, allowVpn_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              374702072, allowPrivateGoogleAccess_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < firewallPolicyTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(firewallPolicyTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getFirewallPolicyTypesList().size();
    }
    if (((bitField0_ & 0x08000000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(404098040, multicast_);
    }
    for (int i = 0; i < predefinedSubnetworkRanges_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              408740430, predefinedSubnetworkRanges_.get(i));
    }
    {
      int dataSize = 0;
      for (int i = 0; i < addressPurposes_.size(); i++) {
        dataSize += computeStringSizeNoTag(addressPurposes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getAddressPurposesList().size();
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetworkStackTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetworkStackTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetworkStackTypesList().size();
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              450941184, allowAddressCreation_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(451110345, allowCloudRouter_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(457984201, allowAliasIpRanges_);
    }
    if (((bitField0_ & 0x00800000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              459328026, allowSubnetworkCreation_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(500838047, allowIpForwarding_);
    }
    if (((bitField0_ & 0x01000000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              509076420, allowVpcFirewallRules_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              512227074, allowPacketMirroring_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetStackTypes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetStackTypes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetStackTypesList().size();
    }
    if (((bitField0_ & 0x10000000) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              527810909, predefinedNetworkInternalIpv6Range_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subnetworkPurposes_.size(); i++) {
        dataSize += computeStringSizeNoTag(subnetworkPurposes_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getSubnetworkPurposesList().size();
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.NetworkProfileNetworkFeatures)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.NetworkProfileNetworkFeatures other =
        (com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) obj;

    if (!getAddressPurposesList().equals(other.getAddressPurposesList())) return false;
    if (hasAllowAddressCreation() != other.hasAllowAddressCreation()) return false;
    if (hasAllowAddressCreation()) {
      if (!getAllowAddressCreation().equals(other.getAllowAddressCreation())) return false;
    }
    if (hasAllowAliasIpRanges() != other.hasAllowAliasIpRanges()) return false;
    if (hasAllowAliasIpRanges()) {
      if (!getAllowAliasIpRanges().equals(other.getAllowAliasIpRanges())) return false;
    }
    if (hasAllowAutoModeSubnet() != other.hasAllowAutoModeSubnet()) return false;
    if (hasAllowAutoModeSubnet()) {
      if (!getAllowAutoModeSubnet().equals(other.getAllowAutoModeSubnet())) return false;
    }
    if (hasAllowClassDFirewalls() != other.hasAllowClassDFirewalls()) return false;
    if (hasAllowClassDFirewalls()) {
      if (!getAllowClassDFirewalls().equals(other.getAllowClassDFirewalls())) return false;
    }
    if (hasAllowCloudNat() != other.hasAllowCloudNat()) return false;
    if (hasAllowCloudNat()) {
      if (!getAllowCloudNat().equals(other.getAllowCloudNat())) return false;
    }
    if (hasAllowCloudRouter() != other.hasAllowCloudRouter()) return false;
    if (hasAllowCloudRouter()) {
      if (!getAllowCloudRouter().equals(other.getAllowCloudRouter())) return false;
    }
    if (hasAllowDefaultNicAttachment() != other.hasAllowDefaultNicAttachment()) return false;
    if (hasAllowDefaultNicAttachment()) {
      if (!getAllowDefaultNicAttachment().equals(other.getAllowDefaultNicAttachment()))
        return false;
    }
    if (hasAllowExternalIpAccess() != other.hasAllowExternalIpAccess()) return false;
    if (hasAllowExternalIpAccess()) {
      if (!getAllowExternalIpAccess().equals(other.getAllowExternalIpAccess())) return false;
    }
    if (hasAllowFirewallPolicy() != other.hasAllowFirewallPolicy()) return false;
    if (hasAllowFirewallPolicy()) {
      if (!getAllowFirewallPolicy().equals(other.getAllowFirewallPolicy())) return false;
    }
    if (hasAllowInterconnect() != other.hasAllowInterconnect()) return false;
    if (hasAllowInterconnect()) {
      if (!getAllowInterconnect().equals(other.getAllowInterconnect())) return false;
    }
    if (hasAllowIpForwarding() != other.hasAllowIpForwarding()) return false;
    if (hasAllowIpForwarding()) {
      if (!getAllowIpForwarding().equals(other.getAllowIpForwarding())) return false;
    }
    if (hasAllowLoadBalancing() != other.hasAllowLoadBalancing()) return false;
    if (hasAllowLoadBalancing()) {
      if (!getAllowLoadBalancing().equals(other.getAllowLoadBalancing())) return false;
    }
    if (hasAllowMultiNicInSameNetwork() != other.hasAllowMultiNicInSameNetwork()) return false;
    if (hasAllowMultiNicInSameNetwork()) {
      if (!getAllowMultiNicInSameNetwork().equals(other.getAllowMultiNicInSameNetwork()))
        return false;
    }
    if (hasAllowMultiNicInSameSubnetwork() != other.hasAllowMultiNicInSameSubnetwork())
      return false;
    if (hasAllowMultiNicInSameSubnetwork()) {
      if (!getAllowMultiNicInSameSubnetwork().equals(other.getAllowMultiNicInSameSubnetwork()))
        return false;
    }
    if (hasAllowMulticast() != other.hasAllowMulticast()) return false;
    if (hasAllowMulticast()) {
      if (!getAllowMulticast().equals(other.getAllowMulticast())) return false;
    }
    if (hasAllowNcc() != other.hasAllowNcc()) return false;
    if (hasAllowNcc()) {
      if (!getAllowNcc().equals(other.getAllowNcc())) return false;
    }
    if (hasAllowNetworkMigration() != other.hasAllowNetworkMigration()) return false;
    if (hasAllowNetworkMigration()) {
      if (!getAllowNetworkMigration().equals(other.getAllowNetworkMigration())) return false;
    }
    if (hasAllowPacketMirroring() != other.hasAllowPacketMirroring()) return false;
    if (hasAllowPacketMirroring()) {
      if (!getAllowPacketMirroring().equals(other.getAllowPacketMirroring())) return false;
    }
    if (hasAllowPrivateGoogleAccess() != other.hasAllowPrivateGoogleAccess()) return false;
    if (hasAllowPrivateGoogleAccess()) {
      if (!getAllowPrivateGoogleAccess().equals(other.getAllowPrivateGoogleAccess())) return false;
    }
    if (hasAllowPsc() != other.hasAllowPsc()) return false;
    if (hasAllowPsc()) {
      if (!getAllowPsc().equals(other.getAllowPsc())) return false;
    }
    if (hasAllowSameNetworkUnicast() != other.hasAllowSameNetworkUnicast()) return false;
    if (hasAllowSameNetworkUnicast()) {
      if (!getAllowSameNetworkUnicast().equals(other.getAllowSameNetworkUnicast())) return false;
    }
    if (hasAllowStaticRoutes() != other.hasAllowStaticRoutes()) return false;
    if (hasAllowStaticRoutes()) {
      if (!getAllowStaticRoutes().equals(other.getAllowStaticRoutes())) return false;
    }
    if (hasAllowSubInterfaces() != other.hasAllowSubInterfaces()) return false;
    if (hasAllowSubInterfaces()) {
      if (!getAllowSubInterfaces().equals(other.getAllowSubInterfaces())) return false;
    }
    if (hasAllowSubnetworkCreation() != other.hasAllowSubnetworkCreation()) return false;
    if (hasAllowSubnetworkCreation()) {
      if (!getAllowSubnetworkCreation().equals(other.getAllowSubnetworkCreation())) return false;
    }
    if (hasAllowVpcFirewallRules() != other.hasAllowVpcFirewallRules()) return false;
    if (hasAllowVpcFirewallRules()) {
      if (!getAllowVpcFirewallRules().equals(other.getAllowVpcFirewallRules())) return false;
    }
    if (hasAllowVpcPeering() != other.hasAllowVpcPeering()) return false;
    if (hasAllowVpcPeering()) {
      if (!getAllowVpcPeering().equals(other.getAllowVpcPeering())) return false;
    }
    if (hasAllowVpn() != other.hasAllowVpn()) return false;
    if (hasAllowVpn()) {
      if (!getAllowVpn().equals(other.getAllowVpn())) return false;
    }
    if (!getFirewallPolicyTypesList().equals(other.getFirewallPolicyTypesList())) return false;
    if (!getInterfaceTypesList().equals(other.getInterfaceTypesList())) return false;
    if (hasMulticast() != other.hasMulticast()) return false;
    if (hasMulticast()) {
      if (!getMulticast().equals(other.getMulticast())) return false;
    }
    if (hasPredefinedNetworkInternalIpv6Range() != other.hasPredefinedNetworkInternalIpv6Range())
      return false;
    if (hasPredefinedNetworkInternalIpv6Range()) {
      if (!getPredefinedNetworkInternalIpv6Range()
          .equals(other.getPredefinedNetworkInternalIpv6Range())) return false;
    }
    if (!getPredefinedSubnetworkRangesList().equals(other.getPredefinedSubnetworkRangesList()))
      return false;
    if (!getSubnetPurposesList().equals(other.getSubnetPurposesList())) return false;
    if (!getSubnetStackTypesList().equals(other.getSubnetStackTypesList())) return false;
    if (!getSubnetworkPurposesList().equals(other.getSubnetworkPurposesList())) return false;
    if (!getSubnetworkStackTypesList().equals(other.getSubnetworkStackTypesList())) return false;
    if (hasUnicast() != other.hasUnicast()) return false;
    if (hasUnicast()) {
      if (!getUnicast().equals(other.getUnicast())) return false;
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getAddressPurposesCount() > 0) {
      hash = (37 * hash) + ADDRESS_PURPOSES_FIELD_NUMBER;
      hash = (53 * hash) + getAddressPurposesList().hashCode();
    }
    if (hasAllowAddressCreation()) {
      hash = (37 * hash) + ALLOW_ADDRESS_CREATION_FIELD_NUMBER;
      hash = (53 * hash) + getAllowAddressCreation().hashCode();
    }
    if (hasAllowAliasIpRanges()) {
      hash = (37 * hash) + ALLOW_ALIAS_IP_RANGES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowAliasIpRanges().hashCode();
    }
    if (hasAllowAutoModeSubnet()) {
      hash = (37 * hash) + ALLOW_AUTO_MODE_SUBNET_FIELD_NUMBER;
      hash = (53 * hash) + getAllowAutoModeSubnet().hashCode();
    }
    if (hasAllowClassDFirewalls()) {
      hash = (37 * hash) + ALLOW_CLASS_D_FIREWALLS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowClassDFirewalls().hashCode();
    }
    if (hasAllowCloudNat()) {
      hash = (37 * hash) + ALLOW_CLOUD_NAT_FIELD_NUMBER;
      hash = (53 * hash) + getAllowCloudNat().hashCode();
    }
    if (hasAllowCloudRouter()) {
      hash = (37 * hash) + ALLOW_CLOUD_ROUTER_FIELD_NUMBER;
      hash = (53 * hash) + getAllowCloudRouter().hashCode();
    }
    if (hasAllowDefaultNicAttachment()) {
      hash = (37 * hash) + ALLOW_DEFAULT_NIC_ATTACHMENT_FIELD_NUMBER;
      hash = (53 * hash) + getAllowDefaultNicAttachment().hashCode();
    }
    if (hasAllowExternalIpAccess()) {
      hash = (37 * hash) + ALLOW_EXTERNAL_IP_ACCESS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowExternalIpAccess().hashCode();
    }
    if (hasAllowFirewallPolicy()) {
      hash = (37 * hash) + ALLOW_FIREWALL_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + getAllowFirewallPolicy().hashCode();
    }
    if (hasAllowInterconnect()) {
      hash = (37 * hash) + ALLOW_INTERCONNECT_FIELD_NUMBER;
      hash = (53 * hash) + getAllowInterconnect().hashCode();
    }
    if (hasAllowIpForwarding()) {
      hash = (37 * hash) + ALLOW_IP_FORWARDING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowIpForwarding().hashCode();
    }
    if (hasAllowLoadBalancing()) {
      hash = (37 * hash) + ALLOW_LOAD_BALANCING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowLoadBalancing().hashCode();
    }
    if (hasAllowMultiNicInSameNetwork()) {
      hash = (37 * hash) + ALLOW_MULTI_NIC_IN_SAME_NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getAllowMultiNicInSameNetwork().hashCode();
    }
    if (hasAllowMultiNicInSameSubnetwork()) {
      hash = (37 * hash) + ALLOW_MULTI_NIC_IN_SAME_SUBNETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getAllowMultiNicInSameSubnetwork().hashCode();
    }
    if (hasAllowMulticast()) {
      hash = (37 * hash) + ALLOW_MULTICAST_FIELD_NUMBER;
      hash = (53 * hash) + getAllowMulticast().hashCode();
    }
    if (hasAllowNcc()) {
      hash = (37 * hash) + ALLOW_NCC_FIELD_NUMBER;
      hash = (53 * hash) + getAllowNcc().hashCode();
    }
    if (hasAllowNetworkMigration()) {
      hash = (37 * hash) + ALLOW_NETWORK_MIGRATION_FIELD_NUMBER;
      hash = (53 * hash) + getAllowNetworkMigration().hashCode();
    }
    if (hasAllowPacketMirroring()) {
      hash = (37 * hash) + ALLOW_PACKET_MIRRORING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPacketMirroring().hashCode();
    }
    if (hasAllowPrivateGoogleAccess()) {
      hash = (37 * hash) + ALLOW_PRIVATE_GOOGLE_ACCESS_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPrivateGoogleAccess().hashCode();
    }
    if (hasAllowPsc()) {
      hash = (37 * hash) + ALLOW_PSC_FIELD_NUMBER;
      hash = (53 * hash) + getAllowPsc().hashCode();
    }
    if (hasAllowSameNetworkUnicast()) {
      hash = (37 * hash) + ALLOW_SAME_NETWORK_UNICAST_FIELD_NUMBER;
      hash = (53 * hash) + getAllowSameNetworkUnicast().hashCode();
    }
    if (hasAllowStaticRoutes()) {
      hash = (37 * hash) + ALLOW_STATIC_ROUTES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowStaticRoutes().hashCode();
    }
    if (hasAllowSubInterfaces()) {
      hash = (37 * hash) + ALLOW_SUB_INTERFACES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowSubInterfaces().hashCode();
    }
    if (hasAllowSubnetworkCreation()) {
      hash = (37 * hash) + ALLOW_SUBNETWORK_CREATION_FIELD_NUMBER;
      hash = (53 * hash) + getAllowSubnetworkCreation().hashCode();
    }
    if (hasAllowVpcFirewallRules()) {
      hash = (37 * hash) + ALLOW_VPC_FIREWALL_RULES_FIELD_NUMBER;
      hash = (53 * hash) + getAllowVpcFirewallRules().hashCode();
    }
    if (hasAllowVpcPeering()) {
      hash = (37 * hash) + ALLOW_VPC_PEERING_FIELD_NUMBER;
      hash = (53 * hash) + getAllowVpcPeering().hashCode();
    }
    if (hasAllowVpn()) {
      hash = (37 * hash) + ALLOW_VPN_FIELD_NUMBER;
      hash = (53 * hash) + getAllowVpn().hashCode();
    }
    if (getFirewallPolicyTypesCount() > 0) {
      hash = (37 * hash) + FIREWALL_POLICY_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getFirewallPolicyTypesList().hashCode();
    }
    if (getInterfaceTypesCount() > 0) {
      hash = (37 * hash) + INTERFACE_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getInterfaceTypesList().hashCode();
    }
    if (hasMulticast()) {
      hash = (37 * hash) + MULTICAST_FIELD_NUMBER;
      hash = (53 * hash) + getMulticast().hashCode();
    }
    if (hasPredefinedNetworkInternalIpv6Range()) {
      hash = (37 * hash) + PREDEFINED_NETWORK_INTERNAL_IPV6_RANGE_FIELD_NUMBER;
      hash = (53 * hash) + getPredefinedNetworkInternalIpv6Range().hashCode();
    }
    if (getPredefinedSubnetworkRangesCount() > 0) {
      hash = (37 * hash) + PREDEFINED_SUBNETWORK_RANGES_FIELD_NUMBER;
      hash = (53 * hash) + getPredefinedSubnetworkRangesList().hashCode();
    }
    if (getSubnetPurposesCount() > 0) {
      hash = (37 * hash) + SUBNET_PURPOSES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetPurposesList().hashCode();
    }
    if (getSubnetStackTypesCount() > 0) {
      hash = (37 * hash) + SUBNET_STACK_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetStackTypesList().hashCode();
    }
    if (getSubnetworkPurposesCount() > 0) {
      hash = (37 * hash) + SUBNETWORK_PURPOSES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetworkPurposesList().hashCode();
    }
    if (getSubnetworkStackTypesCount() > 0) {
      hash = (37 * hash) + SUBNETWORK_STACK_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetworkStackTypesList().hashCode();
    }
    if (hasUnicast()) {
      hash = (37 * hash) + UNICAST_FIELD_NUMBER;
      hash = (53 * hash) + getUnicast().hashCode();
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }

  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.NetworkProfileNetworkFeatures}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
      com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.class,
              com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.newBuilder()
    private Builder() {}

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      bitField1_ = 0;
      addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      allowAddressCreation_ = "";
      allowAliasIpRanges_ = "";
      allowAutoModeSubnet_ = "";
      allowClassDFirewalls_ = "";
      allowCloudNat_ = "";
      allowCloudRouter_ = "";
      allowDefaultNicAttachment_ = "";
      allowExternalIpAccess_ = "";
      allowFirewallPolicy_ = "";
      allowInterconnect_ = "";
      allowIpForwarding_ = "";
      allowLoadBalancing_ = "";
      allowMultiNicInSameNetwork_ = "";
      allowMultiNicInSameSubnetwork_ = "";
      allowMulticast_ = "";
      allowNcc_ = "";
      allowNetworkMigration_ = "";
      allowPacketMirroring_ = "";
      allowPrivateGoogleAccess_ = "";
      allowPsc_ = "";
      allowSameNetworkUnicast_ = "";
      allowStaticRoutes_ = "";
      allowSubInterfaces_ = "";
      allowSubnetworkCreation_ = "";
      allowVpcFirewallRules_ = "";
      allowVpcPeering_ = "";
      allowVpn_ = "";
      firewallPolicyTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      multicast_ = "";
      predefinedNetworkInternalIpv6Range_ = "";
      if (predefinedSubnetworkRangesBuilder_ == null) {
        predefinedSubnetworkRanges_ = java.util.Collections.emptyList();
      } else {
        predefinedSubnetworkRanges_ = null;
        predefinedSubnetworkRangesBuilder_.clear();
      }
      bitField1_ = (bitField1_ & ~0x00000001);
      subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      subnetworkPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      subnetworkStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      unicast_ = "";
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkProfileNetworkFeatures_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures build() {
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures buildPartial() {
      com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result =
          new com.google.cloud.compute.v1.NetworkProfileNetworkFeatures(this);
      buildPartialRepeatedFields(result);
      if (bitField0_ != 0) {
        buildPartial0(result);
      }
      if (bitField1_ != 0) {
        buildPartial1(result);
      }
      onBuilt();
      return result;
    }

    private void buildPartialRepeatedFields(
        com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        if (((bitField1_ & 0x00000001) != 0)) {
          predefinedSubnetworkRanges_ =
              java.util.Collections.unmodifiableList(predefinedSubnetworkRanges_);
          bitField1_ = (bitField1_ & ~0x00000001);
        }
        result.predefinedSubnetworkRanges_ = predefinedSubnetworkRanges_;
      } else {
        result.predefinedSubnetworkRanges_ = predefinedSubnetworkRangesBuilder_.build();
      }
    }

    private void buildPartial0(com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        addressPurposes_.makeImmutable();
        result.addressPurposes_ = addressPurposes_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.allowAddressCreation_ = allowAddressCreation_;
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.allowAliasIpRanges_ = allowAliasIpRanges_;
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.allowAutoModeSubnet_ = allowAutoModeSubnet_;
        to_bitField0_ |= 0x00000004;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.allowClassDFirewalls_ = allowClassDFirewalls_;
        to_bitField0_ |= 0x00000008;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.allowCloudNat_ = allowCloudNat_;
        to_bitField0_ |= 0x00000010;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.allowCloudRouter_ = allowCloudRouter_;
        to_bitField0_ |= 0x00000020;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.allowDefaultNicAttachment_ = allowDefaultNicAttachment_;
        to_bitField0_ |= 0x00000040;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.allowExternalIpAccess_ = allowExternalIpAccess_;
        to_bitField0_ |= 0x00000080;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.allowFirewallPolicy_ = allowFirewallPolicy_;
        to_bitField0_ |= 0x00000100;
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.allowInterconnect_ = allowInterconnect_;
        to_bitField0_ |= 0x00000200;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.allowIpForwarding_ = allowIpForwarding_;
        to_bitField0_ |= 0x00000400;
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        result.allowLoadBalancing_ = allowLoadBalancing_;
        to_bitField0_ |= 0x00000800;
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.allowMultiNicInSameNetwork_ = allowMultiNicInSameNetwork_;
        to_bitField0_ |= 0x00001000;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.allowMultiNicInSameSubnetwork_ = allowMultiNicInSameSubnetwork_;
        to_bitField0_ |= 0x00002000;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.allowMulticast_ = allowMulticast_;
        to_bitField0_ |= 0x00004000;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.allowNcc_ = allowNcc_;
        to_bitField0_ |= 0x00008000;
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.allowNetworkMigration_ = allowNetworkMigration_;
        to_bitField0_ |= 0x00010000;
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        result.allowPacketMirroring_ = allowPacketMirroring_;
        to_bitField0_ |= 0x00020000;
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        result.allowPrivateGoogleAccess_ = allowPrivateGoogleAccess_;
        to_bitField0_ |= 0x00040000;
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        result.allowPsc_ = allowPsc_;
        to_bitField0_ |= 0x00080000;
      }
      if (((from_bitField0_ & 0x00200000) != 0)) {
        result.allowSameNetworkUnicast_ = allowSameNetworkUnicast_;
        to_bitField0_ |= 0x00100000;
      }
      if (((from_bitField0_ & 0x00400000) != 0)) {
        result.allowStaticRoutes_ = allowStaticRoutes_;
        to_bitField0_ |= 0x00200000;
      }
      if (((from_bitField0_ & 0x00800000) != 0)) {
        result.allowSubInterfaces_ = allowSubInterfaces_;
        to_bitField0_ |= 0x00400000;
      }
      if (((from_bitField0_ & 0x01000000) != 0)) {
        result.allowSubnetworkCreation_ = allowSubnetworkCreation_;
        to_bitField0_ |= 0x00800000;
      }
      if (((from_bitField0_ & 0x02000000) != 0)) {
        result.allowVpcFirewallRules_ = allowVpcFirewallRules_;
        to_bitField0_ |= 0x01000000;
      }
      if (((from_bitField0_ & 0x04000000) != 0)) {
        result.allowVpcPeering_ = allowVpcPeering_;
        to_bitField0_ |= 0x02000000;
      }
      if (((from_bitField0_ & 0x08000000) != 0)) {
        result.allowVpn_ = allowVpn_;
        to_bitField0_ |= 0x04000000;
      }
      if (((from_bitField0_ & 0x10000000) != 0)) {
        firewallPolicyTypes_.makeImmutable();
        result.firewallPolicyTypes_ = firewallPolicyTypes_;
      }
      if (((from_bitField0_ & 0x20000000) != 0)) {
        interfaceTypes_.makeImmutable();
        result.interfaceTypes_ = interfaceTypes_;
      }
      if (((from_bitField0_ & 0x40000000) != 0)) {
        result.multicast_ = multicast_;
        to_bitField0_ |= 0x08000000;
      }
      if (((from_bitField0_ & 0x80000000) != 0)) {
        result.predefinedNetworkInternalIpv6Range_ = predefinedNetworkInternalIpv6Range_;
        to_bitField0_ |= 0x10000000;
      }
      result.bitField0_ |= to_bitField0_;
    }

    private void buildPartial1(com.google.cloud.compute.v1.NetworkProfileNetworkFeatures result) {
      int from_bitField1_ = bitField1_;
      if (((from_bitField1_ & 0x00000002) != 0)) {
        subnetPurposes_.makeImmutable();
        result.subnetPurposes_ = subnetPurposes_;
      }
      if (((from_bitField1_ & 0x00000004) != 0)) {
        subnetStackTypes_.makeImmutable();
        result.subnetStackTypes_ = subnetStackTypes_;
      }
      if (((from_bitField1_ & 0x00000008) != 0)) {
        subnetworkPurposes_.makeImmutable();
        result.subnetworkPurposes_ = subnetworkPurposes_;
      }
      if (((from_bitField1_ & 0x00000010) != 0)) {
        subnetworkStackTypes_.makeImmutable();
        result.subnetworkStackTypes_ = subnetworkStackTypes_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField1_ & 0x00000020) != 0)) {
        result.unicast_ = unicast_;
        to_bitField0_ |= 0x20000000;
      }
      result.bitField0_ |= to_bitField0_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) {
        return mergeFrom((com.google.cloud.compute.v1.NetworkProfileNetworkFeatures) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.NetworkProfileNetworkFeatures other) {
      if (other == com.google.cloud.compute.v1.NetworkProfileNetworkFeatures.getDefaultInstance())
        return this;
      if (!other.addressPurposes_.isEmpty()) {
        if (addressPurposes_.isEmpty()) {
          addressPurposes_ = other.addressPurposes_;
          bitField0_ |= 0x00000001;
        } else {
          ensureAddressPurposesIsMutable();
          addressPurposes_.addAll(other.addressPurposes_);
        }
        onChanged();
      }
      if (other.hasAllowAddressCreation()) {
        allowAddressCreation_ = other.allowAddressCreation_;
        bitField0_ |= 0x00000002;
        onChanged();
      }
      if (other.hasAllowAliasIpRanges()) {
        allowAliasIpRanges_ = other.allowAliasIpRanges_;
        bitField0_ |= 0x00000004;
        onChanged();
      }
      if (other.hasAllowAutoModeSubnet()) {
        allowAutoModeSubnet_ = other.allowAutoModeSubnet_;
        bitField0_ |= 0x00000008;
        onChanged();
      }
      if (other.hasAllowClassDFirewalls()) {
        allowClassDFirewalls_ = other.allowClassDFirewalls_;
        bitField0_ |= 0x00000010;
        onChanged();
      }
      if (other.hasAllowCloudNat()) {
        allowCloudNat_ = other.allowCloudNat_;
        bitField0_ |= 0x00000020;
        onChanged();
      }
      if (other.hasAllowCloudRouter()) {
        allowCloudRouter_ = other.allowCloudRouter_;
        bitField0_ |= 0x00000040;
        onChanged();
      }
      if (other.hasAllowDefaultNicAttachment()) {
        allowDefaultNicAttachment_ = other.allowDefaultNicAttachment_;
        bitField0_ |= 0x00000080;
        onChanged();
      }
      if (other.hasAllowExternalIpAccess()) {
        allowExternalIpAccess_ = other.allowExternalIpAccess_;
        bitField0_ |= 0x00000100;
        onChanged();
      }
      if (other.hasAllowFirewallPolicy()) {
        allowFirewallPolicy_ = other.allowFirewallPolicy_;
        bitField0_ |= 0x00000200;
        onChanged();
      }
      if (other.hasAllowInterconnect()) {
        allowInterconnect_ = other.allowInterconnect_;
        bitField0_ |= 0x00000400;
        onChanged();
      }
      if (other.hasAllowIpForwarding()) {
        allowIpForwarding_ = other.allowIpForwarding_;
        bitField0_ |= 0x00000800;
        onChanged();
      }
      if (other.hasAllowLoadBalancing()) {
        allowLoadBalancing_ = other.allowLoadBalancing_;
        bitField0_ |= 0x00001000;
        onChanged();
      }
      if (other.hasAllowMultiNicInSameNetwork()) {
        allowMultiNicInSameNetwork_ = other.allowMultiNicInSameNetwork_;
        bitField0_ |= 0x00002000;
        onChanged();
      }
      if (other.hasAllowMultiNicInSameSubnetwork()) {
        allowMultiNicInSameSubnetwork_ = other.allowMultiNicInSameSubnetwork_;
        bitField0_ |= 0x00004000;
        onChanged();
      }
      if (other.hasAllowMulticast()) {
        allowMulticast_ = other.allowMulticast_;
        bitField0_ |= 0x00008000;
        onChanged();
      }
      if (other.hasAllowNcc()) {
        allowNcc_ = other.allowNcc_;
        bitField0_ |= 0x00010000;
        onChanged();
      }
      if (other.hasAllowNetworkMigration()) {
        allowNetworkMigration_ = other.allowNetworkMigration_;
        bitField0_ |= 0x00020000;
        onChanged();
      }
      if (other.hasAllowPacketMirroring()) {
        allowPacketMirroring_ = other.allowPacketMirroring_;
        bitField0_ |= 0x00040000;
        onChanged();
      }
      if (other.hasAllowPrivateGoogleAccess()) {
        allowPrivateGoogleAccess_ = other.allowPrivateGoogleAccess_;
        bitField0_ |= 0x00080000;
        onChanged();
      }
      if (other.hasAllowPsc()) {
        allowPsc_ = other.allowPsc_;
        bitField0_ |= 0x00100000;
        onChanged();
      }
      if (other.hasAllowSameNetworkUnicast()) {
        allowSameNetworkUnicast_ = other.allowSameNetworkUnicast_;
        bitField0_ |= 0x00200000;
        onChanged();
      }
      if (other.hasAllowStaticRoutes()) {
        allowStaticRoutes_ = other.allowStaticRoutes_;
        bitField0_ |= 0x00400000;
        onChanged();
      }
      if (other.hasAllowSubInterfaces()) {
        allowSubInterfaces_ = other.allowSubInterfaces_;
        bitField0_ |= 0x00800000;
        onChanged();
      }
      if (other.hasAllowSubnetworkCreation()) {
        allowSubnetworkCreation_ = other.allowSubnetworkCreation_;
        bitField0_ |= 0x01000000;
        onChanged();
      }
      if (other.hasAllowVpcFirewallRules()) {
        allowVpcFirewallRules_ = other.allowVpcFirewallRules_;
        bitField0_ |= 0x02000000;
        onChanged();
      }
      if (other.hasAllowVpcPeering()) {
        allowVpcPeering_ = other.allowVpcPeering_;
        bitField0_ |= 0x04000000;
        onChanged();
      }
      if (other.hasAllowVpn()) {
        allowVpn_ = other.allowVpn_;
        bitField0_ |= 0x08000000;
        onChanged();
      }
      if (!other.firewallPolicyTypes_.isEmpty()) {
        if (firewallPolicyTypes_.isEmpty()) {
          firewallPolicyTypes_ = other.firewallPolicyTypes_;
          bitField0_ |= 0x10000000;
        } else {
          ensureFirewallPolicyTypesIsMutable();
          firewallPolicyTypes_.addAll(other.firewallPolicyTypes_);
        }
        onChanged();
      }
      if (!other.interfaceTypes_.isEmpty()) {
        if (interfaceTypes_.isEmpty()) {
          interfaceTypes_ = other.interfaceTypes_;
          bitField0_ |= 0x20000000;
        } else {
          ensureInterfaceTypesIsMutable();
          interfaceTypes_.addAll(other.interfaceTypes_);
        }
        onChanged();
      }
      if (other.hasMulticast()) {
        multicast_ = other.multicast_;
        bitField0_ |= 0x40000000;
        onChanged();
      }
      if (other.hasPredefinedNetworkInternalIpv6Range()) {
        predefinedNetworkInternalIpv6Range_ = other.predefinedNetworkInternalIpv6Range_;
        bitField0_ |= 0x80000000;
        onChanged();
      }
      if (predefinedSubnetworkRangesBuilder_ == null) {
        if (!other.predefinedSubnetworkRanges_.isEmpty()) {
          if (predefinedSubnetworkRanges_.isEmpty()) {
            predefinedSubnetworkRanges_ = other.predefinedSubnetworkRanges_;
            bitField1_ = (bitField1_ & ~0x00000001);
          } else {
            ensurePredefinedSubnetworkRangesIsMutable();
            predefinedSubnetworkRanges_.addAll(other.predefinedSubnetworkRanges_);
          }
          onChanged();
        }
      } else {
        if (!other.predefinedSubnetworkRanges_.isEmpty()) {
          if (predefinedSubnetworkRangesBuilder_.isEmpty()) {
            predefinedSubnetworkRangesBuilder_.dispose();
            predefinedSubnetworkRangesBuilder_ = null;
            predefinedSubnetworkRanges_ = other.predefinedSubnetworkRanges_;
            bitField1_ = (bitField1_ & ~0x00000001);
            predefinedSubnetworkRangesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getPredefinedSubnetworkRangesFieldBuilder()
                    : null;
          } else {
            predefinedSubnetworkRangesBuilder_.addAllMessages(other.predefinedSubnetworkRanges_);
          }
        }
      }
      if (!other.subnetPurposes_.isEmpty()) {
        if (subnetPurposes_.isEmpty()) {
          subnetPurposes_ = other.subnetPurposes_;
          bitField1_ |= 0x00000002;
        } else {
          ensureSubnetPurposesIsMutable();
          subnetPurposes_.addAll(other.subnetPurposes_);
        }
        onChanged();
      }
      if (!other.subnetStackTypes_.isEmpty()) {
        if (subnetStackTypes_.isEmpty()) {
          subnetStackTypes_ = other.subnetStackTypes_;
          bitField1_ |= 0x00000004;
        } else {
          ensureSubnetStackTypesIsMutable();
          subnetStackTypes_.addAll(other.subnetStackTypes_);
        }
        onChanged();
      }
      if (!other.subnetworkPurposes_.isEmpty()) {
        if (subnetworkPurposes_.isEmpty()) {
          subnetworkPurposes_ = other.subnetworkPurposes_;
          bitField1_ |= 0x00000008;
        } else {
          ensureSubnetworkPurposesIsMutable();
          subnetworkPurposes_.addAll(other.subnetworkPurposes_);
        }
        onChanged();
      }
      if (!other.subnetworkStackTypes_.isEmpty()) {
        if (subnetworkStackTypes_.isEmpty()) {
          subnetworkStackTypes_ = other.subnetworkStackTypes_;
          bitField1_ |= 0x00000010;
        } else {
          ensureSubnetworkStackTypesIsMutable();
          subnetworkStackTypes_.addAll(other.subnetworkStackTypes_);
        }
        onChanged();
      }
      if (other.hasUnicast()) {
        unicast_ = other.unicast_;
        bitField1_ |= 0x00000020;
        onChanged();
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 88019986:
              {
                allowMulticast_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00008000;
                break;
              } // case 88019986
            case 431339890:
              {
                allowDefaultNicAttachment_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000080;
                break;
              } // case 431339890
            case 706008034:
              {
                allowMultiNicInSameNetwork_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00002000;
                break;
              } // case 706008034
            case 923217826:
              {
                allowVpcPeering_ = input.readStringRequireUtf8();
                bitField0_ |= 0x04000000;
                break;
              } // case 923217826
            case 1052304882:
              {
                allowExternalIpAccess_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000100;
                break;
              } // case 1052304882
            case 1052871898:
              {
                allowClassDFirewalls_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 1052871898
            case 1217530106:
              {
                allowAutoModeSubnet_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 1217530106
            case 1263849370:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureInterfaceTypesIsMutable();
                interfaceTypes_.add(s);
                break;
              } // case 1263849370
            case 1340253146:
              {
                allowSameNetworkUnicast_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00200000;
                break;
              } // case 1340253146
            case 1482063402:
              {
                allowStaticRoutes_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00400000;
                break;
              } // case 1482063402
            case 1786929586:
              {
                allowLoadBalancing_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00001000;
                break;
              } // case 1786929586
            case 1916705850:
              {
                allowNetworkMigration_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00020000;
                break;
              } // case 1916705850
            case 1977666426:
              {
                allowSubInterfaces_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00800000;
                break;
              } // case 1977666426
            case 1998733690:
              {
                unicast_ = input.readStringRequireUtf8();
                bitField1_ |= 0x00000020;
                break;
              } // case 1998733690
            case 2033607386:
              {
                allowFirewallPolicy_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000200;
                break;
              } // case 2033607386
            case 2038650122:
              {
                allowCloudNat_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000020;
                break;
              } // case 2038650122
            case -2070264062:
              {
                allowMultiNicInSameSubnetwork_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00004000;
                break;
              } // case -2070264062
            case -2050863582:
              {
                allowInterconnect_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000400;
                break;
              } // case -2050863582
            case -1884262982:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetPurposesIsMutable();
                subnetPurposes_.add(s);
                break;
              } // case -1884262982
            case -1316128062:
              {
                allowNcc_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00010000;
                break;
              } // case -1316128062
            case -1316108718:
              {
                allowPsc_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00100000;
                break;
              } // case -1316108718
            case -1316063246:
              {
                allowVpn_ = input.readStringRequireUtf8();
                bitField0_ |= 0x08000000;
                break;
              } // case -1316063246
            case -1297350718:
              {
                allowPrivateGoogleAccess_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00080000;
                break;
              } // case -1297350718
            case -1169031078:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureFirewallPolicyTypesIsMutable();
                firewallPolicyTypes_.add(s);
                break;
              } // case -1169031078
            case -1062182974:
              {
                multicast_ = input.readStringRequireUtf8();
                bitField0_ |= 0x40000000;
                break;
              } // case -1062182974
            case -1025043854:
              {
                com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                    m =
                        input.readMessage(
                            com.google.cloud.compute.v1
                                .NetworkProfileNetworkFeaturesPredefinedSubnetworkRange.parser(),
                            extensionRegistry);
                if (predefinedSubnetworkRangesBuilder_ == null) {
                  ensurePredefinedSubnetworkRangesIsMutable();
                  predefinedSubnetworkRanges_.add(m);
                } else {
                  predefinedSubnetworkRangesBuilder_.addMessage(m);
                }
                break;
              } // case -1025043854
            case -830769150:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureAddressPurposesIsMutable();
                addressPurposes_.add(s);
                break;
              } // case -830769150
            case -800347766:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetworkStackTypesIsMutable();
                subnetworkStackTypes_.add(s);
                break;
              } // case -800347766
            case -687437822:
              {
                allowAddressCreation_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case -687437822
            case -686084534:
              {
                allowCloudRouter_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000040;
                break;
              } // case -686084534
            case -631093686:
              {
                allowAliasIpRanges_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case -631093686
            case -620343086:
              {
                allowSubnetworkCreation_ = input.readStringRequireUtf8();
                bitField0_ |= 0x01000000;
                break;
              } // case -620343086
            case -288262918:
              {
                allowIpForwarding_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000800;
                break;
              } // case -288262918
            case -222355934:
              {
                allowVpcFirewallRules_ = input.readStringRequireUtf8();
                bitField0_ |= 0x02000000;
                break;
              } // case -222355934
            case -197150702:
              {
                allowPacketMirroring_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00040000;
                break;
              } // case -197150702
            case -126897918:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetStackTypesIsMutable();
                subnetStackTypes_.add(s);
                break;
              } // case -126897918
            case -72480022:
              {
                predefinedNetworkInternalIpv6Range_ = input.readStringRequireUtf8();
                bitField0_ |= 0x80000000;
                break;
              } // case -72480022
            case -69041614:
              {
                java.lang.String s = input.readStringRequireUtf8();
                ensureSubnetworkPurposesIsMutable();
                subnetworkPurposes_.add(s);
                break;
              } // case -69041614
            default:
              {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }

    private int bitField0_;
    private int bitField1_;

    private com.google.protobuf.LazyStringArrayList addressPurposes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureAddressPurposesIsMutable() {
      if (!addressPurposes_.isModifiable()) {
        addressPurposes_ = new com.google.protobuf.LazyStringArrayList(addressPurposes_);
      }
      bitField0_ |= 0x00000001;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return A list containing the addressPurposes.
     */
    public com.google.protobuf.ProtocolStringList getAddressPurposesList() {
      addressPurposes_.makeImmutable();
      return addressPurposes_;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return The count of addressPurposes.
     */
    public int getAddressPurposesCount() {
      return addressPurposes_.size();
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index of the element to return.
     * @return The addressPurposes at the given index.
     */
    public java.lang.String getAddressPurposes(int index) {
      return addressPurposes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the addressPurposes at the given index.
     */
    public com.google.protobuf.ByteString getAddressPurposesBytes(int index) {
      return addressPurposes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param index The index to set the value at.
     * @param value The addressPurposes to set.
     * @return This builder for chaining.
     */
    public Builder setAddressPurposes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAddressPurposesIsMutable();
      addressPurposes_.set(index, value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param value The addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAddressPurposes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAddressPurposesIsMutable();
      addressPurposes_.add(value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param values The addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAllAddressPurposes(java.lang.Iterable<java.lang.String> values) {
      ensureAddressPurposesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, addressPurposes_);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAddressPurposes() {
      addressPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x00000001);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies what address purposes are supported. If empty, all address
     * purposes are supported.
     * Check the AddressPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string address_purposes = 433024768;</code>
     *
     * @param value The bytes of the addressPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAddressPurposesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureAddressPurposesIsMutable();
      addressPurposes_.add(value);
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    private java.lang.Object allowAddressCreation_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @return Whether the allowAddressCreation field is set.
     */
    public boolean hasAllowAddressCreation() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @return The allowAddressCreation.
     */
    public java.lang.String getAllowAddressCreation() {
      java.lang.Object ref = allowAddressCreation_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowAddressCreation_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @return The bytes for allowAddressCreation.
     */
    public com.google.protobuf.ByteString getAllowAddressCreationBytes() {
      java.lang.Object ref = allowAddressCreation_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowAddressCreation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @param value The allowAddressCreation to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAddressCreation(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowAddressCreation_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowAddressCreation() {
      allowAddressCreation_ = getDefaultInstance().getAllowAddressCreation();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether address creation is allowed.
     * Check the AllowAddressCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_address_creation = 450941184;</code>
     *
     * @param value The bytes for allowAddressCreation to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAddressCreationBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowAddressCreation_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    private java.lang.Object allowAliasIpRanges_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return Whether the allowAliasIpRanges field is set.
     */
    public boolean hasAllowAliasIpRanges() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return The allowAliasIpRanges.
     */
    public java.lang.String getAllowAliasIpRanges() {
      java.lang.Object ref = allowAliasIpRanges_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowAliasIpRanges_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return The bytes for allowAliasIpRanges.
     */
    public com.google.protobuf.ByteString getAllowAliasIpRangesBytes() {
      java.lang.Object ref = allowAliasIpRanges_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowAliasIpRanges_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @param value The allowAliasIpRanges to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAliasIpRanges(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowAliasIpRanges_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowAliasIpRanges() {
      allowAliasIpRanges_ = getDefaultInstance().getAllowAliasIpRanges();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether alias IP ranges (and secondary address ranges) are
     * allowed.
     * Check the AllowAliasIpRanges enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_alias_ip_ranges = 457984201;</code>
     *
     * @param value The bytes for allowAliasIpRanges to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAliasIpRangesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowAliasIpRanges_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    private java.lang.Object allowAutoModeSubnet_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return Whether the allowAutoModeSubnet field is set.
     */
    public boolean hasAllowAutoModeSubnet() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return The allowAutoModeSubnet.
     */
    public java.lang.String getAllowAutoModeSubnet() {
      java.lang.Object ref = allowAutoModeSubnet_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowAutoModeSubnet_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return The bytes for allowAutoModeSubnet.
     */
    public com.google.protobuf.ByteString getAllowAutoModeSubnetBytes() {
      java.lang.Object ref = allowAutoModeSubnet_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowAutoModeSubnet_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @param value The allowAutoModeSubnet to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAutoModeSubnet(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowAutoModeSubnet_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowAutoModeSubnet() {
      allowAutoModeSubnet_ = getDefaultInstance().getAllowAutoModeSubnet();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether auto mode subnet creation is allowed.
     * Check the AllowAutoModeSubnet enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_auto_mode_subnet = 152191263;</code>
     *
     * @param value The bytes for allowAutoModeSubnet to set.
     * @return This builder for chaining.
     */
    public Builder setAllowAutoModeSubnetBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowAutoModeSubnet_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    private java.lang.Object allowClassDFirewalls_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return Whether the allowClassDFirewalls field is set.
     */
    public boolean hasAllowClassDFirewalls() {
      return ((bitField0_ & 0x00000010) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return The allowClassDFirewalls.
     */
    public java.lang.String getAllowClassDFirewalls() {
      java.lang.Object ref = allowClassDFirewalls_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowClassDFirewalls_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return The bytes for allowClassDFirewalls.
     */
    public com.google.protobuf.ByteString getAllowClassDFirewallsBytes() {
      java.lang.Object ref = allowClassDFirewalls_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowClassDFirewalls_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @param value The allowClassDFirewalls to set.
     * @return This builder for chaining.
     */
    public Builder setAllowClassDFirewalls(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowClassDFirewalls_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowClassDFirewalls() {
      allowClassDFirewalls_ = getDefaultInstance().getAllowClassDFirewalls();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewalls for Class D address ranges are supported.
     * Check the AllowClassDFirewalls enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_class_d_firewalls = 131608987;</code>
     *
     * @param value The bytes for allowClassDFirewalls to set.
     * @return This builder for chaining.
     */
    public Builder setAllowClassDFirewallsBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowClassDFirewalls_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    private java.lang.Object allowCloudNat_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return Whether the allowCloudNat field is set.
     */
    public boolean hasAllowCloudNat() {
      return ((bitField0_ & 0x00000020) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return The allowCloudNat.
     */
    public java.lang.String getAllowCloudNat() {
      java.lang.Object ref = allowCloudNat_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowCloudNat_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return The bytes for allowCloudNat.
     */
    public com.google.protobuf.ByteString getAllowCloudNatBytes() {
      java.lang.Object ref = allowCloudNat_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowCloudNat_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @param value The allowCloudNat to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudNat(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowCloudNat_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowCloudNat() {
      allowCloudNat_ = getDefaultInstance().getAllowCloudNat();
      bitField0_ = (bitField0_ & ~0x00000020);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud NAT creation is allowed.
     * Check the AllowCloudNat enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_nat = 254831265;</code>
     *
     * @param value The bytes for allowCloudNat to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudNatBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowCloudNat_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    private java.lang.Object allowCloudRouter_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return Whether the allowCloudRouter field is set.
     */
    public boolean hasAllowCloudRouter() {
      return ((bitField0_ & 0x00000040) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return The allowCloudRouter.
     */
    public java.lang.String getAllowCloudRouter() {
      java.lang.Object ref = allowCloudRouter_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowCloudRouter_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return The bytes for allowCloudRouter.
     */
    public com.google.protobuf.ByteString getAllowCloudRouterBytes() {
      java.lang.Object ref = allowCloudRouter_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowCloudRouter_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @param value The allowCloudRouter to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudRouter(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowCloudRouter_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowCloudRouter() {
      allowCloudRouter_ = getDefaultInstance().getAllowCloudRouter();
      bitField0_ = (bitField0_ & ~0x00000040);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud router creation is allowed.
     * Check the AllowCloudRouter enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_cloud_router = 451110345;</code>
     *
     * @param value The bytes for allowCloudRouter to set.
     * @return This builder for chaining.
     */
    public Builder setAllowCloudRouterBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowCloudRouter_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    private java.lang.Object allowDefaultNicAttachment_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @return Whether the allowDefaultNicAttachment field is set.
     */
    public boolean hasAllowDefaultNicAttachment() {
      return ((bitField0_ & 0x00000080) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @return The allowDefaultNicAttachment.
     */
    public java.lang.String getAllowDefaultNicAttachment() {
      java.lang.Object ref = allowDefaultNicAttachment_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowDefaultNicAttachment_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @return The bytes for allowDefaultNicAttachment.
     */
    public com.google.protobuf.ByteString getAllowDefaultNicAttachmentBytes() {
      java.lang.Object ref = allowDefaultNicAttachment_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowDefaultNicAttachment_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @param value The allowDefaultNicAttachment to set.
     * @return This builder for chaining.
     */
    public Builder setAllowDefaultNicAttachment(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowDefaultNicAttachment_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowDefaultNicAttachment() {
      allowDefaultNicAttachment_ = getDefaultInstance().getAllowDefaultNicAttachment();
      bitField0_ = (bitField0_ & ~0x00000080);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether default NIC attachment is allowed.
     * Check the AllowDefaultNicAttachment enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_default_nic_attachment = 53917486;</code>
     *
     * @param value The bytes for allowDefaultNicAttachment to set.
     * @return This builder for chaining.
     */
    public Builder setAllowDefaultNicAttachmentBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowDefaultNicAttachment_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }

    private java.lang.Object allowExternalIpAccess_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return Whether the allowExternalIpAccess field is set.
     */
    public boolean hasAllowExternalIpAccess() {
      return ((bitField0_ & 0x00000100) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return The allowExternalIpAccess.
     */
    public java.lang.String getAllowExternalIpAccess() {
      java.lang.Object ref = allowExternalIpAccess_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowExternalIpAccess_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return The bytes for allowExternalIpAccess.
     */
    public com.google.protobuf.ByteString getAllowExternalIpAccessBytes() {
      java.lang.Object ref = allowExternalIpAccess_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowExternalIpAccess_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @param value The allowExternalIpAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowExternalIpAccess(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowExternalIpAccess_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowExternalIpAccess() {
      allowExternalIpAccess_ = getDefaultInstance().getAllowExternalIpAccess();
      bitField0_ = (bitField0_ & ~0x00000100);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VMs are allowed to have external IP access on network
     * interfaces connected to this VPC.
     * Check the AllowExternalIpAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_external_ip_access = 131538110;</code>
     *
     * @param value The bytes for allowExternalIpAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowExternalIpAccessBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowExternalIpAccess_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }

    private java.lang.Object allowFirewallPolicy_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @return Whether the allowFirewallPolicy field is set.
     */
    public boolean hasAllowFirewallPolicy() {
      return ((bitField0_ & 0x00000200) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @return The allowFirewallPolicy.
     */
    public java.lang.String getAllowFirewallPolicy() {
      java.lang.Object ref = allowFirewallPolicy_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowFirewallPolicy_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @return The bytes for allowFirewallPolicy.
     */
    public com.google.protobuf.ByteString getAllowFirewallPolicyBytes() {
      java.lang.Object ref = allowFirewallPolicy_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowFirewallPolicy_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @param value The allowFirewallPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setAllowFirewallPolicy(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowFirewallPolicy_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowFirewallPolicy() {
      allowFirewallPolicy_ = getDefaultInstance().getAllowFirewallPolicy();
      bitField0_ = (bitField0_ & ~0x00000200);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether firewall policy can be attached to the network.
     * Check the AllowFirewallPolicy enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_firewall_policy = 254200923;</code>
     *
     * @param value The bytes for allowFirewallPolicy to set.
     * @return This builder for chaining.
     */
    public Builder setAllowFirewallPolicyBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowFirewallPolicy_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }

    private java.lang.Object allowInterconnect_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return Whether the allowInterconnect field is set.
     */
    public boolean hasAllowInterconnect() {
      return ((bitField0_ & 0x00000400) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return The allowInterconnect.
     */
    public java.lang.String getAllowInterconnect() {
      java.lang.Object ref = allowInterconnect_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowInterconnect_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return The bytes for allowInterconnect.
     */
    public com.google.protobuf.ByteString getAllowInterconnectBytes() {
      java.lang.Object ref = allowInterconnect_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowInterconnect_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @param value The allowInterconnect to set.
     * @return This builder for chaining.
     */
    public Builder setAllowInterconnect(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowInterconnect_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowInterconnect() {
      allowInterconnect_ = getDefaultInstance().getAllowInterconnect();
      bitField0_ = (bitField0_ & ~0x00000400);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Cloud Interconnect creation is allowed.
     * Check the AllowInterconnect enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_interconnect = 280512964;</code>
     *
     * @param value The bytes for allowInterconnect to set.
     * @return This builder for chaining.
     */
    public Builder setAllowInterconnectBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowInterconnect_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }

    private java.lang.Object allowIpForwarding_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @return Whether the allowIpForwarding field is set.
     */
    public boolean hasAllowIpForwarding() {
      return ((bitField0_ & 0x00000800) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @return The allowIpForwarding.
     */
    public java.lang.String getAllowIpForwarding() {
      java.lang.Object ref = allowIpForwarding_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowIpForwarding_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @return The bytes for allowIpForwarding.
     */
    public com.google.protobuf.ByteString getAllowIpForwardingBytes() {
      java.lang.Object ref = allowIpForwarding_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowIpForwarding_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @param value The allowIpForwarding to set.
     * @return This builder for chaining.
     */
    public Builder setAllowIpForwarding(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowIpForwarding_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowIpForwarding() {
      allowIpForwarding_ = getDefaultInstance().getAllowIpForwarding();
      bitField0_ = (bitField0_ & ~0x00000800);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether IP forwarding is allowed.
     * Check the AllowIpForwarding enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ip_forwarding = 500838047;</code>
     *
     * @param value The bytes for allowIpForwarding to set.
     * @return This builder for chaining.
     */
    public Builder setAllowIpForwardingBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowIpForwarding_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }

    private java.lang.Object allowLoadBalancing_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return Whether the allowLoadBalancing field is set.
     */
    public boolean hasAllowLoadBalancing() {
      return ((bitField0_ & 0x00001000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return The allowLoadBalancing.
     */
    public java.lang.String getAllowLoadBalancing() {
      java.lang.Object ref = allowLoadBalancing_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowLoadBalancing_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return The bytes for allowLoadBalancing.
     */
    public com.google.protobuf.ByteString getAllowLoadBalancingBytes() {
      java.lang.Object ref = allowLoadBalancing_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowLoadBalancing_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @param value The allowLoadBalancing to set.
     * @return This builder for chaining.
     */
    public Builder setAllowLoadBalancing(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowLoadBalancing_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowLoadBalancing() {
      allowLoadBalancing_ = getDefaultInstance().getAllowLoadBalancing();
      bitField0_ = (bitField0_ & ~0x00001000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether cloud load balancing is allowed.
     * Check the AllowLoadBalancing enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_load_balancing = 223366198;</code>
     *
     * @param value The bytes for allowLoadBalancing to set.
     * @return This builder for chaining.
     */
    public Builder setAllowLoadBalancingBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowLoadBalancing_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }

    private java.lang.Object allowMultiNicInSameNetwork_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return Whether the allowMultiNicInSameNetwork field is set.
     */
    public boolean hasAllowMultiNicInSameNetwork() {
      return ((bitField0_ & 0x00002000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return The allowMultiNicInSameNetwork.
     */
    public java.lang.String getAllowMultiNicInSameNetwork() {
      java.lang.Object ref = allowMultiNicInSameNetwork_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowMultiNicInSameNetwork_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return The bytes for allowMultiNicInSameNetwork.
     */
    public com.google.protobuf.ByteString getAllowMultiNicInSameNetworkBytes() {
      java.lang.Object ref = allowMultiNicInSameNetwork_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowMultiNicInSameNetwork_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @param value The allowMultiNicInSameNetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameNetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowMultiNicInSameNetwork_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowMultiNicInSameNetwork() {
      allowMultiNicInSameNetwork_ = getDefaultInstance().getAllowMultiNicInSameNetwork();
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same network is allowed.
     * Check the AllowMultiNicInSameNetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_network = 88251004;</code>
     *
     * @param value The bytes for allowMultiNicInSameNetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameNetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowMultiNicInSameNetwork_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }

    private java.lang.Object allowMultiNicInSameSubnetwork_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @return Whether the allowMultiNicInSameSubnetwork field is set.
     */
    public boolean hasAllowMultiNicInSameSubnetwork() {
      return ((bitField0_ & 0x00004000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @return The allowMultiNicInSameSubnetwork.
     */
    public java.lang.String getAllowMultiNicInSameSubnetwork() {
      java.lang.Object ref = allowMultiNicInSameSubnetwork_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowMultiNicInSameSubnetwork_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @return The bytes for allowMultiNicInSameSubnetwork.
     */
    public com.google.protobuf.ByteString getAllowMultiNicInSameSubnetworkBytes() {
      java.lang.Object ref = allowMultiNicInSameSubnetwork_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowMultiNicInSameSubnetwork_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @param value The allowMultiNicInSameSubnetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameSubnetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowMultiNicInSameSubnetwork_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowMultiNicInSameSubnetwork() {
      allowMultiNicInSameSubnetwork_ = getDefaultInstance().getAllowMultiNicInSameSubnetwork();
      bitField0_ = (bitField0_ & ~0x00004000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multi-nic in the same subnetwork is allowed.
     * Check the AllowMultiNicInSameSubnetwork enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multi_nic_in_same_subnetwork = 278087904;</code>
     *
     * @param value The bytes for allowMultiNicInSameSubnetwork to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMultiNicInSameSubnetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowMultiNicInSameSubnetwork_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }

    private java.lang.Object allowMulticast_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @return Whether the allowMulticast field is set.
     */
    public boolean hasAllowMulticast() {
      return ((bitField0_ & 0x00008000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @return The allowMulticast.
     */
    public java.lang.String getAllowMulticast() {
      java.lang.Object ref = allowMulticast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowMulticast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @return The bytes for allowMulticast.
     */
    public com.google.protobuf.ByteString getAllowMulticastBytes() {
      java.lang.Object ref = allowMulticast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowMulticast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @param value The allowMulticast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMulticast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowMulticast_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowMulticast() {
      allowMulticast_ = getDefaultInstance().getAllowMulticast();
      bitField0_ = (bitField0_ & ~0x00008000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether multicast is allowed.
     * Check the AllowMulticast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_multicast = 11002498;</code>
     *
     * @param value The bytes for allowMulticast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowMulticastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowMulticast_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    private java.lang.Object allowNcc_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @return Whether the allowNcc field is set.
     */
    public boolean hasAllowNcc() {
      return ((bitField0_ & 0x00010000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @return The allowNcc.
     */
    public java.lang.String getAllowNcc() {
      java.lang.Object ref = allowNcc_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowNcc_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @return The bytes for allowNcc.
     */
    public com.google.protobuf.ByteString getAllowNccBytes() {
      java.lang.Object ref = allowNcc_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowNcc_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @param value The allowNcc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowNcc(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowNcc_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowNcc() {
      allowNcc_ = getDefaultInstance().getAllowNcc();
      bitField0_ = (bitField0_ & ~0x00010000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether NCC is allowed.
     * Check the AllowNcc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_ncc = 372354904;</code>
     *
     * @param value The bytes for allowNcc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowNccBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowNcc_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }

    private java.lang.Object allowNetworkMigration_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @return Whether the allowNetworkMigration field is set.
     */
    public boolean hasAllowNetworkMigration() {
      return ((bitField0_ & 0x00020000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @return The allowNetworkMigration.
     */
    public java.lang.String getAllowNetworkMigration() {
      java.lang.Object ref = allowNetworkMigration_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowNetworkMigration_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @return The bytes for allowNetworkMigration.
     */
    public com.google.protobuf.ByteString getAllowNetworkMigrationBytes() {
      java.lang.Object ref = allowNetworkMigration_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowNetworkMigration_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @param value The allowNetworkMigration to set.
     * @return This builder for chaining.
     */
    public Builder setAllowNetworkMigration(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowNetworkMigration_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowNetworkMigration() {
      allowNetworkMigration_ = getDefaultInstance().getAllowNetworkMigration();
      bitField0_ = (bitField0_ & ~0x00020000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VM network migration is allowed.
     * Check the AllowNetworkMigration enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_network_migration = 239588231;</code>
     *
     * @param value The bytes for allowNetworkMigration to set.
     * @return This builder for chaining.
     */
    public Builder setAllowNetworkMigrationBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowNetworkMigration_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }

    private java.lang.Object allowPacketMirroring_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return Whether the allowPacketMirroring field is set.
     */
    public boolean hasAllowPacketMirroring() {
      return ((bitField0_ & 0x00040000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return The allowPacketMirroring.
     */
    public java.lang.String getAllowPacketMirroring() {
      java.lang.Object ref = allowPacketMirroring_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPacketMirroring_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return The bytes for allowPacketMirroring.
     */
    public com.google.protobuf.ByteString getAllowPacketMirroringBytes() {
      java.lang.Object ref = allowPacketMirroring_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPacketMirroring_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @param value The allowPacketMirroring to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPacketMirroring(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPacketMirroring_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPacketMirroring() {
      allowPacketMirroring_ = getDefaultInstance().getAllowPacketMirroring();
      bitField0_ = (bitField0_ & ~0x00040000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether Packet Mirroring 1.0 is supported.
     * Check the AllowPacketMirroring enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_packet_mirroring = 512227074;</code>
     *
     * @param value The bytes for allowPacketMirroring to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPacketMirroringBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPacketMirroring_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }

    private java.lang.Object allowPrivateGoogleAccess_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return Whether the allowPrivateGoogleAccess field is set.
     */
    public boolean hasAllowPrivateGoogleAccess() {
      return ((bitField0_ & 0x00080000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return The allowPrivateGoogleAccess.
     */
    public java.lang.String getAllowPrivateGoogleAccess() {
      java.lang.Object ref = allowPrivateGoogleAccess_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPrivateGoogleAccess_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return The bytes for allowPrivateGoogleAccess.
     */
    public com.google.protobuf.ByteString getAllowPrivateGoogleAccessBytes() {
      java.lang.Object ref = allowPrivateGoogleAccess_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPrivateGoogleAccess_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @param value The allowPrivateGoogleAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPrivateGoogleAccess(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPrivateGoogleAccess_ = value;
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPrivateGoogleAccess() {
      allowPrivateGoogleAccess_ = getDefaultInstance().getAllowPrivateGoogleAccess();
      bitField0_ = (bitField0_ & ~0x00080000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether private Google access is allowed.
     * Check the AllowPrivateGoogleAccess enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_private_google_access = 374702072;</code>
     *
     * @param value The bytes for allowPrivateGoogleAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPrivateGoogleAccessBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPrivateGoogleAccess_ = value;
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }

    private java.lang.Object allowPsc_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return Whether the allowPsc field is set.
     */
    public boolean hasAllowPsc() {
      return ((bitField0_ & 0x00100000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return The allowPsc.
     */
    public java.lang.String getAllowPsc() {
      java.lang.Object ref = allowPsc_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowPsc_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return The bytes for allowPsc.
     */
    public com.google.protobuf.ByteString getAllowPscBytes() {
      java.lang.Object ref = allowPsc_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowPsc_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @param value The allowPsc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPsc(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowPsc_ = value;
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowPsc() {
      allowPsc_ = getDefaultInstance().getAllowPsc();
      bitField0_ = (bitField0_ & ~0x00100000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether PSC creation is allowed.
     * Check the AllowPsc enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_psc = 372357322;</code>
     *
     * @param value The bytes for allowPsc to set.
     * @return This builder for chaining.
     */
    public Builder setAllowPscBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowPsc_ = value;
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }

    private java.lang.Object allowSameNetworkUnicast_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return Whether the allowSameNetworkUnicast field is set.
     */
    public boolean hasAllowSameNetworkUnicast() {
      return ((bitField0_ & 0x00200000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return The allowSameNetworkUnicast.
     */
    public java.lang.String getAllowSameNetworkUnicast() {
      java.lang.Object ref = allowSameNetworkUnicast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowSameNetworkUnicast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return The bytes for allowSameNetworkUnicast.
     */
    public com.google.protobuf.ByteString getAllowSameNetworkUnicastBytes() {
      java.lang.Object ref = allowSameNetworkUnicast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowSameNetworkUnicast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @param value The allowSameNetworkUnicast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSameNetworkUnicast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowSameNetworkUnicast_ = value;
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowSameNetworkUnicast() {
      allowSameNetworkUnicast_ = getDefaultInstance().getAllowSameNetworkUnicast();
      bitField0_ = (bitField0_ & ~0x00200000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether unicast within the same network is allowed.
     * Check the AllowSameNetworkUnicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_same_network_unicast = 167531643;</code>
     *
     * @param value The bytes for allowSameNetworkUnicast to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSameNetworkUnicastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowSameNetworkUnicast_ = value;
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }

    private java.lang.Object allowStaticRoutes_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return Whether the allowStaticRoutes field is set.
     */
    public boolean hasAllowStaticRoutes() {
      return ((bitField0_ & 0x00400000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return The allowStaticRoutes.
     */
    public java.lang.String getAllowStaticRoutes() {
      java.lang.Object ref = allowStaticRoutes_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowStaticRoutes_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return The bytes for allowStaticRoutes.
     */
    public com.google.protobuf.ByteString getAllowStaticRoutesBytes() {
      java.lang.Object ref = allowStaticRoutes_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowStaticRoutes_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @param value The allowStaticRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setAllowStaticRoutes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowStaticRoutes_ = value;
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowStaticRoutes() {
      allowStaticRoutes_ = getDefaultInstance().getAllowStaticRoutes();
      bitField0_ = (bitField0_ & ~0x00400000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether static route creation is allowed.
     * Check the AllowStaticRoutes enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_static_routes = 185257925;</code>
     *
     * @param value The bytes for allowStaticRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setAllowStaticRoutesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowStaticRoutes_ = value;
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }

    private java.lang.Object allowSubInterfaces_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return Whether the allowSubInterfaces field is set.
     */
    public boolean hasAllowSubInterfaces() {
      return ((bitField0_ & 0x00800000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return The allowSubInterfaces.
     */
    public java.lang.String getAllowSubInterfaces() {
      java.lang.Object ref = allowSubInterfaces_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowSubInterfaces_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return The bytes for allowSubInterfaces.
     */
    public com.google.protobuf.ByteString getAllowSubInterfacesBytes() {
      java.lang.Object ref = allowSubInterfaces_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowSubInterfaces_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @param value The allowSubInterfaces to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubInterfaces(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowSubInterfaces_ = value;
      bitField0_ |= 0x00800000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowSubInterfaces() {
      allowSubInterfaces_ = getDefaultInstance().getAllowSubInterfaces();
      bitField0_ = (bitField0_ & ~0x00800000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether sub interfaces are allowed.
     * Check the AllowSubInterfaces enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_sub_interfaces = 247208303;</code>
     *
     * @param value The bytes for allowSubInterfaces to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubInterfacesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowSubInterfaces_ = value;
      bitField0_ |= 0x00800000;
      onChanged();
      return this;
    }

    private java.lang.Object allowSubnetworkCreation_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @return Whether the allowSubnetworkCreation field is set.
     */
    public boolean hasAllowSubnetworkCreation() {
      return ((bitField0_ & 0x01000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @return The allowSubnetworkCreation.
     */
    public java.lang.String getAllowSubnetworkCreation() {
      java.lang.Object ref = allowSubnetworkCreation_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowSubnetworkCreation_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @return The bytes for allowSubnetworkCreation.
     */
    public com.google.protobuf.ByteString getAllowSubnetworkCreationBytes() {
      java.lang.Object ref = allowSubnetworkCreation_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowSubnetworkCreation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @param value The allowSubnetworkCreation to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubnetworkCreation(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowSubnetworkCreation_ = value;
      bitField0_ |= 0x01000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowSubnetworkCreation() {
      allowSubnetworkCreation_ = getDefaultInstance().getAllowSubnetworkCreation();
      bitField0_ = (bitField0_ & ~0x01000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether subnetwork creation is allowed.
     * Check the AllowSubnetworkCreation enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_subnetwork_creation = 459328026;</code>
     *
     * @param value The bytes for allowSubnetworkCreation to set.
     * @return This builder for chaining.
     */
    public Builder setAllowSubnetworkCreationBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowSubnetworkCreation_ = value;
      bitField0_ |= 0x01000000;
      onChanged();
      return this;
    }

    private java.lang.Object allowVpcFirewallRules_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @return Whether the allowVpcFirewallRules field is set.
     */
    public boolean hasAllowVpcFirewallRules() {
      return ((bitField0_ & 0x02000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @return The allowVpcFirewallRules.
     */
    public java.lang.String getAllowVpcFirewallRules() {
      java.lang.Object ref = allowVpcFirewallRules_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowVpcFirewallRules_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @return The bytes for allowVpcFirewallRules.
     */
    public com.google.protobuf.ByteString getAllowVpcFirewallRulesBytes() {
      java.lang.Object ref = allowVpcFirewallRules_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowVpcFirewallRules_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @param value The allowVpcFirewallRules to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcFirewallRules(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowVpcFirewallRules_ = value;
      bitField0_ |= 0x02000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowVpcFirewallRules() {
      allowVpcFirewallRules_ = getDefaultInstance().getAllowVpcFirewallRules();
      bitField0_ = (bitField0_ & ~0x02000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC firewall rules can be created under the network.
     * Check the AllowVpcFirewallRules enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_firewall_rules = 509076420;</code>
     *
     * @param value The bytes for allowVpcFirewallRules to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcFirewallRulesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowVpcFirewallRules_ = value;
      bitField0_ |= 0x02000000;
      onChanged();
      return this;
    }

    private java.lang.Object allowVpcPeering_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return Whether the allowVpcPeering field is set.
     */
    public boolean hasAllowVpcPeering() {
      return ((bitField0_ & 0x04000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return The allowVpcPeering.
     */
    public java.lang.String getAllowVpcPeering() {
      java.lang.Object ref = allowVpcPeering_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowVpcPeering_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return The bytes for allowVpcPeering.
     */
    public com.google.protobuf.ByteString getAllowVpcPeeringBytes() {
      java.lang.Object ref = allowVpcPeering_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowVpcPeering_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @param value The allowVpcPeering to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcPeering(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowVpcPeering_ = value;
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowVpcPeering() {
      allowVpcPeering_ = getDefaultInstance().getAllowVpcPeering();
      bitField0_ = (bitField0_ & ~0x04000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPC peering is allowed.
     * Check the AllowVpcPeering enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpc_peering = 115402228;</code>
     *
     * @param value The bytes for allowVpcPeering to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpcPeeringBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowVpcPeering_ = value;
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }

    private java.lang.Object allowVpn_ = "";

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return Whether the allowVpn field is set.
     */
    public boolean hasAllowVpn() {
      return ((bitField0_ & 0x08000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return The allowVpn.
     */
    public java.lang.String getAllowVpn() {
      java.lang.Object ref = allowVpn_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        allowVpn_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return The bytes for allowVpn.
     */
    public com.google.protobuf.ByteString getAllowVpnBytes() {
      java.lang.Object ref = allowVpn_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        allowVpn_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @param value The allowVpn to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpn(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      allowVpn_ = value;
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowVpn() {
      allowVpn_ = getDefaultInstance().getAllowVpn();
      bitField0_ = (bitField0_ & ~0x08000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies whether VPN creation is allowed.
     * Check the AllowVpn enum for the list of possible values.
     * </pre>
     *
     * <code>optional string allow_vpn = 372363006;</code>
     *
     * @param value The bytes for allowVpn to set.
     * @return This builder for chaining.
     */
    public Builder setAllowVpnBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      allowVpn_ = value;
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList firewallPolicyTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureFirewallPolicyTypesIsMutable() {
      if (!firewallPolicyTypes_.isModifiable()) {
        firewallPolicyTypes_ = new com.google.protobuf.LazyStringArrayList(firewallPolicyTypes_);
      }
      bitField0_ |= 0x10000000;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @return A list containing the firewallPolicyTypes.
     */
    public com.google.protobuf.ProtocolStringList getFirewallPolicyTypesList() {
      firewallPolicyTypes_.makeImmutable();
      return firewallPolicyTypes_;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @return The count of firewallPolicyTypes.
     */
    public int getFirewallPolicyTypesCount() {
      return firewallPolicyTypes_.size();
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param index The index of the element to return.
     * @return The firewallPolicyTypes at the given index.
     */
    public java.lang.String getFirewallPolicyTypes(int index) {
      return firewallPolicyTypes_.get(index);
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the firewallPolicyTypes at the given index.
     */
    public com.google.protobuf.ByteString getFirewallPolicyTypesBytes(int index) {
      return firewallPolicyTypes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param index The index to set the value at.
     * @param value The firewallPolicyTypes to set.
     * @return This builder for chaining.
     */
    public Builder setFirewallPolicyTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureFirewallPolicyTypesIsMutable();
      firewallPolicyTypes_.set(index, value);
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param value The firewallPolicyTypes to add.
     * @return This builder for chaining.
     */
    public Builder addFirewallPolicyTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureFirewallPolicyTypesIsMutable();
      firewallPolicyTypes_.add(value);
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param values The firewallPolicyTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllFirewallPolicyTypes(java.lang.Iterable<java.lang.String> values) {
      ensureFirewallPolicyTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, firewallPolicyTypes_);
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearFirewallPolicyTypes() {
      firewallPolicyTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x10000000);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     *
     * Check the FirewallPolicyTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string firewall_policy_types = 390742027;</code>
     *
     * @param value The bytes of the firewallPolicyTypes to add.
     * @return This builder for chaining.
     */
    public Builder addFirewallPolicyTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureFirewallPolicyTypesIsMutable();
      firewallPolicyTypes_.add(value);
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList interfaceTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureInterfaceTypesIsMutable() {
      if (!interfaceTypes_.isModifiable()) {
        interfaceTypes_ = new com.google.protobuf.LazyStringArrayList(interfaceTypes_);
      }
      bitField0_ |= 0x20000000;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return A list containing the interfaceTypes.
     */
    public com.google.protobuf.ProtocolStringList getInterfaceTypesList() {
      interfaceTypes_.makeImmutable();
      return interfaceTypes_;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return The count of interfaceTypes.
     */
    public int getInterfaceTypesCount() {
      return interfaceTypes_.size();
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index of the element to return.
     * @return The interfaceTypes at the given index.
     */
    public java.lang.String getInterfaceTypes(int index) {
      return interfaceTypes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the interfaceTypes at the given index.
     */
    public com.google.protobuf.ByteString getInterfaceTypesBytes(int index) {
      return interfaceTypes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param index The index to set the value at.
     * @param value The interfaceTypes to set.
     * @return This builder for chaining.
     */
    public Builder setInterfaceTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.set(index, value);
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param value The interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addInterfaceTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.add(value);
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param values The interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllInterfaceTypes(java.lang.Iterable<java.lang.String> values) {
      ensureInterfaceTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, interfaceTypes_);
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearInterfaceTypes() {
      interfaceTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField0_ = (bitField0_ & ~0x20000000);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * If set, limits the interface types that the network supports. If
     * empty, all interface types are supported.
     * Check the InterfaceTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string interface_types = 157981171;</code>
     *
     * @param value The bytes of the interfaceTypes to add.
     * @return This builder for chaining.
     */
    public Builder addInterfaceTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureInterfaceTypesIsMutable();
      interfaceTypes_.add(value);
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }

    private java.lang.Object multicast_ = "";

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @return Whether the multicast field is set.
     */
    public boolean hasMulticast() {
      return ((bitField0_ & 0x40000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @return The multicast.
     */
    public java.lang.String getMulticast() {
      java.lang.Object ref = multicast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        multicast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @return The bytes for multicast.
     */
    public com.google.protobuf.ByteString getMulticastBytes() {
      java.lang.Object ref = multicast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        multicast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @param value The multicast to set.
     * @return This builder for chaining.
     */
    public Builder setMulticast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      multicast_ = value;
      bitField0_ |= 0x40000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMulticast() {
      multicast_ = getDefaultInstance().getMulticast();
      bitField0_ = (bitField0_ & ~0x40000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of multicast is supported.
     * Check the Multicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string multicast = 404098040;</code>
     *
     * @param value The bytes for multicast to set.
     * @return This builder for chaining.
     */
    public Builder setMulticastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      multicast_ = value;
      bitField0_ |= 0x40000000;
      onChanged();
      return this;
    }

    private java.lang.Object predefinedNetworkInternalIpv6Range_ = "";

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @return Whether the predefinedNetworkInternalIpv6Range field is set.
     */
    public boolean hasPredefinedNetworkInternalIpv6Range() {
      return ((bitField0_ & 0x80000000) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @return The predefinedNetworkInternalIpv6Range.
     */
    public java.lang.String getPredefinedNetworkInternalIpv6Range() {
      java.lang.Object ref = predefinedNetworkInternalIpv6Range_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        predefinedNetworkInternalIpv6Range_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @return The bytes for predefinedNetworkInternalIpv6Range.
     */
    public com.google.protobuf.ByteString getPredefinedNetworkInternalIpv6RangeBytes() {
      java.lang.Object ref = predefinedNetworkInternalIpv6Range_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        predefinedNetworkInternalIpv6Range_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @param value The predefinedNetworkInternalIpv6Range to set.
     * @return This builder for chaining.
     */
    public Builder setPredefinedNetworkInternalIpv6Range(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      predefinedNetworkInternalIpv6Range_ = value;
      bitField0_ |= 0x80000000;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPredefinedNetworkInternalIpv6Range() {
      predefinedNetworkInternalIpv6Range_ =
          getDefaultInstance().getPredefinedNetworkInternalIpv6Range();
      bitField0_ = (bitField0_ & ~0x80000000);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies a predefined internal IPv6 range for the network.
     * </pre>
     *
     * <code>optional string predefined_network_internal_ipv6_range = 527810909;</code>
     *
     * @param value The bytes for predefinedNetworkInternalIpv6Range to set.
     * @return This builder for chaining.
     */
    public Builder setPredefinedNetworkInternalIpv6RangeBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      predefinedNetworkInternalIpv6Range_ = value;
      bitField0_ |= 0x80000000;
      onChanged();
      return this;
    }

    private java.util.List<
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>
        predefinedSubnetworkRanges_ = java.util.Collections.emptyList();

    private void ensurePredefinedSubnetworkRangesIsMutable() {
      if (!((bitField1_ & 0x00000001) != 0)) {
        predefinedSubnetworkRanges_ =
            new java.util.ArrayList<
                com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>(
                predefinedSubnetworkRanges_);
        bitField1_ |= 0x00000001;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange,
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                .Builder,
            com.google.cloud.compute.v1
                .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder>
        predefinedSubnetworkRangesBuilder_;

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public java.util.List<
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>
        getPredefinedSubnetworkRangesList() {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(predefinedSubnetworkRanges_);
      } else {
        return predefinedSubnetworkRangesBuilder_.getMessageList();
      }
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public int getPredefinedSubnetworkRangesCount() {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        return predefinedSubnetworkRanges_.size();
      } else {
        return predefinedSubnetworkRangesBuilder_.getCount();
      }
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
        getPredefinedSubnetworkRanges(int index) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        return predefinedSubnetworkRanges_.get(index);
      } else {
        return predefinedSubnetworkRangesBuilder_.getMessage(index);
      }
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder setPredefinedSubnetworkRanges(
        int index,
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange value) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.set(index, value);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.setMessage(index, value);
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder setPredefinedSubnetworkRanges(
        int index,
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange.Builder
            builderForValue) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.set(index, builderForValue.build());
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder addPredefinedSubnetworkRanges(
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange value) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.add(value);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.addMessage(value);
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder addPredefinedSubnetworkRanges(
        int index,
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange value) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.add(index, value);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.addMessage(index, value);
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder addPredefinedSubnetworkRanges(
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange.Builder
            builderForValue) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.add(builderForValue.build());
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder addPredefinedSubnetworkRanges(
        int index,
        com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange.Builder
            builderForValue) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.add(index, builderForValue.build());
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder addAllPredefinedSubnetworkRanges(
        java.lang.Iterable<
                ? extends
                    com.google.cloud.compute.v1
                        .NetworkProfileNetworkFeaturesPredefinedSubnetworkRange>
            values) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        ensurePredefinedSubnetworkRangesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, predefinedSubnetworkRanges_);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.addAllMessages(values);
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder clearPredefinedSubnetworkRanges() {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        predefinedSubnetworkRanges_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000001);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.clear();
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public Builder removePredefinedSubnetworkRanges(int index) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        ensurePredefinedSubnetworkRangesIsMutable();
        predefinedSubnetworkRanges_.remove(index);
        onChanged();
      } else {
        predefinedSubnetworkRangesBuilder_.remove(index);
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
            .Builder
        getPredefinedSubnetworkRangesBuilder(int index) {
      return getPredefinedSubnetworkRangesFieldBuilder().getBuilder(index);
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public com.google.cloud.compute.v1
            .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder
        getPredefinedSubnetworkRangesOrBuilder(int index) {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        return predefinedSubnetworkRanges_.get(index);
      } else {
        return predefinedSubnetworkRangesBuilder_.getMessageOrBuilder(index);
      }
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public java.util.List<
            ? extends
                com.google.cloud.compute.v1
                    .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder>
        getPredefinedSubnetworkRangesOrBuilderList() {
      if (predefinedSubnetworkRangesBuilder_ != null) {
        return predefinedSubnetworkRangesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(predefinedSubnetworkRanges_);
      }
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
            .Builder
        addPredefinedSubnetworkRangesBuilder() {
      return getPredefinedSubnetworkRangesFieldBuilder()
          .addBuilder(
              com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                  .getDefaultInstance());
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
            .Builder
        addPredefinedSubnetworkRangesBuilder(int index) {
      return getPredefinedSubnetworkRangesFieldBuilder()
          .addBuilder(
              index,
              com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                  .getDefaultInstance());
    }

    /**
     *
     *
     * <pre>
     * Predefined subnetwork ranges for the network.
     * </pre>
     *
     * <code>
     * repeated .google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange predefined_subnetwork_ranges = 408740430;
     * </code>
     */
    public java.util.List<
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                .Builder>
        getPredefinedSubnetworkRangesBuilderList() {
      return getPredefinedSubnetworkRangesFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange,
            com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                .Builder,
            com.google.cloud.compute.v1
                .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder>
        getPredefinedSubnetworkRangesFieldBuilder() {
      if (predefinedSubnetworkRangesBuilder_ == null) {
        predefinedSubnetworkRangesBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange,
                com.google.cloud.compute.v1.NetworkProfileNetworkFeaturesPredefinedSubnetworkRange
                    .Builder,
                com.google.cloud.compute.v1
                    .NetworkProfileNetworkFeaturesPredefinedSubnetworkRangeOrBuilder>(
                predefinedSubnetworkRanges_,
                ((bitField1_ & 0x00000001) != 0),
                getParentForChildren(),
                isClean());
        predefinedSubnetworkRanges_ = null;
      }
      return predefinedSubnetworkRangesBuilder_;
    }

    private com.google.protobuf.LazyStringArrayList subnetPurposes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetPurposesIsMutable() {
      if (!subnetPurposes_.isModifiable()) {
        subnetPurposes_ = new com.google.protobuf.LazyStringArrayList(subnetPurposes_);
      }
      bitField1_ |= 0x00000002;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return A list containing the subnetPurposes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetPurposesList() {
      subnetPurposes_.makeImmutable();
      return subnetPurposes_;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return The count of subnetPurposes.
     */
    public int getSubnetPurposesCount() {
      return subnetPurposes_.size();
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetPurposes at the given index.
     */
    public java.lang.String getSubnetPurposes(int index) {
      return subnetPurposes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetPurposes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetPurposesBytes(int index) {
      return subnetPurposes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetPurposes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetPurposes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.set(index, value);
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param value The subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetPurposes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.add(value);
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param values The subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetPurposes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetPurposesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetPurposes_);
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetPurposes() {
      subnetPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField1_ = (bitField1_ & ~0x00000002);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork purposes are supported.
     * Check the SubnetPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_purposes = 301338039;</code>
     *
     * @param value The bytes of the subnetPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetPurposesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetPurposesIsMutable();
      subnetPurposes_.add(value);
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList subnetStackTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetStackTypesIsMutable() {
      if (!subnetStackTypes_.isModifiable()) {
        subnetStackTypes_ = new com.google.protobuf.LazyStringArrayList(subnetStackTypes_);
      }
      bitField1_ |= 0x00000004;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return A list containing the subnetStackTypes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetStackTypesList() {
      subnetStackTypes_.makeImmutable();
      return subnetStackTypes_;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return The count of subnetStackTypes.
     */
    public int getSubnetStackTypesCount() {
      return subnetStackTypes_.size();
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetStackTypes at the given index.
     */
    public java.lang.String getSubnetStackTypes(int index) {
      return subnetStackTypes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetStackTypes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetStackTypesBytes(int index) {
      return subnetStackTypes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetStackTypes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetStackTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.set(index, value);
      bitField1_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param value The subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetStackTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.add(value);
      bitField1_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param values The subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetStackTypes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetStackTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetStackTypes_);
      bitField1_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetStackTypes() {
      subnetStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField1_ = (bitField1_ & ~0x00000004);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which subnetwork stack types are supported.
     * Check the SubnetStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnet_stack_types = 521008672;</code>
     *
     * @param value The bytes of the subnetStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetStackTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetStackTypesIsMutable();
      subnetStackTypes_.add(value);
      bitField1_ |= 0x00000004;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList subnetworkPurposes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetworkPurposesIsMutable() {
      if (!subnetworkPurposes_.isModifiable()) {
        subnetworkPurposes_ = new com.google.protobuf.LazyStringArrayList(subnetworkPurposes_);
      }
      bitField1_ |= 0x00000008;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @return A list containing the subnetworkPurposes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetworkPurposesList() {
      subnetworkPurposes_.makeImmutable();
      return subnetworkPurposes_;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @return The count of subnetworkPurposes.
     */
    public int getSubnetworkPurposesCount() {
      return subnetworkPurposes_.size();
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetworkPurposes at the given index.
     */
    public java.lang.String getSubnetworkPurposes(int index) {
      return subnetworkPurposes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetworkPurposes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetworkPurposesBytes(int index) {
      return subnetworkPurposes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetworkPurposes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetworkPurposes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetworkPurposesIsMutable();
      subnetworkPurposes_.set(index, value);
      bitField1_ |= 0x00000008;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param value The subnetworkPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetworkPurposes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetworkPurposesIsMutable();
      subnetworkPurposes_.add(value);
      bitField1_ |= 0x00000008;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param values The subnetworkPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetworkPurposes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetworkPurposesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetworkPurposes_);
      bitField1_ |= 0x00000008;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetworkPurposes() {
      subnetworkPurposes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField1_ = (bitField1_ & ~0x00000008);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork purposes are supported.
     * Check the SubnetworkPurposes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_purposes = 528240710;</code>
     *
     * @param value The bytes of the subnetworkPurposes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetworkPurposesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetworkPurposesIsMutable();
      subnetworkPurposes_.add(value);
      bitField1_ |= 0x00000008;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringArrayList subnetworkStackTypes_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    private void ensureSubnetworkStackTypesIsMutable() {
      if (!subnetworkStackTypes_.isModifiable()) {
        subnetworkStackTypes_ = new com.google.protobuf.LazyStringArrayList(subnetworkStackTypes_);
      }
      bitField1_ |= 0x00000010;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @return A list containing the subnetworkStackTypes.
     */
    public com.google.protobuf.ProtocolStringList getSubnetworkStackTypesList() {
      subnetworkStackTypes_.makeImmutable();
      return subnetworkStackTypes_;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @return The count of subnetworkStackTypes.
     */
    public int getSubnetworkStackTypesCount() {
      return subnetworkStackTypes_.size();
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param index The index of the element to return.
     * @return The subnetworkStackTypes at the given index.
     */
    public java.lang.String getSubnetworkStackTypes(int index) {
      return subnetworkStackTypes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the subnetworkStackTypes at the given index.
     */
    public com.google.protobuf.ByteString getSubnetworkStackTypesBytes(int index) {
      return subnetworkStackTypes_.getByteString(index);
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param index The index to set the value at.
     * @param value The subnetworkStackTypes to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetworkStackTypes(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetworkStackTypesIsMutable();
      subnetworkStackTypes_.set(index, value);
      bitField1_ |= 0x00000010;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param value The subnetworkStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetworkStackTypes(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureSubnetworkStackTypesIsMutable();
      subnetworkStackTypes_.add(value);
      bitField1_ |= 0x00000010;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param values The subnetworkStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubnetworkStackTypes(java.lang.Iterable<java.lang.String> values) {
      ensureSubnetworkStackTypesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, subnetworkStackTypes_);
      bitField1_ |= 0x00000010;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetworkStackTypes() {
      subnetworkStackTypes_ = com.google.protobuf.LazyStringArrayList.emptyList();
      bitField1_ = (bitField1_ & ~0x00000010);
      ;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Output only. Specifies which subnetwork stack types are supported.
     * Check the SubnetworkStackTypes enum for the list of possible values.
     * </pre>
     *
     * <code>repeated string subnetwork_stack_types = 436827441;</code>
     *
     * @param value The bytes of the subnetworkStackTypes to add.
     * @return This builder for chaining.
     */
    public Builder addSubnetworkStackTypesBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensureSubnetworkStackTypesIsMutable();
      subnetworkStackTypes_.add(value);
      bitField1_ |= 0x00000010;
      onChanged();
      return this;
    }

    private java.lang.Object unicast_ = "";

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return Whether the unicast field is set.
     */
    public boolean hasUnicast() {
      return ((bitField1_ & 0x00000020) != 0);
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return The unicast.
     */
    public java.lang.String getUnicast() {
      java.lang.Object ref = unicast_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        unicast_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return The bytes for unicast.
     */
    public com.google.protobuf.ByteString getUnicastBytes() {
      java.lang.Object ref = unicast_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        unicast_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @param value The unicast to set.
     * @return This builder for chaining.
     */
    public Builder setUnicast(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      unicast_ = value;
      bitField1_ |= 0x00000020;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearUnicast() {
      unicast_ = getDefaultInstance().getUnicast();
      bitField1_ = (bitField1_ & ~0x00000020);
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies which type of unicast is supported.
     * Check the Unicast enum for the list of possible values.
     * </pre>
     *
     * <code>optional string unicast = 249841711;</code>
     *
     * @param value The bytes for unicast to set.
     * @return This builder for chaining.
     */
    public Builder setUnicastBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      unicast_ = value;
      bitField1_ |= 0x00000020;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.NetworkProfileNetworkFeatures)
  private static final com.google.cloud.compute.v1.NetworkProfileNetworkFeatures DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.NetworkProfileNetworkFeatures();
  }

  public static com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<NetworkProfileNetworkFeatures> PARSER =
      new com.google.protobuf.AbstractParser<NetworkProfileNetworkFeatures>() {
        @java.lang.Override
        public NetworkProfileNetworkFeatures parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

  public static com.google.protobuf.Parser<NetworkProfileNetworkFeatures> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<NetworkProfileNetworkFeatures> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkProfileNetworkFeatures getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
