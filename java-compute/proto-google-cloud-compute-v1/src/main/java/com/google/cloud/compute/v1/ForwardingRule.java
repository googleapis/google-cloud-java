/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * Represents a Forwarding Rule resource.
 * Forwarding rule resources in GCP can be either regional or global in scope:
 * * [Global](/compute/docs/reference/rest/{$api_version}/globalForwardingRules) * [Regional](/compute/docs/reference/rest/{$api_version}/forwardingRules)
 * A forwarding rule and its corresponding IP address represent the frontend configuration of a Google Cloud Platform load balancer. Forwarding rules can also reference target instances and Cloud VPN Classic gateways (targetVpnGateway).
 * For more information, read Forwarding rule concepts and Using protocol forwarding.
 * (== resource_for {$api_version}.forwardingRules ==) (== resource_for {$api_version}.globalForwardingRules ==) (== resource_for {$api_version}.regionForwardingRules ==)
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.ForwardingRule}
 */
public final class ForwardingRule extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.ForwardingRule)
    ForwardingRuleOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use ForwardingRule.newBuilder() to construct.
  private ForwardingRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private ForwardingRule() {
    iPAddress_ = "";
    iPProtocol_ = 0;
    backendService_ = "";
    creationTimestamp_ = "";
    description_ = "";
    fingerprint_ = "";
    id_ = "";
    ipVersion_ = 0;
    kind_ = "";
    loadBalancingScheme_ = 0;
    metadataFilters_ = java.util.Collections.emptyList();
    name_ = "";
    network_ = "";
    networkTier_ = 0;
    portRange_ = "";
    ports_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    region_ = "";
    selfLink_ = "";
    serviceLabel_ = "";
    serviceName_ = "";
    subnetwork_ = "";
    target_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new ForwardingRule();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private ForwardingRule(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 26842:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000100;
              id_ = s;
              break;
            }
          case 26336418:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000800;
              kind_ = s;
              break;
            }
          case 26989658:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00002000;
              name_ = s;
              break;
            }
          case 244202930:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000020;
              creationTimestamp_ = s;
              break;
            }
          case 343815546:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000001;
              iPAddress_ = s;
              break;
            }
          case 854835346:
            {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00040000) != 0)) {
                ports_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00040000;
              }
              ports_.add(s);
              break;
            }
          case 954041312:
            {
              bitField0_ |= 0x00000400;
              isMirroringCollector_ = input.readBool();
              break;
            }
          case 1111570338:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00020000;
              region_ = s;
              break;
            }
          case 1542687882:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00400000;
              target_ = s;
              break;
            }
          case 1740144634:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00010000;
              portRange_ = s;
              break;
            }
          case 1862979954:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00004000;
              network_ = s;
              break;
            }
          case 1877428002:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000080;
              fingerprint_ = s;
              break;
            }
          case -1935290880:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00000200;
              ipVersion_ = rawValue;
              break;
            }
          case -1839398830:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000010;
              backendService_ = s;
              break;
            }
          case -1832345742:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00200000;
              subnetwork_ = s;
              break;
            }
          case -1415926102:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00100000;
              serviceName_ = s;
              break;
            }
          case -1383845344:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00001000;
              loadBalancingScheme_ = rawValue;
              break;
            }
          case -958896302:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00080000;
              serviceLabel_ = s;
              break;
            }
          case -911466526:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00000040;
              description_ = s;
              break;
            }
          case -733560928:
            {
              bitField0_ |= 0x00000004;
              allPorts_ = input.readBool();
              break;
            }
          case -645248918:
            {
              java.lang.String s = input.readStringRequireUtf8();
              bitField0_ |= 0x00040000;
              selfLink_ = s;
              break;
            }
          case -577161382:
            {
              if (!((mutable_bitField0_ & 0x00002000) != 0)) {
                metadataFilters_ =
                    new java.util.ArrayList<com.google.cloud.compute.v1.MetadataFilter>();
                mutable_bitField0_ |= 0x00002000;
              }
              metadataFilters_.add(
                  input.readMessage(
                      com.google.cloud.compute.v1.MetadataFilter.parser(), extensionRegistry));
              break;
            }
          case -390211096:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00000002;
              iPProtocol_ = rawValue;
              break;
            }
          case -299689904:
            {
              bitField0_ |= 0x00000008;
              allowGlobalAccess_ = input.readBool();
              break;
            }
          case -155784552:
            {
              int rawValue = input.readEnum();
              bitField0_ |= 0x00008000;
              networkTier_ = rawValue;
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00040000) != 0)) {
        ports_ = ports_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00002000) != 0)) {
        metadataFilters_ = java.util.Collections.unmodifiableList(metadataFilters_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_ForwardingRule_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_ForwardingRule_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.ForwardingRule.class,
            com.google.cloud.compute.v1.ForwardingRule.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * The IP protocol to which this rule applies.
   * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
   * The valid IP protocols are different for different load balancing products:
   * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
   * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
   * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
   * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
   * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.ForwardingRule.IPProtocol}
   */
  public enum IPProtocol implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_I_P_PROTOCOL = 0;</code>
     */
    UNDEFINED_I_P_PROTOCOL(0),
    /** <code>AH = 2087;</code> */
    AH(2087),
    /** <code>ESP = 68962;</code> */
    ESP(68962),
    /** <code>ICMP = 2241597;</code> */
    ICMP(2241597),
    /** <code>SCTP = 2539724;</code> */
    SCTP(2539724),
    /** <code>TCP = 82881;</code> */
    TCP(82881),
    /** <code>UDP = 83873;</code> */
    UDP(83873),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_I_P_PROTOCOL = 0;</code>
     */
    public static final int UNDEFINED_I_P_PROTOCOL_VALUE = 0;
    /** <code>AH = 2087;</code> */
    public static final int AH_VALUE = 2087;
    /** <code>ESP = 68962;</code> */
    public static final int ESP_VALUE = 68962;
    /** <code>ICMP = 2241597;</code> */
    public static final int ICMP_VALUE = 2241597;
    /** <code>SCTP = 2539724;</code> */
    public static final int SCTP_VALUE = 2539724;
    /** <code>TCP = 82881;</code> */
    public static final int TCP_VALUE = 82881;
    /** <code>UDP = 83873;</code> */
    public static final int UDP_VALUE = 83873;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static IPProtocol valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static IPProtocol forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_I_P_PROTOCOL;
        case 2087:
          return AH;
        case 68962:
          return ESP;
        case 2241597:
          return ICMP;
        case 2539724:
          return SCTP;
        case 82881:
          return TCP;
        case 83873:
          return UDP;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<IPProtocol> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<IPProtocol> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<IPProtocol>() {
          public IPProtocol findValueByNumber(int number) {
            return IPProtocol.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.ForwardingRule.getDescriptor().getEnumTypes().get(0);
    }

    private static final IPProtocol[] VALUES = values();

    public static IPProtocol valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private IPProtocol(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.ForwardingRule.IPProtocol)
  }

  /**
   *
   *
   * <pre>
   * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.ForwardingRule.IpVersion}
   */
  public enum IpVersion implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_IP_VERSION = 0;</code>
     */
    UNDEFINED_IP_VERSION(0),
    /** <code>IPV4 = 2254341;</code> */
    IPV4(2254341),
    /** <code>IPV6 = 2254343;</code> */
    IPV6(2254343),
    /** <code>UNSPECIFIED_VERSION = 21850000;</code> */
    UNSPECIFIED_VERSION(21850000),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_IP_VERSION = 0;</code>
     */
    public static final int UNDEFINED_IP_VERSION_VALUE = 0;
    /** <code>IPV4 = 2254341;</code> */
    public static final int IPV4_VALUE = 2254341;
    /** <code>IPV6 = 2254343;</code> */
    public static final int IPV6_VALUE = 2254343;
    /** <code>UNSPECIFIED_VERSION = 21850000;</code> */
    public static final int UNSPECIFIED_VERSION_VALUE = 21850000;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static IpVersion valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static IpVersion forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_IP_VERSION;
        case 2254341:
          return IPV4;
        case 2254343:
          return IPV6;
        case 21850000:
          return UNSPECIFIED_VERSION;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<IpVersion> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<IpVersion> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<IpVersion>() {
          public IpVersion findValueByNumber(int number) {
            return IpVersion.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.ForwardingRule.getDescriptor().getEnumTypes().get(1);
    }

    private static final IpVersion[] VALUES = values();

    public static IpVersion valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private IpVersion(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.ForwardingRule.IpVersion)
  }

  /**
   *
   *
   * <pre>
   * Specifies the forwarding rule type.
   * - EXTERNAL is used for:
   * - Classic Cloud VPN gateways
   * - Protocol forwarding to VMs from an external IP address
   * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
   * - INTERNAL is used for:
   * - Protocol forwarding to VMs from an internal IP address
   * - Internal TCP/UDP Load Balancing
   * - INTERNAL_MANAGED is used for:
   * - Internal HTTP(S) Load Balancing
   * - INTERNAL_SELF_MANAGED is used for:
   * - Traffic Director
   * For more information about forwarding rules, refer to Forwarding rule concepts.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme}
   */
  public enum LoadBalancingScheme implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOAD_BALANCING_SCHEME = 0;</code>
     */
    UNDEFINED_LOAD_BALANCING_SCHEME(0),
    /** <code>EXTERNAL = 35607499;</code> */
    EXTERNAL(35607499),
    /** <code>INTERNAL = 279295677;</code> */
    INTERNAL(279295677),
    /** <code>INTERNAL_MANAGED = 37350397;</code> */
    INTERNAL_MANAGED(37350397),
    /** <code>INTERNAL_SELF_MANAGED = 236211150;</code> */
    INTERNAL_SELF_MANAGED(236211150),
    /** <code>INVALID = 530283991;</code> */
    INVALID(530283991),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_LOAD_BALANCING_SCHEME = 0;</code>
     */
    public static final int UNDEFINED_LOAD_BALANCING_SCHEME_VALUE = 0;
    /** <code>EXTERNAL = 35607499;</code> */
    public static final int EXTERNAL_VALUE = 35607499;
    /** <code>INTERNAL = 279295677;</code> */
    public static final int INTERNAL_VALUE = 279295677;
    /** <code>INTERNAL_MANAGED = 37350397;</code> */
    public static final int INTERNAL_MANAGED_VALUE = 37350397;
    /** <code>INTERNAL_SELF_MANAGED = 236211150;</code> */
    public static final int INTERNAL_SELF_MANAGED_VALUE = 236211150;
    /** <code>INVALID = 530283991;</code> */
    public static final int INVALID_VALUE = 530283991;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LoadBalancingScheme valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LoadBalancingScheme forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_LOAD_BALANCING_SCHEME;
        case 35607499:
          return EXTERNAL;
        case 279295677:
          return INTERNAL;
        case 37350397:
          return INTERNAL_MANAGED;
        case 236211150:
          return INTERNAL_SELF_MANAGED;
        case 530283991:
          return INVALID;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LoadBalancingScheme>() {
              public LoadBalancingScheme findValueByNumber(int number) {
                return LoadBalancingScheme.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.ForwardingRule.getDescriptor().getEnumTypes().get(2);
    }

    private static final LoadBalancingScheme[] VALUES = values();

    public static LoadBalancingScheme valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LoadBalancingScheme(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme)
  }

  /**
   *
   *
   * <pre>
   * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
   * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
   * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.ForwardingRule.NetworkTier}
   */
  public enum NetworkTier implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_NETWORK_TIER = 0;</code>
     */
    UNDEFINED_NETWORK_TIER(0),
    /** <code>PREMIUM = 399530551;</code> */
    PREMIUM(399530551),
    /** <code>STANDARD = 484642493;</code> */
    STANDARD(484642493),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_NETWORK_TIER = 0;</code>
     */
    public static final int UNDEFINED_NETWORK_TIER_VALUE = 0;
    /** <code>PREMIUM = 399530551;</code> */
    public static final int PREMIUM_VALUE = 399530551;
    /** <code>STANDARD = 484642493;</code> */
    public static final int STANDARD_VALUE = 484642493;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static NetworkTier valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static NetworkTier forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_NETWORK_TIER;
        case 399530551:
          return PREMIUM;
        case 484642493:
          return STANDARD;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<NetworkTier> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<NetworkTier> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<NetworkTier>() {
          public NetworkTier findValueByNumber(int number) {
            return NetworkTier.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.ForwardingRule.getDescriptor().getEnumTypes().get(3);
    }

    private static final NetworkTier[] VALUES = values();

    public static NetworkTier valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private NetworkTier(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.ForwardingRule.NetworkTier)
  }

  private int bitField0_;
  public static final int I_P_ADDRESS_FIELD_NUMBER = 42976943;
  private volatile java.lang.Object iPAddress_;
  /**
   *
   *
   * <pre>
   * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
   * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
   * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
   * - projects/project_id/regions/region/addresses/address-name
   * - regions/region/addresses/address-name
   * - global/addresses/address-name
   * - address-name
   * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
   * </pre>
   *
   * <code>string I_p_address = 42976943;</code>
   *
   * @return Whether the iPAddress field is set.
   */
  @java.lang.Override
  public boolean hasIPAddress() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   *
   *
   * <pre>
   * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
   * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
   * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
   * - projects/project_id/regions/region/addresses/address-name
   * - regions/region/addresses/address-name
   * - global/addresses/address-name
   * - address-name
   * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
   * </pre>
   *
   * <code>string I_p_address = 42976943;</code>
   *
   * @return The iPAddress.
   */
  @java.lang.Override
  public java.lang.String getIPAddress() {
    java.lang.Object ref = iPAddress_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      iPAddress_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
   * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
   * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
   * - projects/project_id/regions/region/addresses/address-name
   * - regions/region/addresses/address-name
   * - global/addresses/address-name
   * - address-name
   * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
   * </pre>
   *
   * <code>string I_p_address = 42976943;</code>
   *
   * @return The bytes for iPAddress.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getIPAddressBytes() {
    java.lang.Object ref = iPAddress_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      iPAddress_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int I_P_PROTOCOL_FIELD_NUMBER = 488094525;
  private int iPProtocol_;
  /**
   *
   *
   * <pre>
   * The IP protocol to which this rule applies.
   * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
   * The valid IP protocols are different for different load balancing products:
   * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
   * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
   * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
   * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
   * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
   *
   * @return Whether the iPProtocol field is set.
   */
  @java.lang.Override
  public boolean hasIPProtocol() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   *
   *
   * <pre>
   * The IP protocol to which this rule applies.
   * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
   * The valid IP protocols are different for different load balancing products:
   * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
   * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
   * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
   * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
   * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
   *
   * @return The enum numeric value on the wire for iPProtocol.
   */
  @java.lang.Override
  public int getIPProtocolValue() {
    return iPProtocol_;
  }
  /**
   *
   *
   * <pre>
   * The IP protocol to which this rule applies.
   * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
   * The valid IP protocols are different for different load balancing products:
   * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
   * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
   * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
   * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
   * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
   *
   * @return The iPProtocol.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ForwardingRule.IPProtocol getIPProtocol() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.ForwardingRule.IPProtocol result =
        com.google.cloud.compute.v1.ForwardingRule.IPProtocol.valueOf(iPProtocol_);
    return result == null
        ? com.google.cloud.compute.v1.ForwardingRule.IPProtocol.UNRECOGNIZED
        : result;
  }

  public static final int ALL_PORTS_FIELD_NUMBER = 445175796;
  private boolean allPorts_;
  /**
   *
   *
   * <pre>
   * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
   * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
   * </pre>
   *
   * <code>bool all_ports = 445175796;</code>
   *
   * @return Whether the allPorts field is set.
   */
  @java.lang.Override
  public boolean hasAllPorts() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
   * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
   * </pre>
   *
   * <code>bool all_ports = 445175796;</code>
   *
   * @return The allPorts.
   */
  @java.lang.Override
  public boolean getAllPorts() {
    return allPorts_;
  }

  public static final int ALLOW_GLOBAL_ACCESS_FIELD_NUMBER = 499409674;
  private boolean allowGlobalAccess_;
  /**
   *
   *
   * <pre>
   * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
   * </pre>
   *
   * <code>bool allow_global_access = 499409674;</code>
   *
   * @return Whether the allowGlobalAccess field is set.
   */
  @java.lang.Override
  public boolean hasAllowGlobalAccess() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
   * </pre>
   *
   * <code>bool allow_global_access = 499409674;</code>
   *
   * @return The allowGlobalAccess.
   */
  @java.lang.Override
  public boolean getAllowGlobalAccess() {
    return allowGlobalAccess_;
  }

  public static final int BACKEND_SERVICE_FIELD_NUMBER = 306946058;
  private volatile java.lang.Object backendService_;
  /**
   *
   *
   * <pre>
   * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
   * </pre>
   *
   * <code>string backend_service = 306946058;</code>
   *
   * @return Whether the backendService field is set.
   */
  @java.lang.Override
  public boolean hasBackendService() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   *
   *
   * <pre>
   * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
   * </pre>
   *
   * <code>string backend_service = 306946058;</code>
   *
   * @return The backendService.
   */
  @java.lang.Override
  public java.lang.String getBackendService() {
    java.lang.Object ref = backendService_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      backendService_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
   * </pre>
   *
   * <code>string backend_service = 306946058;</code>
   *
   * @return The bytes for backendService.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getBackendServiceBytes() {
    java.lang.Object ref = backendService_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      backendService_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int CREATION_TIMESTAMP_FIELD_NUMBER = 30525366;
  private volatile java.lang.Object creationTimestamp_;
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return Whether the creationTimestamp field is set.
   */
  @java.lang.Override
  public boolean hasCreationTimestamp() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The creationTimestamp.
   */
  @java.lang.Override
  public java.lang.String getCreationTimestamp() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      creationTimestamp_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Creation timestamp in RFC3339 text format.
   * </pre>
   *
   * <code>string creation_timestamp = 30525366;</code>
   *
   * @return The bytes for creationTimestamp.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getCreationTimestampBytes() {
    java.lang.Object ref = creationTimestamp_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      creationTimestamp_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 422937596;
  private volatile java.lang.Object description_;
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return Whether the description field is set.
   */
  @java.lang.Override
  public boolean hasDescription() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The description.
   */
  @java.lang.Override
  public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      description_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 422937596;</code>
   *
   * @return The bytes for description.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      description_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int FINGERPRINT_FIELD_NUMBER = 234678500;
  private volatile java.lang.Object fingerprint_;
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
   * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return Whether the fingerprint field is set.
   */
  @java.lang.Override
  public boolean hasFingerprint() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
   * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return The fingerprint.
   */
  @java.lang.Override
  public java.lang.String getFingerprint() {
    java.lang.Object ref = fingerprint_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      fingerprint_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
   * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
   * </pre>
   *
   * <code>string fingerprint = 234678500;</code>
   *
   * @return The bytes for fingerprint.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getFingerprintBytes() {
    java.lang.Object ref = fingerprint_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      fingerprint_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ID_FIELD_NUMBER = 3355;
  private volatile java.lang.Object id_;
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return Whether the id field is set.
   */
  @java.lang.Override
  public boolean hasId() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The id.
   */
  @java.lang.Override
  public java.lang.String getId() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      id_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
   * </pre>
   *
   * <code>string id = 3355;</code>
   *
   * @return The bytes for id.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getIdBytes() {
    java.lang.Object ref = id_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      id_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int IP_VERSION_FIELD_NUMBER = 294959552;
  private int ipVersion_;
  /**
   *
   *
   * <pre>
   * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
   *
   * @return Whether the ipVersion field is set.
   */
  @java.lang.Override
  public boolean hasIpVersion() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   *
   *
   * <pre>
   * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
   *
   * @return The enum numeric value on the wire for ipVersion.
   */
  @java.lang.Override
  public int getIpVersionValue() {
    return ipVersion_;
  }
  /**
   *
   *
   * <pre>
   * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
   *
   * @return The ipVersion.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ForwardingRule.IpVersion getIpVersion() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.ForwardingRule.IpVersion result =
        com.google.cloud.compute.v1.ForwardingRule.IpVersion.valueOf(ipVersion_);
    return result == null
        ? com.google.cloud.compute.v1.ForwardingRule.IpVersion.UNRECOGNIZED
        : result;
  }

  public static final int IS_MIRRORING_COLLECTOR_FIELD_NUMBER = 119255164;
  private boolean isMirroringCollector_;
  /**
   *
   *
   * <pre>
   * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
   * </pre>
   *
   * <code>bool is_mirroring_collector = 119255164;</code>
   *
   * @return Whether the isMirroringCollector field is set.
   */
  @java.lang.Override
  public boolean hasIsMirroringCollector() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   *
   *
   * <pre>
   * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
   * </pre>
   *
   * <code>bool is_mirroring_collector = 119255164;</code>
   *
   * @return The isMirroringCollector.
   */
  @java.lang.Override
  public boolean getIsMirroringCollector() {
    return isMirroringCollector_;
  }

  public static final int KIND_FIELD_NUMBER = 3292052;
  private volatile java.lang.Object kind_;
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return Whether the kind field is set.
   */
  @java.lang.Override
  public boolean hasKind() {
    return ((bitField0_ & 0x00000800) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The kind.
   */
  @java.lang.Override
  public java.lang.String getKind() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      kind_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
   * </pre>
   *
   * <code>string kind = 3292052;</code>
   *
   * @return The bytes for kind.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getKindBytes() {
    java.lang.Object ref = kind_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      kind_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int LOAD_BALANCING_SCHEME_FIELD_NUMBER = 363890244;
  private int loadBalancingScheme_;
  /**
   *
   *
   * <pre>
   * Specifies the forwarding rule type.
   * - EXTERNAL is used for:
   * - Classic Cloud VPN gateways
   * - Protocol forwarding to VMs from an external IP address
   * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
   * - INTERNAL is used for:
   * - Protocol forwarding to VMs from an internal IP address
   * - Internal TCP/UDP Load Balancing
   * - INTERNAL_MANAGED is used for:
   * - Internal HTTP(S) Load Balancing
   * - INTERNAL_SELF_MANAGED is used for:
   * - Traffic Director
   * For more information about forwarding rules, refer to Forwarding rule concepts.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return Whether the loadBalancingScheme field is set.
   */
  @java.lang.Override
  public boolean hasLoadBalancingScheme() {
    return ((bitField0_ & 0x00001000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Specifies the forwarding rule type.
   * - EXTERNAL is used for:
   * - Classic Cloud VPN gateways
   * - Protocol forwarding to VMs from an external IP address
   * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
   * - INTERNAL is used for:
   * - Protocol forwarding to VMs from an internal IP address
   * - Internal TCP/UDP Load Balancing
   * - INTERNAL_MANAGED is used for:
   * - Internal HTTP(S) Load Balancing
   * - INTERNAL_SELF_MANAGED is used for:
   * - Traffic Director
   * For more information about forwarding rules, refer to Forwarding rule concepts.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return The enum numeric value on the wire for loadBalancingScheme.
   */
  @java.lang.Override
  public int getLoadBalancingSchemeValue() {
    return loadBalancingScheme_;
  }
  /**
   *
   *
   * <pre>
   * Specifies the forwarding rule type.
   * - EXTERNAL is used for:
   * - Classic Cloud VPN gateways
   * - Protocol forwarding to VMs from an external IP address
   * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
   * - INTERNAL is used for:
   * - Protocol forwarding to VMs from an internal IP address
   * - Internal TCP/UDP Load Balancing
   * - INTERNAL_MANAGED is used for:
   * - Internal HTTP(S) Load Balancing
   * - INTERNAL_SELF_MANAGED is used for:
   * - Traffic Director
   * For more information about forwarding rules, refer to Forwarding rule concepts.
   * </pre>
   *
   * <code>
   * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
   * </code>
   *
   * @return The loadBalancingScheme.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme getLoadBalancingScheme() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme result =
        com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme.valueOf(
            loadBalancingScheme_);
    return result == null
        ? com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme.UNRECOGNIZED
        : result;
  }

  public static final int METADATA_FILTERS_FIELD_NUMBER = 464725739;
  private java.util.List<com.google.cloud.compute.v1.MetadataFilter> metadataFilters_;
  /**
   *
   *
   * <pre>
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
   * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
   * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.cloud.compute.v1.MetadataFilter> getMetadataFiltersList() {
    return metadataFilters_;
  }
  /**
   *
   *
   * <pre>
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
   * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
   * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.cloud.compute.v1.MetadataFilterOrBuilder>
      getMetadataFiltersOrBuilderList() {
    return metadataFilters_;
  }
  /**
   *
   *
   * <pre>
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
   * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
   * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
   */
  @java.lang.Override
  public int getMetadataFiltersCount() {
    return metadataFilters_.size();
  }
  /**
   *
   *
   * <pre>
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
   * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
   * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.MetadataFilter getMetadataFilters(int index) {
    return metadataFilters_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
   * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
   * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
   * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   * </pre>
   *
   * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.MetadataFilterOrBuilder getMetadataFiltersOrBuilder(
      int index) {
    return metadataFilters_.get(index);
  }

  public static final int NAME_FIELD_NUMBER = 3373707;
  private volatile java.lang.Object name_;
  /**
   *
   *
   * <pre>
   * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return Whether the name field is set.
   */
  @java.lang.Override
  public boolean hasName() {
    return ((bitField0_ & 0x00002000) != 0);
  }
  /**
   *
   *
   * <pre>
   * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NETWORK_FIELD_NUMBER = 232872494;
  private volatile java.lang.Object network_;
  /**
   *
   *
   * <pre>
   * This field is not used for external load balancing.
   * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return Whether the network field is set.
   */
  @java.lang.Override
  public boolean hasNetwork() {
    return ((bitField0_ & 0x00004000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field is not used for external load balancing.
   * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The network.
   */
  @java.lang.Override
  public java.lang.String getNetwork() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      network_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * This field is not used for external load balancing.
   * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The bytes for network.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNetworkBytes() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      network_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NETWORK_TIER_FIELD_NUMBER = 517397843;
  private int networkTier_;
  /**
   *
   *
   * <pre>
   * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
   * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
   * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
   *
   * @return Whether the networkTier field is set.
   */
  @java.lang.Override
  public boolean hasNetworkTier() {
    return ((bitField0_ & 0x00008000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
   * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
   * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
   *
   * @return The enum numeric value on the wire for networkTier.
   */
  @java.lang.Override
  public int getNetworkTierValue() {
    return networkTier_;
  }
  /**
   *
   *
   * <pre>
   * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
   * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
   * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
   *
   * @return The networkTier.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.ForwardingRule.NetworkTier getNetworkTier() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.ForwardingRule.NetworkTier result =
        com.google.cloud.compute.v1.ForwardingRule.NetworkTier.valueOf(networkTier_);
    return result == null
        ? com.google.cloud.compute.v1.ForwardingRule.NetworkTier.UNRECOGNIZED
        : result;
  }

  public static final int PORT_RANGE_FIELD_NUMBER = 217518079;
  private volatile java.lang.Object portRange_;
  /**
   *
   *
   * <pre>
   * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
   * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
   * Some types of forwarding target have constraints on the acceptable ports:
   * - TargetHttpProxy: 80, 8080
   * - TargetHttpsProxy: 443
   * - TargetGrpcProxy: no constraints
   * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetVpnGateway: 500, 4500
   * </pre>
   *
   * <code>string port_range = 217518079;</code>
   *
   * @return Whether the portRange field is set.
   */
  @java.lang.Override
  public boolean hasPortRange() {
    return ((bitField0_ & 0x00010000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
   * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
   * Some types of forwarding target have constraints on the acceptable ports:
   * - TargetHttpProxy: 80, 8080
   * - TargetHttpsProxy: 443
   * - TargetGrpcProxy: no constraints
   * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetVpnGateway: 500, 4500
   * </pre>
   *
   * <code>string port_range = 217518079;</code>
   *
   * @return The portRange.
   */
  @java.lang.Override
  public java.lang.String getPortRange() {
    java.lang.Object ref = portRange_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      portRange_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
   * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
   * Some types of forwarding target have constraints on the acceptable ports:
   * - TargetHttpProxy: 80, 8080
   * - TargetHttpsProxy: 443
   * - TargetGrpcProxy: no constraints
   * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
   * - TargetVpnGateway: 500, 4500
   * </pre>
   *
   * <code>string port_range = 217518079;</code>
   *
   * @return The bytes for portRange.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getPortRangeBytes() {
    java.lang.Object ref = portRange_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      portRange_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PORTS_FIELD_NUMBER = 106854418;
  private com.google.protobuf.LazyStringList ports_;
  /**
   *
   *
   * <pre>
   * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
   * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
   * You can specify a list of up to five ports, which can be non-contiguous.
   * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
   * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
   * </pre>
   *
   * <code>repeated string ports = 106854418;</code>
   *
   * @return A list containing the ports.
   */
  public com.google.protobuf.ProtocolStringList getPortsList() {
    return ports_;
  }
  /**
   *
   *
   * <pre>
   * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
   * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
   * You can specify a list of up to five ports, which can be non-contiguous.
   * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
   * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
   * </pre>
   *
   * <code>repeated string ports = 106854418;</code>
   *
   * @return The count of ports.
   */
  public int getPortsCount() {
    return ports_.size();
  }
  /**
   *
   *
   * <pre>
   * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
   * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
   * You can specify a list of up to five ports, which can be non-contiguous.
   * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
   * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
   * </pre>
   *
   * <code>repeated string ports = 106854418;</code>
   *
   * @param index The index of the element to return.
   * @return The ports at the given index.
   */
  public java.lang.String getPorts(int index) {
    return ports_.get(index);
  }
  /**
   *
   *
   * <pre>
   * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
   * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
   * You can specify a list of up to five ports, which can be non-contiguous.
   * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
   * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
   * </pre>
   *
   * <code>repeated string ports = 106854418;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the ports at the given index.
   */
  public com.google.protobuf.ByteString getPortsBytes(int index) {
    return ports_.getByteString(index);
  }

  public static final int REGION_FIELD_NUMBER = 138946292;
  private volatile java.lang.Object region_;
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return Whether the region field is set.
   */
  @java.lang.Override
  public boolean hasRegion() {
    return ((bitField0_ & 0x00020000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The region.
   */
  @java.lang.Override
  public java.lang.String getRegion() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      region_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
   * </pre>
   *
   * <code>string region = 138946292;</code>
   *
   * @return The bytes for region.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getRegionBytes() {
    java.lang.Object ref = region_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      region_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SELF_LINK_FIELD_NUMBER = 456214797;
  private volatile java.lang.Object selfLink_;
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return Whether the selfLink field is set.
   */
  @java.lang.Override
  public boolean hasSelfLink() {
    return ((bitField0_ & 0x00040000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The selfLink.
   */
  @java.lang.Override
  public java.lang.String getSelfLink() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      selfLink_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>string self_link = 456214797;</code>
   *
   * @return The bytes for selfLink.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getSelfLinkBytes() {
    java.lang.Object ref = selfLink_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      selfLink_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SERVICE_LABEL_FIELD_NUMBER = 417008874;
  private volatile java.lang.Object serviceLabel_;
  /**
   *
   *
   * <pre>
   * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
   * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_label = 417008874;</code>
   *
   * @return Whether the serviceLabel field is set.
   */
  @java.lang.Override
  public boolean hasServiceLabel() {
    return ((bitField0_ & 0x00080000) != 0);
  }
  /**
   *
   *
   * <pre>
   * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
   * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_label = 417008874;</code>
   *
   * @return The serviceLabel.
   */
  @java.lang.Override
  public java.lang.String getServiceLabel() {
    java.lang.Object ref = serviceLabel_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      serviceLabel_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
   * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_label = 417008874;</code>
   *
   * @return The bytes for serviceLabel.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getServiceLabelBytes() {
    java.lang.Object ref = serviceLabel_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      serviceLabel_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SERVICE_NAME_FIELD_NUMBER = 359880149;
  private volatile java.lang.Object serviceName_;
  /**
   *
   *
   * <pre>
   * [Output Only] The internal fully qualified service name for this Forwarding Rule.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_name = 359880149;</code>
   *
   * @return Whether the serviceName field is set.
   */
  @java.lang.Override
  public boolean hasServiceName() {
    return ((bitField0_ & 0x00100000) != 0);
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The internal fully qualified service name for this Forwarding Rule.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_name = 359880149;</code>
   *
   * @return The serviceName.
   */
  @java.lang.Override
  public java.lang.String getServiceName() {
    java.lang.Object ref = serviceName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      serviceName_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] The internal fully qualified service name for this Forwarding Rule.
   * This field is only used for internal load balancing.
   * </pre>
   *
   * <code>string service_name = 359880149;</code>
   *
   * @return The bytes for serviceName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getServiceNameBytes() {
    java.lang.Object ref = serviceName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      serviceName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SUBNETWORK_FIELD_NUMBER = 307827694;
  private volatile java.lang.Object subnetwork_;
  /**
   *
   *
   * <pre>
   * This field is only used for internal load balancing.
   * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
   * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
   * </pre>
   *
   * <code>string subnetwork = 307827694;</code>
   *
   * @return Whether the subnetwork field is set.
   */
  @java.lang.Override
  public boolean hasSubnetwork() {
    return ((bitField0_ & 0x00200000) != 0);
  }
  /**
   *
   *
   * <pre>
   * This field is only used for internal load balancing.
   * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
   * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
   * </pre>
   *
   * <code>string subnetwork = 307827694;</code>
   *
   * @return The subnetwork.
   */
  @java.lang.Override
  public java.lang.String getSubnetwork() {
    java.lang.Object ref = subnetwork_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      subnetwork_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * This field is only used for internal load balancing.
   * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
   * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
   * </pre>
   *
   * <code>string subnetwork = 307827694;</code>
   *
   * @return The bytes for subnetwork.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getSubnetworkBytes() {
    java.lang.Object ref = subnetwork_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      subnetwork_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int TARGET_FIELD_NUMBER = 192835985;
  private volatile java.lang.Object target_;
  /**
   *
   *
   * <pre>
   * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
   * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
   * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
   * </pre>
   *
   * <code>string target = 192835985;</code>
   *
   * @return Whether the target field is set.
   */
  @java.lang.Override
  public boolean hasTarget() {
    return ((bitField0_ & 0x00400000) != 0);
  }
  /**
   *
   *
   * <pre>
   * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
   * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
   * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
   * </pre>
   *
   * <code>string target = 192835985;</code>
   *
   * @return The target.
   */
  @java.lang.Override
  public java.lang.String getTarget() {
    java.lang.Object ref = target_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      target_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
   * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
   * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
   * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
   * </pre>
   *
   * <code>string target = 192835985;</code>
   *
   * @return The bytes for target.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getTargetBytes() {
    java.lang.Object ref = target_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      target_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000100) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3355, id_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3292052, kind_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3373707, name_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 42976943, iPAddress_);
    }
    for (int i = 0; i < ports_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 106854418, ports_.getRaw(i));
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      output.writeBool(119255164, isMirroringCollector_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 138946292, region_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 192835985, target_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 217518079, portRange_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 232872494, network_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 234678500, fingerprint_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      output.writeEnum(294959552, ipVersion_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 306946058, backendService_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 307827694, subnetwork_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 359880149, serviceName_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      output.writeEnum(363890244, loadBalancingScheme_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 417008874, serviceLabel_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 422937596, description_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      output.writeBool(445175796, allPorts_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 456214797, selfLink_);
    }
    for (int i = 0; i < metadataFilters_.size(); i++) {
      output.writeMessage(464725739, metadataFilters_.get(i));
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeEnum(488094525, iPProtocol_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      output.writeBool(499409674, allowGlobalAccess_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      output.writeEnum(517397843, networkTier_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000100) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3355, id_);
    }
    if (((bitField0_ & 0x00000800) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3292052, kind_);
    }
    if (((bitField0_ & 0x00002000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3373707, name_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(30525366, creationTimestamp_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(42976943, iPAddress_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < ports_.size(); i++) {
        dataSize += computeStringSizeNoTag(ports_.getRaw(i));
      }
      size += dataSize;
      size += 5 * getPortsList().size();
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeBoolSize(119255164, isMirroringCollector_);
    }
    if (((bitField0_ & 0x00020000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(138946292, region_);
    }
    if (((bitField0_ & 0x00400000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(192835985, target_);
    }
    if (((bitField0_ & 0x00010000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(217518079, portRange_);
    }
    if (((bitField0_ & 0x00004000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(232872494, network_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(234678500, fingerprint_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(294959552, ipVersion_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(306946058, backendService_);
    }
    if (((bitField0_ & 0x00200000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(307827694, subnetwork_);
    }
    if (((bitField0_ & 0x00100000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(359880149, serviceName_);
    }
    if (((bitField0_ & 0x00001000) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeEnumSize(363890244, loadBalancingScheme_);
    }
    if (((bitField0_ & 0x00080000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(417008874, serviceLabel_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(422937596, description_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(445175796, allPorts_);
    }
    if (((bitField0_ & 0x00040000) != 0)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(456214797, selfLink_);
    }
    for (int i = 0; i < metadataFilters_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              464725739, metadataFilters_.get(i));
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(488094525, iPProtocol_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(499409674, allowGlobalAccess_);
    }
    if (((bitField0_ & 0x00008000) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(517397843, networkTier_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.ForwardingRule)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.ForwardingRule other =
        (com.google.cloud.compute.v1.ForwardingRule) obj;

    if (hasIPAddress() != other.hasIPAddress()) return false;
    if (hasIPAddress()) {
      if (!getIPAddress().equals(other.getIPAddress())) return false;
    }
    if (hasIPProtocol() != other.hasIPProtocol()) return false;
    if (hasIPProtocol()) {
      if (iPProtocol_ != other.iPProtocol_) return false;
    }
    if (hasAllPorts() != other.hasAllPorts()) return false;
    if (hasAllPorts()) {
      if (getAllPorts() != other.getAllPorts()) return false;
    }
    if (hasAllowGlobalAccess() != other.hasAllowGlobalAccess()) return false;
    if (hasAllowGlobalAccess()) {
      if (getAllowGlobalAccess() != other.getAllowGlobalAccess()) return false;
    }
    if (hasBackendService() != other.hasBackendService()) return false;
    if (hasBackendService()) {
      if (!getBackendService().equals(other.getBackendService())) return false;
    }
    if (hasCreationTimestamp() != other.hasCreationTimestamp()) return false;
    if (hasCreationTimestamp()) {
      if (!getCreationTimestamp().equals(other.getCreationTimestamp())) return false;
    }
    if (hasDescription() != other.hasDescription()) return false;
    if (hasDescription()) {
      if (!getDescription().equals(other.getDescription())) return false;
    }
    if (hasFingerprint() != other.hasFingerprint()) return false;
    if (hasFingerprint()) {
      if (!getFingerprint().equals(other.getFingerprint())) return false;
    }
    if (hasId() != other.hasId()) return false;
    if (hasId()) {
      if (!getId().equals(other.getId())) return false;
    }
    if (hasIpVersion() != other.hasIpVersion()) return false;
    if (hasIpVersion()) {
      if (ipVersion_ != other.ipVersion_) return false;
    }
    if (hasIsMirroringCollector() != other.hasIsMirroringCollector()) return false;
    if (hasIsMirroringCollector()) {
      if (getIsMirroringCollector() != other.getIsMirroringCollector()) return false;
    }
    if (hasKind() != other.hasKind()) return false;
    if (hasKind()) {
      if (!getKind().equals(other.getKind())) return false;
    }
    if (hasLoadBalancingScheme() != other.hasLoadBalancingScheme()) return false;
    if (hasLoadBalancingScheme()) {
      if (loadBalancingScheme_ != other.loadBalancingScheme_) return false;
    }
    if (!getMetadataFiltersList().equals(other.getMetadataFiltersList())) return false;
    if (hasName() != other.hasName()) return false;
    if (hasName()) {
      if (!getName().equals(other.getName())) return false;
    }
    if (hasNetwork() != other.hasNetwork()) return false;
    if (hasNetwork()) {
      if (!getNetwork().equals(other.getNetwork())) return false;
    }
    if (hasNetworkTier() != other.hasNetworkTier()) return false;
    if (hasNetworkTier()) {
      if (networkTier_ != other.networkTier_) return false;
    }
    if (hasPortRange() != other.hasPortRange()) return false;
    if (hasPortRange()) {
      if (!getPortRange().equals(other.getPortRange())) return false;
    }
    if (!getPortsList().equals(other.getPortsList())) return false;
    if (hasRegion() != other.hasRegion()) return false;
    if (hasRegion()) {
      if (!getRegion().equals(other.getRegion())) return false;
    }
    if (hasSelfLink() != other.hasSelfLink()) return false;
    if (hasSelfLink()) {
      if (!getSelfLink().equals(other.getSelfLink())) return false;
    }
    if (hasServiceLabel() != other.hasServiceLabel()) return false;
    if (hasServiceLabel()) {
      if (!getServiceLabel().equals(other.getServiceLabel())) return false;
    }
    if (hasServiceName() != other.hasServiceName()) return false;
    if (hasServiceName()) {
      if (!getServiceName().equals(other.getServiceName())) return false;
    }
    if (hasSubnetwork() != other.hasSubnetwork()) return false;
    if (hasSubnetwork()) {
      if (!getSubnetwork().equals(other.getSubnetwork())) return false;
    }
    if (hasTarget() != other.hasTarget()) return false;
    if (hasTarget()) {
      if (!getTarget().equals(other.getTarget())) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasIPAddress()) {
      hash = (37 * hash) + I_P_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getIPAddress().hashCode();
    }
    if (hasIPProtocol()) {
      hash = (37 * hash) + I_P_PROTOCOL_FIELD_NUMBER;
      hash = (53 * hash) + iPProtocol_;
    }
    if (hasAllPorts()) {
      hash = (37 * hash) + ALL_PORTS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getAllPorts());
    }
    if (hasAllowGlobalAccess()) {
      hash = (37 * hash) + ALLOW_GLOBAL_ACCESS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getAllowGlobalAccess());
    }
    if (hasBackendService()) {
      hash = (37 * hash) + BACKEND_SERVICE_FIELD_NUMBER;
      hash = (53 * hash) + getBackendService().hashCode();
    }
    if (hasCreationTimestamp()) {
      hash = (37 * hash) + CREATION_TIMESTAMP_FIELD_NUMBER;
      hash = (53 * hash) + getCreationTimestamp().hashCode();
    }
    if (hasDescription()) {
      hash = (37 * hash) + DESCRIPTION_FIELD_NUMBER;
      hash = (53 * hash) + getDescription().hashCode();
    }
    if (hasFingerprint()) {
      hash = (37 * hash) + FINGERPRINT_FIELD_NUMBER;
      hash = (53 * hash) + getFingerprint().hashCode();
    }
    if (hasId()) {
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
    }
    if (hasIpVersion()) {
      hash = (37 * hash) + IP_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + ipVersion_;
    }
    if (hasIsMirroringCollector()) {
      hash = (37 * hash) + IS_MIRRORING_COLLECTOR_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getIsMirroringCollector());
    }
    if (hasKind()) {
      hash = (37 * hash) + KIND_FIELD_NUMBER;
      hash = (53 * hash) + getKind().hashCode();
    }
    if (hasLoadBalancingScheme()) {
      hash = (37 * hash) + LOAD_BALANCING_SCHEME_FIELD_NUMBER;
      hash = (53 * hash) + loadBalancingScheme_;
    }
    if (getMetadataFiltersCount() > 0) {
      hash = (37 * hash) + METADATA_FILTERS_FIELD_NUMBER;
      hash = (53 * hash) + getMetadataFiltersList().hashCode();
    }
    if (hasName()) {
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
    }
    if (hasNetwork()) {
      hash = (37 * hash) + NETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getNetwork().hashCode();
    }
    if (hasNetworkTier()) {
      hash = (37 * hash) + NETWORK_TIER_FIELD_NUMBER;
      hash = (53 * hash) + networkTier_;
    }
    if (hasPortRange()) {
      hash = (37 * hash) + PORT_RANGE_FIELD_NUMBER;
      hash = (53 * hash) + getPortRange().hashCode();
    }
    if (getPortsCount() > 0) {
      hash = (37 * hash) + PORTS_FIELD_NUMBER;
      hash = (53 * hash) + getPortsList().hashCode();
    }
    if (hasRegion()) {
      hash = (37 * hash) + REGION_FIELD_NUMBER;
      hash = (53 * hash) + getRegion().hashCode();
    }
    if (hasSelfLink()) {
      hash = (37 * hash) + SELF_LINK_FIELD_NUMBER;
      hash = (53 * hash) + getSelfLink().hashCode();
    }
    if (hasServiceLabel()) {
      hash = (37 * hash) + SERVICE_LABEL_FIELD_NUMBER;
      hash = (53 * hash) + getServiceLabel().hashCode();
    }
    if (hasServiceName()) {
      hash = (37 * hash) + SERVICE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getServiceName().hashCode();
    }
    if (hasSubnetwork()) {
      hash = (37 * hash) + SUBNETWORK_FIELD_NUMBER;
      hash = (53 * hash) + getSubnetwork().hashCode();
    }
    if (hasTarget()) {
      hash = (37 * hash) + TARGET_FIELD_NUMBER;
      hash = (53 * hash) + getTarget().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.ForwardingRule parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.ForwardingRule prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Represents a Forwarding Rule resource.
   * Forwarding rule resources in GCP can be either regional or global in scope:
   * * [Global](/compute/docs/reference/rest/{$api_version}/globalForwardingRules) * [Regional](/compute/docs/reference/rest/{$api_version}/forwardingRules)
   * A forwarding rule and its corresponding IP address represent the frontend configuration of a Google Cloud Platform load balancer. Forwarding rules can also reference target instances and Cloud VPN Classic gateways (targetVpnGateway).
   * For more information, read Forwarding rule concepts and Using protocol forwarding.
   * (== resource_for {$api_version}.forwardingRules ==) (== resource_for {$api_version}.globalForwardingRules ==) (== resource_for {$api_version}.regionForwardingRules ==)
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.ForwardingRule}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.ForwardingRule)
      com.google.cloud.compute.v1.ForwardingRuleOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_ForwardingRule_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_ForwardingRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.ForwardingRule.class,
              com.google.cloud.compute.v1.ForwardingRule.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.ForwardingRule.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getMetadataFiltersFieldBuilder();
      }
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      iPAddress_ = "";
      bitField0_ = (bitField0_ & ~0x00000001);
      iPProtocol_ = 0;
      bitField0_ = (bitField0_ & ~0x00000002);
      allPorts_ = false;
      bitField0_ = (bitField0_ & ~0x00000004);
      allowGlobalAccess_ = false;
      bitField0_ = (bitField0_ & ~0x00000008);
      backendService_ = "";
      bitField0_ = (bitField0_ & ~0x00000010);
      creationTimestamp_ = "";
      bitField0_ = (bitField0_ & ~0x00000020);
      description_ = "";
      bitField0_ = (bitField0_ & ~0x00000040);
      fingerprint_ = "";
      bitField0_ = (bitField0_ & ~0x00000080);
      id_ = "";
      bitField0_ = (bitField0_ & ~0x00000100);
      ipVersion_ = 0;
      bitField0_ = (bitField0_ & ~0x00000200);
      isMirroringCollector_ = false;
      bitField0_ = (bitField0_ & ~0x00000400);
      kind_ = "";
      bitField0_ = (bitField0_ & ~0x00000800);
      loadBalancingScheme_ = 0;
      bitField0_ = (bitField0_ & ~0x00001000);
      if (metadataFiltersBuilder_ == null) {
        metadataFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
      } else {
        metadataFiltersBuilder_.clear();
      }
      name_ = "";
      bitField0_ = (bitField0_ & ~0x00004000);
      network_ = "";
      bitField0_ = (bitField0_ & ~0x00008000);
      networkTier_ = 0;
      bitField0_ = (bitField0_ & ~0x00010000);
      portRange_ = "";
      bitField0_ = (bitField0_ & ~0x00020000);
      ports_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00040000);
      region_ = "";
      bitField0_ = (bitField0_ & ~0x00080000);
      selfLink_ = "";
      bitField0_ = (bitField0_ & ~0x00100000);
      serviceLabel_ = "";
      bitField0_ = (bitField0_ & ~0x00200000);
      serviceName_ = "";
      bitField0_ = (bitField0_ & ~0x00400000);
      subnetwork_ = "";
      bitField0_ = (bitField0_ & ~0x00800000);
      target_ = "";
      bitField0_ = (bitField0_ & ~0x01000000);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_ForwardingRule_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.ForwardingRule.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule build() {
      com.google.cloud.compute.v1.ForwardingRule result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule buildPartial() {
      com.google.cloud.compute.v1.ForwardingRule result =
          new com.google.cloud.compute.v1.ForwardingRule(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        to_bitField0_ |= 0x00000001;
      }
      result.iPAddress_ = iPAddress_;
      if (((from_bitField0_ & 0x00000002) != 0)) {
        to_bitField0_ |= 0x00000002;
      }
      result.iPProtocol_ = iPProtocol_;
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.allPorts_ = allPorts_;
        to_bitField0_ |= 0x00000004;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.allowGlobalAccess_ = allowGlobalAccess_;
        to_bitField0_ |= 0x00000008;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        to_bitField0_ |= 0x00000010;
      }
      result.backendService_ = backendService_;
      if (((from_bitField0_ & 0x00000020) != 0)) {
        to_bitField0_ |= 0x00000020;
      }
      result.creationTimestamp_ = creationTimestamp_;
      if (((from_bitField0_ & 0x00000040) != 0)) {
        to_bitField0_ |= 0x00000040;
      }
      result.description_ = description_;
      if (((from_bitField0_ & 0x00000080) != 0)) {
        to_bitField0_ |= 0x00000080;
      }
      result.fingerprint_ = fingerprint_;
      if (((from_bitField0_ & 0x00000100) != 0)) {
        to_bitField0_ |= 0x00000100;
      }
      result.id_ = id_;
      if (((from_bitField0_ & 0x00000200) != 0)) {
        to_bitField0_ |= 0x00000200;
      }
      result.ipVersion_ = ipVersion_;
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.isMirroringCollector_ = isMirroringCollector_;
        to_bitField0_ |= 0x00000400;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        to_bitField0_ |= 0x00000800;
      }
      result.kind_ = kind_;
      if (((from_bitField0_ & 0x00001000) != 0)) {
        to_bitField0_ |= 0x00001000;
      }
      result.loadBalancingScheme_ = loadBalancingScheme_;
      if (metadataFiltersBuilder_ == null) {
        if (((bitField0_ & 0x00002000) != 0)) {
          metadataFilters_ = java.util.Collections.unmodifiableList(metadataFilters_);
          bitField0_ = (bitField0_ & ~0x00002000);
        }
        result.metadataFilters_ = metadataFilters_;
      } else {
        result.metadataFilters_ = metadataFiltersBuilder_.build();
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        to_bitField0_ |= 0x00002000;
      }
      result.name_ = name_;
      if (((from_bitField0_ & 0x00008000) != 0)) {
        to_bitField0_ |= 0x00004000;
      }
      result.network_ = network_;
      if (((from_bitField0_ & 0x00010000) != 0)) {
        to_bitField0_ |= 0x00008000;
      }
      result.networkTier_ = networkTier_;
      if (((from_bitField0_ & 0x00020000) != 0)) {
        to_bitField0_ |= 0x00010000;
      }
      result.portRange_ = portRange_;
      if (((bitField0_ & 0x00040000) != 0)) {
        ports_ = ports_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00040000);
      }
      result.ports_ = ports_;
      if (((from_bitField0_ & 0x00080000) != 0)) {
        to_bitField0_ |= 0x00020000;
      }
      result.region_ = region_;
      if (((from_bitField0_ & 0x00100000) != 0)) {
        to_bitField0_ |= 0x00040000;
      }
      result.selfLink_ = selfLink_;
      if (((from_bitField0_ & 0x00200000) != 0)) {
        to_bitField0_ |= 0x00080000;
      }
      result.serviceLabel_ = serviceLabel_;
      if (((from_bitField0_ & 0x00400000) != 0)) {
        to_bitField0_ |= 0x00100000;
      }
      result.serviceName_ = serviceName_;
      if (((from_bitField0_ & 0x00800000) != 0)) {
        to_bitField0_ |= 0x00200000;
      }
      result.subnetwork_ = subnetwork_;
      if (((from_bitField0_ & 0x01000000) != 0)) {
        to_bitField0_ |= 0x00400000;
      }
      result.target_ = target_;
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.ForwardingRule) {
        return mergeFrom((com.google.cloud.compute.v1.ForwardingRule) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.ForwardingRule other) {
      if (other == com.google.cloud.compute.v1.ForwardingRule.getDefaultInstance()) return this;
      if (other.hasIPAddress()) {
        bitField0_ |= 0x00000001;
        iPAddress_ = other.iPAddress_;
        onChanged();
      }
      if (other.hasIPProtocol()) {
        setIPProtocol(other.getIPProtocol());
      }
      if (other.hasAllPorts()) {
        setAllPorts(other.getAllPorts());
      }
      if (other.hasAllowGlobalAccess()) {
        setAllowGlobalAccess(other.getAllowGlobalAccess());
      }
      if (other.hasBackendService()) {
        bitField0_ |= 0x00000010;
        backendService_ = other.backendService_;
        onChanged();
      }
      if (other.hasCreationTimestamp()) {
        bitField0_ |= 0x00000020;
        creationTimestamp_ = other.creationTimestamp_;
        onChanged();
      }
      if (other.hasDescription()) {
        bitField0_ |= 0x00000040;
        description_ = other.description_;
        onChanged();
      }
      if (other.hasFingerprint()) {
        bitField0_ |= 0x00000080;
        fingerprint_ = other.fingerprint_;
        onChanged();
      }
      if (other.hasId()) {
        bitField0_ |= 0x00000100;
        id_ = other.id_;
        onChanged();
      }
      if (other.hasIpVersion()) {
        setIpVersion(other.getIpVersion());
      }
      if (other.hasIsMirroringCollector()) {
        setIsMirroringCollector(other.getIsMirroringCollector());
      }
      if (other.hasKind()) {
        bitField0_ |= 0x00000800;
        kind_ = other.kind_;
        onChanged();
      }
      if (other.hasLoadBalancingScheme()) {
        setLoadBalancingScheme(other.getLoadBalancingScheme());
      }
      if (metadataFiltersBuilder_ == null) {
        if (!other.metadataFilters_.isEmpty()) {
          if (metadataFilters_.isEmpty()) {
            metadataFilters_ = other.metadataFilters_;
            bitField0_ = (bitField0_ & ~0x00002000);
          } else {
            ensureMetadataFiltersIsMutable();
            metadataFilters_.addAll(other.metadataFilters_);
          }
          onChanged();
        }
      } else {
        if (!other.metadataFilters_.isEmpty()) {
          if (metadataFiltersBuilder_.isEmpty()) {
            metadataFiltersBuilder_.dispose();
            metadataFiltersBuilder_ = null;
            metadataFilters_ = other.metadataFilters_;
            bitField0_ = (bitField0_ & ~0x00002000);
            metadataFiltersBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getMetadataFiltersFieldBuilder()
                    : null;
          } else {
            metadataFiltersBuilder_.addAllMessages(other.metadataFilters_);
          }
        }
      }
      if (other.hasName()) {
        bitField0_ |= 0x00004000;
        name_ = other.name_;
        onChanged();
      }
      if (other.hasNetwork()) {
        bitField0_ |= 0x00008000;
        network_ = other.network_;
        onChanged();
      }
      if (other.hasNetworkTier()) {
        setNetworkTier(other.getNetworkTier());
      }
      if (other.hasPortRange()) {
        bitField0_ |= 0x00020000;
        portRange_ = other.portRange_;
        onChanged();
      }
      if (!other.ports_.isEmpty()) {
        if (ports_.isEmpty()) {
          ports_ = other.ports_;
          bitField0_ = (bitField0_ & ~0x00040000);
        } else {
          ensurePortsIsMutable();
          ports_.addAll(other.ports_);
        }
        onChanged();
      }
      if (other.hasRegion()) {
        bitField0_ |= 0x00080000;
        region_ = other.region_;
        onChanged();
      }
      if (other.hasSelfLink()) {
        bitField0_ |= 0x00100000;
        selfLink_ = other.selfLink_;
        onChanged();
      }
      if (other.hasServiceLabel()) {
        bitField0_ |= 0x00200000;
        serviceLabel_ = other.serviceLabel_;
        onChanged();
      }
      if (other.hasServiceName()) {
        bitField0_ |= 0x00400000;
        serviceName_ = other.serviceName_;
        onChanged();
      }
      if (other.hasSubnetwork()) {
        bitField0_ |= 0x00800000;
        subnetwork_ = other.subnetwork_;
        onChanged();
      }
      if (other.hasTarget()) {
        bitField0_ |= 0x01000000;
        target_ = other.target_;
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.ForwardingRule parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.cloud.compute.v1.ForwardingRule) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int bitField0_;

    private java.lang.Object iPAddress_ = "";
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @return Whether the iPAddress field is set.
     */
    public boolean hasIPAddress() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @return The iPAddress.
     */
    public java.lang.String getIPAddress() {
      java.lang.Object ref = iPAddress_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        iPAddress_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @return The bytes for iPAddress.
     */
    public com.google.protobuf.ByteString getIPAddressBytes() {
      java.lang.Object ref = iPAddress_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        iPAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @param value The iPAddress to set.
     * @return This builder for chaining.
     */
    public Builder setIPAddress(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      iPAddress_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIPAddress() {
      bitField0_ = (bitField0_ & ~0x00000001);
      iPAddress_ = getDefaultInstance().getIPAddress();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * IP address that this forwarding rule serves. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the target that you specify in the forwarding rule.
     * If you don't specify a reserved IP address, an ephemeral IP address is assigned. Methods for specifying an IP address:
     * * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
     * - projects/project_id/regions/region/addresses/address-name
     * - regions/region/addresses/address-name
     * - global/addresses/address-name
     * - address-name
     * The loadBalancingScheme and the forwarding rule's target determine the type of IP address that you can use. For detailed information, refer to [IP address specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * Must be set to `0.0.0.0` when the target is targetGrpcProxy that has validateForProxyless field set to true.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, IP address must be provided.
     * </pre>
     *
     * <code>string I_p_address = 42976943;</code>
     *
     * @param value The bytes for iPAddress to set.
     * @return This builder for chaining.
     */
    public Builder setIPAddressBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000001;
      iPAddress_ = value;
      onChanged();
      return this;
    }

    private int iPProtocol_ = 0;
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @return Whether the iPProtocol field is set.
     */
    @java.lang.Override
    public boolean hasIPProtocol() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @return The enum numeric value on the wire for iPProtocol.
     */
    @java.lang.Override
    public int getIPProtocolValue() {
      return iPProtocol_;
    }
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @param value The enum numeric value on the wire for iPProtocol to set.
     * @return This builder for chaining.
     */
    public Builder setIPProtocolValue(int value) {
      bitField0_ |= 0x00000002;
      iPProtocol_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @return The iPProtocol.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule.IPProtocol getIPProtocol() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.ForwardingRule.IPProtocol result =
          com.google.cloud.compute.v1.ForwardingRule.IPProtocol.valueOf(iPProtocol_);
      return result == null
          ? com.google.cloud.compute.v1.ForwardingRule.IPProtocol.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @param value The iPProtocol to set.
     * @return This builder for chaining.
     */
    public Builder setIPProtocol(com.google.cloud.compute.v1.ForwardingRule.IPProtocol value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      iPProtocol_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The IP protocol to which this rule applies.
     * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
     * The valid IP protocols are different for different load balancing products:
     * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid.
     * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.
     * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid.
     * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid.
     * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IPProtocol I_p_protocol = 488094525;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIPProtocol() {
      bitField0_ = (bitField0_ & ~0x00000002);
      iPProtocol_ = 0;
      onChanged();
      return this;
    }

    private boolean allPorts_;
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
     * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
     * </pre>
     *
     * <code>bool all_ports = 445175796;</code>
     *
     * @return Whether the allPorts field is set.
     */
    @java.lang.Override
    public boolean hasAllPorts() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
     * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
     * </pre>
     *
     * <code>bool all_ports = 445175796;</code>
     *
     * @return The allPorts.
     */
    @java.lang.Override
    public boolean getAllPorts() {
      return allPorts_;
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
     * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
     * </pre>
     *
     * <code>bool all_ports = 445175796;</code>
     *
     * @param value The allPorts to set.
     * @return This builder for chaining.
     */
    public Builder setAllPorts(boolean value) {
      bitField0_ |= 0x00000004;
      allPorts_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. This field cannot be used with port or portRange fields.
     * When the load balancing scheme is INTERNAL and protocol is TCP/UDP, specify this field to allow packets addressed to any ports will be forwarded to the backends configured with this forwarding rule.
     * </pre>
     *
     * <code>bool all_ports = 445175796;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllPorts() {
      bitField0_ = (bitField0_ & ~0x00000004);
      allPorts_ = false;
      onChanged();
      return this;
    }

    private boolean allowGlobalAccess_;
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
     * </pre>
     *
     * <code>bool allow_global_access = 499409674;</code>
     *
     * @return Whether the allowGlobalAccess field is set.
     */
    @java.lang.Override
    public boolean hasAllowGlobalAccess() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
     * </pre>
     *
     * <code>bool allow_global_access = 499409674;</code>
     *
     * @return The allowGlobalAccess.
     */
    @java.lang.Override
    public boolean getAllowGlobalAccess() {
      return allowGlobalAccess_;
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
     * </pre>
     *
     * <code>bool allow_global_access = 499409674;</code>
     *
     * @param value The allowGlobalAccess to set.
     * @return This builder for chaining.
     */
    public Builder setAllowGlobalAccess(boolean value) {
      bitField0_ |= 0x00000008;
      allowGlobalAccess_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If the field is set to TRUE, clients can access ILB from all regions. Otherwise only allows access from clients in the same region as the internal load balancer.
     * </pre>
     *
     * <code>bool allow_global_access = 499409674;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAllowGlobalAccess() {
      bitField0_ = (bitField0_ & ~0x00000008);
      allowGlobalAccess_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object backendService_ = "";
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @return Whether the backendService field is set.
     */
    public boolean hasBackendService() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @return The backendService.
     */
    public java.lang.String getBackendService() {
      java.lang.Object ref = backendService_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        backendService_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @return The bytes for backendService.
     */
    public com.google.protobuf.ByteString getBackendServiceBytes() {
      java.lang.Object ref = backendService_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        backendService_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @param value The backendService to set.
     * @return This builder for chaining.
     */
    public Builder setBackendService(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      backendService_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearBackendService() {
      bitField0_ = (bitField0_ & ~0x00000010);
      backendService_ = getDefaultInstance().getBackendService();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Identifies the backend service to which the forwarding rule sends traffic. Required for Internal TCP/UDP Load Balancing and Network Load Balancing; must be omitted for all other load balancer types.
     * </pre>
     *
     * <code>string backend_service = 306946058;</code>
     *
     * @param value The bytes for backendService to set.
     * @return This builder for chaining.
     */
    public Builder setBackendServiceBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000010;
      backendService_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object creationTimestamp_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return Whether the creationTimestamp field is set.
     */
    public boolean hasCreationTimestamp() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The creationTimestamp.
     */
    public java.lang.String getCreationTimestamp() {
      java.lang.Object ref = creationTimestamp_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        creationTimestamp_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return The bytes for creationTimestamp.
     */
    public com.google.protobuf.ByteString getCreationTimestampBytes() {
      java.lang.Object ref = creationTimestamp_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        creationTimestamp_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestamp(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000020;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCreationTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000020);
      creationTimestamp_ = getDefaultInstance().getCreationTimestamp();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Creation timestamp in RFC3339 text format.
     * </pre>
     *
     * <code>string creation_timestamp = 30525366;</code>
     *
     * @param value The bytes for creationTimestamp to set.
     * @return This builder for chaining.
     */
    public Builder setCreationTimestampBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000020;
      creationTimestamp_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object description_ = "";
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return Whether the description field is set.
     */
    public boolean hasDescription() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The description.
     */
    public java.lang.String getDescription() {
      java.lang.Object ref = description_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        description_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return The bytes for description.
     */
    public com.google.protobuf.ByteString getDescriptionBytes() {
      java.lang.Object ref = description_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The description to set.
     * @return This builder for chaining.
     */
    public Builder setDescription(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000040;
      description_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearDescription() {
      bitField0_ = (bitField0_ & ~0x00000040);
      description_ = getDefaultInstance().getDescription();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 422937596;</code>
     *
     * @param value The bytes for description to set.
     * @return This builder for chaining.
     */
    public Builder setDescriptionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000040;
      description_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object fingerprint_ = "";
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return Whether the fingerprint field is set.
     */
    public boolean hasFingerprint() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return The fingerprint.
     */
    public java.lang.String getFingerprint() {
      java.lang.Object ref = fingerprint_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        fingerprint_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return The bytes for fingerprint.
     */
    public com.google.protobuf.ByteString getFingerprintBytes() {
      java.lang.Object ref = fingerprint_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        fingerprint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @param value The fingerprint to set.
     * @return This builder for chaining.
     */
    public Builder setFingerprint(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000080;
      fingerprint_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearFingerprint() {
      bitField0_ = (bitField0_ & ~0x00000080);
      fingerprint_ = getDefaultInstance().getFingerprint();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request.
     * To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
     * </pre>
     *
     * <code>string fingerprint = 234678500;</code>
     *
     * @param value The bytes for fingerprint to set.
     * @return This builder for chaining.
     */
    public Builder setFingerprintBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000080;
      fingerprint_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object id_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return Whether the id field is set.
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The id.
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return The bytes for id.
     */
    public com.google.protobuf.ByteString getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The id to set.
     * @return This builder for chaining.
     */
    public Builder setId(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000100;
      id_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearId() {
      bitField0_ = (bitField0_ & ~0x00000100);
      id_ = getDefaultInstance().getId();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
     * </pre>
     *
     * <code>string id = 3355;</code>
     *
     * @param value The bytes for id to set.
     * @return This builder for chaining.
     */
    public Builder setIdBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000100;
      id_ = value;
      onChanged();
      return this;
    }

    private int ipVersion_ = 0;
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @return Whether the ipVersion field is set.
     */
    @java.lang.Override
    public boolean hasIpVersion() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @return The enum numeric value on the wire for ipVersion.
     */
    @java.lang.Override
    public int getIpVersionValue() {
      return ipVersion_;
    }
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @param value The enum numeric value on the wire for ipVersion to set.
     * @return This builder for chaining.
     */
    public Builder setIpVersionValue(int value) {
      bitField0_ |= 0x00000200;
      ipVersion_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @return The ipVersion.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule.IpVersion getIpVersion() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.ForwardingRule.IpVersion result =
          com.google.cloud.compute.v1.ForwardingRule.IpVersion.valueOf(ipVersion_);
      return result == null
          ? com.google.cloud.compute.v1.ForwardingRule.IpVersion.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @param value The ipVersion to set.
     * @return This builder for chaining.
     */
    public Builder setIpVersion(com.google.cloud.compute.v1.ForwardingRule.IpVersion value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000200;
      ipVersion_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.IpVersion ip_version = 294959552;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIpVersion() {
      bitField0_ = (bitField0_ & ~0x00000200);
      ipVersion_ = 0;
      onChanged();
      return this;
    }

    private boolean isMirroringCollector_;
    /**
     *
     *
     * <pre>
     * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
     * </pre>
     *
     * <code>bool is_mirroring_collector = 119255164;</code>
     *
     * @return Whether the isMirroringCollector field is set.
     */
    @java.lang.Override
    public boolean hasIsMirroringCollector() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     *
     *
     * <pre>
     * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
     * </pre>
     *
     * <code>bool is_mirroring_collector = 119255164;</code>
     *
     * @return The isMirroringCollector.
     */
    @java.lang.Override
    public boolean getIsMirroringCollector() {
      return isMirroringCollector_;
    }
    /**
     *
     *
     * <pre>
     * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
     * </pre>
     *
     * <code>bool is_mirroring_collector = 119255164;</code>
     *
     * @param value The isMirroringCollector to set.
     * @return This builder for chaining.
     */
    public Builder setIsMirroringCollector(boolean value) {
      bitField0_ |= 0x00000400;
      isMirroringCollector_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
     * </pre>
     *
     * <code>bool is_mirroring_collector = 119255164;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIsMirroringCollector() {
      bitField0_ = (bitField0_ & ~0x00000400);
      isMirroringCollector_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object kind_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return Whether the kind field is set.
     */
    public boolean hasKind() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The kind.
     */
    public java.lang.String getKind() {
      java.lang.Object ref = kind_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        kind_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return The bytes for kind.
     */
    public com.google.protobuf.ByteString getKindBytes() {
      java.lang.Object ref = kind_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        kind_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The kind to set.
     * @return This builder for chaining.
     */
    public Builder setKind(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000800;
      kind_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearKind() {
      bitField0_ = (bitField0_ & ~0x00000800);
      kind_ = getDefaultInstance().getKind();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Type of the resource. Always compute#forwardingRule for Forwarding Rule resources.
     * </pre>
     *
     * <code>string kind = 3292052;</code>
     *
     * @param value The bytes for kind to set.
     * @return This builder for chaining.
     */
    public Builder setKindBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00000800;
      kind_ = value;
      onChanged();
      return this;
    }

    private int loadBalancingScheme_ = 0;
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return Whether the loadBalancingScheme field is set.
     */
    @java.lang.Override
    public boolean hasLoadBalancingScheme() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return The enum numeric value on the wire for loadBalancingScheme.
     */
    @java.lang.Override
    public int getLoadBalancingSchemeValue() {
      return loadBalancingScheme_;
    }
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @param value The enum numeric value on the wire for loadBalancingScheme to set.
     * @return This builder for chaining.
     */
    public Builder setLoadBalancingSchemeValue(int value) {
      bitField0_ |= 0x00001000;
      loadBalancingScheme_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return The loadBalancingScheme.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme getLoadBalancingScheme() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme result =
          com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme.valueOf(
              loadBalancingScheme_);
      return result == null
          ? com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @param value The loadBalancingScheme to set.
     * @return This builder for chaining.
     */
    public Builder setLoadBalancingScheme(
        com.google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00001000;
      loadBalancingScheme_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the forwarding rule type.
     * - EXTERNAL is used for:
     * - Classic Cloud VPN gateways
     * - Protocol forwarding to VMs from an external IP address
     * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
     * - INTERNAL is used for:
     * - Protocol forwarding to VMs from an internal IP address
     * - Internal TCP/UDP Load Balancing
     * - INTERNAL_MANAGED is used for:
     * - Internal HTTP(S) Load Balancing
     * - INTERNAL_SELF_MANAGED is used for:
     * - Traffic Director
     * For more information about forwarding rules, refer to Forwarding rule concepts.
     * </pre>
     *
     * <code>
     * .google.cloud.compute.v1.ForwardingRule.LoadBalancingScheme load_balancing_scheme = 363890244;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearLoadBalancingScheme() {
      bitField0_ = (bitField0_ & ~0x00001000);
      loadBalancingScheme_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<com.google.cloud.compute.v1.MetadataFilter> metadataFilters_ =
        java.util.Collections.emptyList();

    private void ensureMetadataFiltersIsMutable() {
      if (!((bitField0_ & 0x00002000) != 0)) {
        metadataFilters_ =
            new java.util.ArrayList<com.google.cloud.compute.v1.MetadataFilter>(metadataFilters_);
        bitField0_ |= 0x00002000;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.MetadataFilter,
            com.google.cloud.compute.v1.MetadataFilter.Builder,
            com.google.cloud.compute.v1.MetadataFilterOrBuilder>
        metadataFiltersBuilder_;

    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public java.util.List<com.google.cloud.compute.v1.MetadataFilter> getMetadataFiltersList() {
      if (metadataFiltersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(metadataFilters_);
      } else {
        return metadataFiltersBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public int getMetadataFiltersCount() {
      if (metadataFiltersBuilder_ == null) {
        return metadataFilters_.size();
      } else {
        return metadataFiltersBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public com.google.cloud.compute.v1.MetadataFilter getMetadataFilters(int index) {
      if (metadataFiltersBuilder_ == null) {
        return metadataFilters_.get(index);
      } else {
        return metadataFiltersBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder setMetadataFilters(int index, com.google.cloud.compute.v1.MetadataFilter value) {
      if (metadataFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataFiltersIsMutable();
        metadataFilters_.set(index, value);
        onChanged();
      } else {
        metadataFiltersBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder setMetadataFilters(
        int index, com.google.cloud.compute.v1.MetadataFilter.Builder builderForValue) {
      if (metadataFiltersBuilder_ == null) {
        ensureMetadataFiltersIsMutable();
        metadataFilters_.set(index, builderForValue.build());
        onChanged();
      } else {
        metadataFiltersBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder addMetadataFilters(com.google.cloud.compute.v1.MetadataFilter value) {
      if (metadataFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataFiltersIsMutable();
        metadataFilters_.add(value);
        onChanged();
      } else {
        metadataFiltersBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder addMetadataFilters(int index, com.google.cloud.compute.v1.MetadataFilter value) {
      if (metadataFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataFiltersIsMutable();
        metadataFilters_.add(index, value);
        onChanged();
      } else {
        metadataFiltersBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder addMetadataFilters(
        com.google.cloud.compute.v1.MetadataFilter.Builder builderForValue) {
      if (metadataFiltersBuilder_ == null) {
        ensureMetadataFiltersIsMutable();
        metadataFilters_.add(builderForValue.build());
        onChanged();
      } else {
        metadataFiltersBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder addMetadataFilters(
        int index, com.google.cloud.compute.v1.MetadataFilter.Builder builderForValue) {
      if (metadataFiltersBuilder_ == null) {
        ensureMetadataFiltersIsMutable();
        metadataFilters_.add(index, builderForValue.build());
        onChanged();
      } else {
        metadataFiltersBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder addAllMetadataFilters(
        java.lang.Iterable<? extends com.google.cloud.compute.v1.MetadataFilter> values) {
      if (metadataFiltersBuilder_ == null) {
        ensureMetadataFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, metadataFilters_);
        onChanged();
      } else {
        metadataFiltersBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder clearMetadataFilters() {
      if (metadataFiltersBuilder_ == null) {
        metadataFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
      } else {
        metadataFiltersBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public Builder removeMetadataFilters(int index) {
      if (metadataFiltersBuilder_ == null) {
        ensureMetadataFiltersIsMutable();
        metadataFilters_.remove(index);
        onChanged();
      } else {
        metadataFiltersBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public com.google.cloud.compute.v1.MetadataFilter.Builder getMetadataFiltersBuilder(int index) {
      return getMetadataFiltersFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public com.google.cloud.compute.v1.MetadataFilterOrBuilder getMetadataFiltersOrBuilder(
        int index) {
      if (metadataFiltersBuilder_ == null) {
        return metadataFilters_.get(index);
      } else {
        return metadataFiltersBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public java.util.List<? extends com.google.cloud.compute.v1.MetadataFilterOrBuilder>
        getMetadataFiltersOrBuilderList() {
      if (metadataFiltersBuilder_ != null) {
        return metadataFiltersBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(metadataFilters_);
      }
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public com.google.cloud.compute.v1.MetadataFilter.Builder addMetadataFiltersBuilder() {
      return getMetadataFiltersFieldBuilder()
          .addBuilder(com.google.cloud.compute.v1.MetadataFilter.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public com.google.cloud.compute.v1.MetadataFilter.Builder addMetadataFiltersBuilder(int index) {
      return getMetadataFiltersFieldBuilder()
          .addBuilder(index, com.google.cloud.compute.v1.MetadataFilter.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Opaque filter criteria used by Loadbalancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to Loadbalancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule will not be visible to those proxies.
     * For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match.
     * metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references.
     * metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
     * </pre>
     *
     * <code>repeated .google.cloud.compute.v1.MetadataFilter metadata_filters = 464725739;</code>
     */
    public java.util.List<com.google.cloud.compute.v1.MetadataFilter.Builder>
        getMetadataFiltersBuilderList() {
      return getMetadataFiltersFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.cloud.compute.v1.MetadataFilter,
            com.google.cloud.compute.v1.MetadataFilter.Builder,
            com.google.cloud.compute.v1.MetadataFilterOrBuilder>
        getMetadataFiltersFieldBuilder() {
      if (metadataFiltersBuilder_ == null) {
        metadataFiltersBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.cloud.compute.v1.MetadataFilter,
                com.google.cloud.compute.v1.MetadataFilter.Builder,
                com.google.cloud.compute.v1.MetadataFilterOrBuilder>(
                metadataFilters_,
                ((bitField0_ & 0x00002000) != 0),
                getParentForChildren(),
                isClean());
        metadataFilters_ = null;
      }
      return metadataFiltersBuilder_;
    }

    private java.lang.Object name_ = "";
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return Whether the name field is set.
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00004000;
      name_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearName() {
      bitField0_ = (bitField0_ & ~0x00004000);
      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00004000;
      name_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object network_ = "";
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return Whether the network field is set.
     */
    public boolean hasNetwork() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The network.
     */
    public java.lang.String getNetwork() {
      java.lang.Object ref = network_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        network_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The bytes for network.
     */
    public com.google.protobuf.ByteString getNetworkBytes() {
      java.lang.Object ref = network_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        network_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The network to set.
     * @return This builder for chaining.
     */
    public Builder setNetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00008000;
      network_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearNetwork() {
      bitField0_ = (bitField0_ & ~0x00008000);
      network_ = getDefaultInstance().getNetwork();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is not used for external load balancing.
     * For Internal TCP/UDP Load Balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The bytes for network to set.
     * @return This builder for chaining.
     */
    public Builder setNetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00008000;
      network_ = value;
      onChanged();
      return this;
    }

    private int networkTier_ = 0;
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @return Whether the networkTier field is set.
     */
    @java.lang.Override
    public boolean hasNetworkTier() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @return The enum numeric value on the wire for networkTier.
     */
    @java.lang.Override
    public int getNetworkTierValue() {
      return networkTier_;
    }
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @param value The enum numeric value on the wire for networkTier to set.
     * @return This builder for chaining.
     */
    public Builder setNetworkTierValue(int value) {
      bitField0_ |= 0x00010000;
      networkTier_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @return The networkTier.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.ForwardingRule.NetworkTier getNetworkTier() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.ForwardingRule.NetworkTier result =
          com.google.cloud.compute.v1.ForwardingRule.NetworkTier.valueOf(networkTier_);
      return result == null
          ? com.google.cloud.compute.v1.ForwardingRule.NetworkTier.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @param value The networkTier to set.
     * @return This builder for chaining.
     */
    public Builder setNetworkTier(com.google.cloud.compute.v1.ForwardingRule.NetworkTier value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00010000;
      networkTier_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
     * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
     * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.ForwardingRule.NetworkTier network_tier = 517397843;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearNetworkTier() {
      bitField0_ = (bitField0_ & ~0x00010000);
      networkTier_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object portRange_ = "";
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @return Whether the portRange field is set.
     */
    public boolean hasPortRange() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @return The portRange.
     */
    public java.lang.String getPortRange() {
      java.lang.Object ref = portRange_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        portRange_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @return The bytes for portRange.
     */
    public com.google.protobuf.ByteString getPortRangeBytes() {
      java.lang.Object ref = portRange_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        portRange_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @param value The portRange to set.
     * @return This builder for chaining.
     */
    public Builder setPortRange(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00020000;
      portRange_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPortRange() {
      bitField0_ = (bitField0_ & ~0x00020000);
      portRange_ = getDefaultInstance().getPortRange();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field can be used only if: * Load balancing scheme is one of EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is one of TCP, UDP, or SCTP.
     * Packets addressed to ports in the specified range will be forwarded to target or  backend_service. You can only use one of ports, port_range, or allPorts. The three are mutually exclusive. Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
     * Some types of forwarding target have constraints on the acceptable ports:
     * - TargetHttpProxy: 80, 8080
     * - TargetHttpsProxy: 443
     * - TargetGrpcProxy: no constraints
     * - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222
     * - TargetVpnGateway: 500, 4500
     * </pre>
     *
     * <code>string port_range = 217518079;</code>
     *
     * @param value The bytes for portRange to set.
     * @return This builder for chaining.
     */
    public Builder setPortRangeBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00020000;
      portRange_ = value;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList ports_ =
        com.google.protobuf.LazyStringArrayList.EMPTY;

    private void ensurePortsIsMutable() {
      if (!((bitField0_ & 0x00040000) != 0)) {
        ports_ = new com.google.protobuf.LazyStringArrayList(ports_);
        bitField0_ |= 0x00040000;
      }
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @return A list containing the ports.
     */
    public com.google.protobuf.ProtocolStringList getPortsList() {
      return ports_.getUnmodifiableView();
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @return The count of ports.
     */
    public int getPortsCount() {
      return ports_.size();
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param index The index of the element to return.
     * @return The ports at the given index.
     */
    public java.lang.String getPorts(int index) {
      return ports_.get(index);
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the ports at the given index.
     */
    public com.google.protobuf.ByteString getPortsBytes(int index) {
      return ports_.getByteString(index);
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param index The index to set the value at.
     * @param value The ports to set.
     * @return This builder for chaining.
     */
    public Builder setPorts(int index, java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensurePortsIsMutable();
      ports_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param value The ports to add.
     * @return This builder for chaining.
     */
    public Builder addPorts(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensurePortsIsMutable();
      ports_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param values The ports to add.
     * @return This builder for chaining.
     */
    public Builder addAllPorts(java.lang.Iterable<java.lang.String> values) {
      ensurePortsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(values, ports_);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPorts() {
      ports_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00040000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The ports field is only supported when the forwarding rule references a backend_service directly. Supported load balancing products are Internal TCP/UDP Load Balancing and Network Load Balancing. Only packets addressed to the specified list of ports are forwarded to backends.
     * You can only use one of ports and port_range, or allPorts. The three are mutually exclusive.
     * You can specify a list of up to five ports, which can be non-contiguous.
     * For Internal TCP/UDP Load Balancing, if you specify allPorts, you should not specify ports.
     * For more information, see [Port specifications](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
     * </pre>
     *
     * <code>repeated string ports = 106854418;</code>
     *
     * @param value The bytes of the ports to add.
     * @return This builder for chaining.
     */
    public Builder addPortsBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      ensurePortsIsMutable();
      ports_.add(value);
      onChanged();
      return this;
    }

    private java.lang.Object region_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return Whether the region field is set.
     */
    public boolean hasRegion() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The region.
     */
    public java.lang.String getRegion() {
      java.lang.Object ref = region_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        region_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return The bytes for region.
     */
    public com.google.protobuf.ByteString getRegionBytes() {
      java.lang.Object ref = region_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        region_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The region to set.
     * @return This builder for chaining.
     */
    public Builder setRegion(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00080000;
      region_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearRegion() {
      bitField0_ = (bitField0_ & ~0x00080000);
      region_ = getDefaultInstance().getRegion();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
     * </pre>
     *
     * <code>string region = 138946292;</code>
     *
     * @param value The bytes for region to set.
     * @return This builder for chaining.
     */
    public Builder setRegionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00080000;
      region_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object selfLink_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return Whether the selfLink field is set.
     */
    public boolean hasSelfLink() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The selfLink.
     */
    public java.lang.String getSelfLink() {
      java.lang.Object ref = selfLink_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        selfLink_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return The bytes for selfLink.
     */
    public com.google.protobuf.ByteString getSelfLinkBytes() {
      java.lang.Object ref = selfLink_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        selfLink_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLink(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00100000;
      selfLink_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSelfLink() {
      bitField0_ = (bitField0_ & ~0x00100000);
      selfLink_ = getDefaultInstance().getSelfLink();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>string self_link = 456214797;</code>
     *
     * @param value The bytes for selfLink to set.
     * @return This builder for chaining.
     */
    public Builder setSelfLinkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00100000;
      selfLink_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object serviceLabel_ = "";
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @return Whether the serviceLabel field is set.
     */
    public boolean hasServiceLabel() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @return The serviceLabel.
     */
    public java.lang.String getServiceLabel() {
      java.lang.Object ref = serviceLabel_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceLabel_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @return The bytes for serviceLabel.
     */
    public com.google.protobuf.ByteString getServiceLabelBytes() {
      java.lang.Object ref = serviceLabel_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        serviceLabel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @param value The serviceLabel to set.
     * @return This builder for chaining.
     */
    public Builder setServiceLabel(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00200000;
      serviceLabel_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearServiceLabel() {
      bitField0_ = (bitField0_ & ~0x00200000);
      serviceLabel_ = getDefaultInstance().getServiceLabel();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional prefix to the service name for this Forwarding Rule. If specified, the prefix is the first label of the fully qualified service name.
     * The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_label = 417008874;</code>
     *
     * @param value The bytes for serviceLabel to set.
     * @return This builder for chaining.
     */
    public Builder setServiceLabelBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00200000;
      serviceLabel_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object serviceName_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @return Whether the serviceName field is set.
     */
    public boolean hasServiceName() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @return The serviceName.
     */
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @return The bytes for serviceName.
     */
    public com.google.protobuf.ByteString getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @param value The serviceName to set.
     * @return This builder for chaining.
     */
    public Builder setServiceName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00400000;
      serviceName_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearServiceName() {
      bitField0_ = (bitField0_ & ~0x00400000);
      serviceName_ = getDefaultInstance().getServiceName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] The internal fully qualified service name for this Forwarding Rule.
     * This field is only used for internal load balancing.
     * </pre>
     *
     * <code>string service_name = 359880149;</code>
     *
     * @param value The bytes for serviceName to set.
     * @return This builder for chaining.
     */
    public Builder setServiceNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00400000;
      serviceName_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object subnetwork_ = "";
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @return Whether the subnetwork field is set.
     */
    public boolean hasSubnetwork() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @return The subnetwork.
     */
    public java.lang.String getSubnetwork() {
      java.lang.Object ref = subnetwork_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        subnetwork_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @return The bytes for subnetwork.
     */
    public com.google.protobuf.ByteString getSubnetworkBytes() {
      java.lang.Object ref = subnetwork_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        subnetwork_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @param value The subnetwork to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00800000;
      subnetwork_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSubnetwork() {
      bitField0_ = (bitField0_ & ~0x00800000);
      subnetwork_ = getDefaultInstance().getSubnetwork();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field is only used for internal load balancing.
     * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
     * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
     * </pre>
     *
     * <code>string subnetwork = 307827694;</code>
     *
     * @param value The bytes for subnetwork to set.
     * @return This builder for chaining.
     */
    public Builder setSubnetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x00800000;
      subnetwork_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object target_ = "";
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @return Whether the target field is set.
     */
    public boolean hasTarget() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @return The target.
     */
    public java.lang.String getTarget() {
      java.lang.Object ref = target_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        target_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @return The bytes for target.
     */
    public com.google.protobuf.ByteString getTargetBytes() {
      java.lang.Object ref = target_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        target_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @param value The target to set.
     * @return This builder for chaining.
     */
    public Builder setTarget(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x01000000;
      target_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTarget() {
      bitField0_ = (bitField0_ & ~0x01000000);
      target_ = getDefaultInstance().getTarget();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. For more information, see the "Target" column in [Port specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
     * For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle. Currently, the supported Google API bundles include:
     * - vpc-sc - GCP APIs that support VPC Service Controls. For more information about which APIs support VPC Service Controls, refer to VPC-SC supported products and limitations.
     * - all-apis - All GCP APIs. For more information about which APIs are supported with this bundle, refer to Private Google Access-specific domains and VIPs.
     * </pre>
     *
     * <code>string target = 192835985;</code>
     *
     * @param value The bytes for target to set.
     * @return This builder for chaining.
     */
    public Builder setTargetBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      bitField0_ |= 0x01000000;
      target_ = value;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.ForwardingRule)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.ForwardingRule)
  private static final com.google.cloud.compute.v1.ForwardingRule DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.ForwardingRule();
  }

  public static com.google.cloud.compute.v1.ForwardingRule getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<ForwardingRule> PARSER =
      new com.google.protobuf.AbstractParser<ForwardingRule>() {
        @java.lang.Override
        public ForwardingRule parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ForwardingRule(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<ForwardingRule> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<ForwardingRule> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.ForwardingRule getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
