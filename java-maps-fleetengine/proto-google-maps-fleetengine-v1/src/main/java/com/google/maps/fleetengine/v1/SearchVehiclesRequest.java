/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/maps/fleetengine/v1/vehicle_api.proto

package google.maps.fleetengine.v1;

/**
 *
 *
 * <pre>
 * `SearchVehicles` request message.
 * </pre>
 *
 * Protobuf type {@code maps.fleetengine.v1.SearchVehiclesRequest}
 */
public final class SearchVehiclesRequest extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:maps.fleetengine.v1.SearchVehiclesRequest)
    SearchVehiclesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use SearchVehiclesRequest.newBuilder() to construct.
  private SearchVehiclesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private SearchVehiclesRequest() {
    parent_ = "";
    tripTypes_ = java.util.Collections.emptyList();
    vehicleTypes_ = java.util.Collections.emptyList();
    requiredAttributes_ = java.util.Collections.emptyList();
    requiredOneOfAttributes_ = java.util.Collections.emptyList();
    requiredOneOfAttributeSets_ = java.util.Collections.emptyList();
    orderBy_ = 0;
    tripId_ = "";
    currentTripsPresent_ = 0;
    filter_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new SearchVehiclesRequest();
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return google.maps.fleetengine.v1.VehicleApi
        .internal_static_maps_fleetengine_v1_SearchVehiclesRequest_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return google.maps.fleetengine.v1.VehicleApi
        .internal_static_maps_fleetengine_v1_SearchVehiclesRequest_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            google.maps.fleetengine.v1.SearchVehiclesRequest.class,
            google.maps.fleetengine.v1.SearchVehiclesRequest.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * Specifies the order of the vehicle matches in the response.
   * </pre>
   *
   * Protobuf enum {@code maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder}
   */
  public enum VehicleMatchOrder implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Default, used for unspecified or unrecognized vehicle matches order.
     * </pre>
     *
     * <code>UNKNOWN_VEHICLE_MATCH_ORDER = 0;</code>
     */
    UNKNOWN_VEHICLE_MATCH_ORDER(0),
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving time to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_ETA = 1;</code>
     */
    PICKUP_POINT_ETA(1),
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving distance to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_DISTANCE = 2;</code>
     */
    PICKUP_POINT_DISTANCE(2),
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving time to the dropoff point. This order
     * can only be used if the dropoff point is specified in the request.
     * </pre>
     *
     * <code>DROPOFF_POINT_ETA = 3;</code>
     */
    DROPOFF_POINT_ETA(3),
    /**
     *
     *
     * <pre>
     * Ascending order by straight-line distance from the vehicle's last
     * reported location to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_STRAIGHT_DISTANCE = 4;</code>
     */
    PICKUP_POINT_STRAIGHT_DISTANCE(4),
    /**
     *
     *
     * <pre>
     * Ascending order by the configured match cost. Match cost is defined as a
     * weighted calculation between straight-line distance and ETA. Weights are
     * set with default values and can be modified per customer. Please contact
     * Google support if these weights need to be modified for your project.
     * </pre>
     *
     * <code>COST = 5;</code>
     */
    COST(5),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Default, used for unspecified or unrecognized vehicle matches order.
     * </pre>
     *
     * <code>UNKNOWN_VEHICLE_MATCH_ORDER = 0;</code>
     */
    public static final int UNKNOWN_VEHICLE_MATCH_ORDER_VALUE = 0;
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving time to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_ETA = 1;</code>
     */
    public static final int PICKUP_POINT_ETA_VALUE = 1;
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving distance to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_DISTANCE = 2;</code>
     */
    public static final int PICKUP_POINT_DISTANCE_VALUE = 2;
    /**
     *
     *
     * <pre>
     * Ascending order by vehicle driving time to the dropoff point. This order
     * can only be used if the dropoff point is specified in the request.
     * </pre>
     *
     * <code>DROPOFF_POINT_ETA = 3;</code>
     */
    public static final int DROPOFF_POINT_ETA_VALUE = 3;
    /**
     *
     *
     * <pre>
     * Ascending order by straight-line distance from the vehicle's last
     * reported location to the pickup point.
     * </pre>
     *
     * <code>PICKUP_POINT_STRAIGHT_DISTANCE = 4;</code>
     */
    public static final int PICKUP_POINT_STRAIGHT_DISTANCE_VALUE = 4;
    /**
     *
     *
     * <pre>
     * Ascending order by the configured match cost. Match cost is defined as a
     * weighted calculation between straight-line distance and ETA. Weights are
     * set with default values and can be modified per customer. Please contact
     * Google support if these weights need to be modified for your project.
     * </pre>
     *
     * <code>COST = 5;</code>
     */
    public static final int COST_VALUE = 5;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static VehicleMatchOrder valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static VehicleMatchOrder forNumber(int value) {
      switch (value) {
        case 0:
          return UNKNOWN_VEHICLE_MATCH_ORDER;
        case 1:
          return PICKUP_POINT_ETA;
        case 2:
          return PICKUP_POINT_DISTANCE;
        case 3:
          return DROPOFF_POINT_ETA;
        case 4:
          return PICKUP_POINT_STRAIGHT_DISTANCE;
        case 5:
          return COST;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<VehicleMatchOrder>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<VehicleMatchOrder>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VehicleMatchOrder>() {
              public VehicleMatchOrder findValueByNumber(int number) {
                return VehicleMatchOrder.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return google.maps.fleetengine.v1.SearchVehiclesRequest.getDescriptor().getEnumTypes().get(0);
    }

    private static final VehicleMatchOrder[] VALUES = values();

    public static VehicleMatchOrder valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private VehicleMatchOrder(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder)
  }

  /**
   *
   *
   * <pre>
   * Specifies the types of restrictions on a vehicle's current trips.
   * </pre>
   *
   * Protobuf enum {@code maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent}
   */
  public enum CurrentTripsPresent implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Only vehicles without trips can appear in search results.
     * A validation exception is thrown if `include_back_to_back` is true. See
     * the `include_back_to_back` flag for more details.
     * </pre>
     *
     * <code>CURRENT_TRIPS_PRESENT_UNSPECIFIED = 0;</code>
     */
    CURRENT_TRIPS_PRESENT_UNSPECIFIED(0),
    /**
     *
     *
     * <pre>
     * Vehicles without trips can appear in search results.
     * A validation exception is thrown if `include_back_to_back` is true.
     * </pre>
     *
     * <code>NONE = 1;</code>
     */
    NONE(1),
    /**
     *
     *
     * <pre>
     * Vehicles with at most 5 current trips and 10 waypoints are included
     * in the search results.
     * A validation exception is thrown if `include_back_to_back` is true.
     * </pre>
     *
     * <code>ANY = 2;</code>
     */
    ANY(2),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Only vehicles without trips can appear in search results.
     * A validation exception is thrown if `include_back_to_back` is true. See
     * the `include_back_to_back` flag for more details.
     * </pre>
     *
     * <code>CURRENT_TRIPS_PRESENT_UNSPECIFIED = 0;</code>
     */
    public static final int CURRENT_TRIPS_PRESENT_UNSPECIFIED_VALUE = 0;
    /**
     *
     *
     * <pre>
     * Vehicles without trips can appear in search results.
     * A validation exception is thrown if `include_back_to_back` is true.
     * </pre>
     *
     * <code>NONE = 1;</code>
     */
    public static final int NONE_VALUE = 1;
    /**
     *
     *
     * <pre>
     * Vehicles with at most 5 current trips and 10 waypoints are included
     * in the search results.
     * A validation exception is thrown if `include_back_to_back` is true.
     * </pre>
     *
     * <code>ANY = 2;</code>
     */
    public static final int ANY_VALUE = 2;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CurrentTripsPresent valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CurrentTripsPresent forNumber(int value) {
      switch (value) {
        case 0:
          return CURRENT_TRIPS_PRESENT_UNSPECIFIED;
        case 1:
          return NONE;
        case 2:
          return ANY;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CurrentTripsPresent>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<CurrentTripsPresent>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CurrentTripsPresent>() {
              public CurrentTripsPresent findValueByNumber(int number) {
                return CurrentTripsPresent.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return google.maps.fleetengine.v1.SearchVehiclesRequest.getDescriptor().getEnumTypes().get(1);
    }

    private static final CurrentTripsPresent[] VALUES = values();

    public static CurrentTripsPresent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CurrentTripsPresent(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent)
  }

  public static final int HEADER_FIELD_NUMBER = 1;
  private google.maps.fleetengine.v1.RequestHeader header_;
  /**
   *
   *
   * <pre>
   * The standard Fleet Engine request header.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
   *
   * @return Whether the header field is set.
   */
  @java.lang.Override
  public boolean hasHeader() {
    return header_ != null;
  }
  /**
   *
   *
   * <pre>
   * The standard Fleet Engine request header.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
   *
   * @return The header.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.RequestHeader getHeader() {
    return header_ == null
        ? google.maps.fleetengine.v1.RequestHeader.getDefaultInstance()
        : header_;
  }
  /**
   *
   *
   * <pre>
   * The standard Fleet Engine request header.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.RequestHeaderOrBuilder getHeaderOrBuilder() {
    return header_ == null
        ? google.maps.fleetengine.v1.RequestHeader.getDefaultInstance()
        : header_;
  }

  public static final int PARENT_FIELD_NUMBER = 3;

  @SuppressWarnings("serial")
  private volatile java.lang.Object parent_ = "";
  /**
   *
   *
   * <pre>
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   * </pre>
   *
   * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   *
   * @return The parent.
   */
  @java.lang.Override
  public java.lang.String getParent() {
    java.lang.Object ref = parent_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      parent_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   * </pre>
   *
   * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   *
   * @return The bytes for parent.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getParentBytes() {
    java.lang.Object ref = parent_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      parent_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PICKUP_POINT_FIELD_NUMBER = 4;
  private google.maps.fleetengine.v1.TerminalLocation pickupPoint_;
  /**
   *
   *
   * <pre>
   * Required. The pickup point to search near.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return Whether the pickupPoint field is set.
   */
  @java.lang.Override
  public boolean hasPickupPoint() {
    return pickupPoint_ != null;
  }
  /**
   *
   *
   * <pre>
   * Required. The pickup point to search near.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return The pickupPoint.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.TerminalLocation getPickupPoint() {
    return pickupPoint_ == null
        ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
        : pickupPoint_;
  }
  /**
   *
   *
   * <pre>
   * Required. The pickup point to search near.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.TerminalLocationOrBuilder getPickupPointOrBuilder() {
    return pickupPoint_ == null
        ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
        : pickupPoint_;
  }

  public static final int DROPOFF_POINT_FIELD_NUMBER = 5;
  private google.maps.fleetengine.v1.TerminalLocation dropoffPoint_;
  /**
   *
   *
   * <pre>
   * The customer's intended dropoff location. The field is required if
   * `trip_types` contains `TripType.SHARED`.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
   *
   * @return Whether the dropoffPoint field is set.
   */
  @java.lang.Override
  public boolean hasDropoffPoint() {
    return dropoffPoint_ != null;
  }
  /**
   *
   *
   * <pre>
   * The customer's intended dropoff location. The field is required if
   * `trip_types` contains `TripType.SHARED`.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
   *
   * @return The dropoffPoint.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.TerminalLocation getDropoffPoint() {
    return dropoffPoint_ == null
        ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
        : dropoffPoint_;
  }
  /**
   *
   *
   * <pre>
   * The customer's intended dropoff location. The field is required if
   * `trip_types` contains `TripType.SHARED`.
   * </pre>
   *
   * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.TerminalLocationOrBuilder getDropoffPointOrBuilder() {
    return dropoffPoint_ == null
        ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
        : dropoffPoint_;
  }

  public static final int PICKUP_RADIUS_METERS_FIELD_NUMBER = 6;
  private int pickupRadiusMeters_ = 0;
  /**
   *
   *
   * <pre>
   * Required. Defines the vehicle search radius around the pickup point. Only
   * vehicles within the search radius will be returned. Value must be between
   * 400 and 10000 meters (inclusive).
   * </pre>
   *
   * <code>int32 pickup_radius_meters = 6 [(.google.api.field_behavior) = REQUIRED];</code>
   *
   * @return The pickupRadiusMeters.
   */
  @java.lang.Override
  public int getPickupRadiusMeters() {
    return pickupRadiusMeters_;
  }

  public static final int COUNT_FIELD_NUMBER = 7;
  private int count_ = 0;
  /**
   *
   *
   * <pre>
   * Required. Specifies the maximum number of vehicles to return. The value
   * must be between 1 and 50 (inclusive).
   * </pre>
   *
   * <code>int32 count = 7 [(.google.api.field_behavior) = REQUIRED];</code>
   *
   * @return The count.
   */
  @java.lang.Override
  public int getCount() {
    return count_;
  }

  public static final int MINIMUM_CAPACITY_FIELD_NUMBER = 8;
  private int minimumCapacity_ = 0;
  /**
   *
   *
   * <pre>
   * Required. Specifies the number of passengers being considered for a trip.
   * The value must be greater than or equal to one. The driver is not
   * considered in the capacity value.
   * </pre>
   *
   * <code>int32 minimum_capacity = 8 [(.google.api.field_behavior) = REQUIRED];</code>
   *
   * @return The minimumCapacity.
   */
  @java.lang.Override
  public int getMinimumCapacity() {
    return minimumCapacity_;
  }

  public static final int TRIP_TYPES_FIELD_NUMBER = 9;

  @SuppressWarnings("serial")
  private java.util.List<java.lang.Integer> tripTypes_;

  private static final com.google.protobuf.Internal.ListAdapter.Converter<
          java.lang.Integer, google.maps.fleetengine.v1.TripType>
      tripTypes_converter_ =
          new com.google.protobuf.Internal.ListAdapter.Converter<
              java.lang.Integer, google.maps.fleetengine.v1.TripType>() {
            public google.maps.fleetengine.v1.TripType convert(java.lang.Integer from) {
              google.maps.fleetengine.v1.TripType result =
                  google.maps.fleetengine.v1.TripType.forNumber(from);
              return result == null ? google.maps.fleetengine.v1.TripType.UNRECOGNIZED : result;
            }
          };
  /**
   *
   *
   * <pre>
   * Required. Represents the type of proposed trip. Eligible vehicles are those
   * that can support at least one of the specified trip type.
   *
   * `EXCLUSIVE` and `SHARED` may not be included together.
   * `SHARED` is not supported when `current_trips_present` is
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return A list containing the tripTypes.
   */
  @java.lang.Override
  public java.util.List<google.maps.fleetengine.v1.TripType> getTripTypesList() {
    return new com.google.protobuf.Internal.ListAdapter<
        java.lang.Integer, google.maps.fleetengine.v1.TripType>(tripTypes_, tripTypes_converter_);
  }
  /**
   *
   *
   * <pre>
   * Required. Represents the type of proposed trip. Eligible vehicles are those
   * that can support at least one of the specified trip type.
   *
   * `EXCLUSIVE` and `SHARED` may not be included together.
   * `SHARED` is not supported when `current_trips_present` is
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return The count of tripTypes.
   */
  @java.lang.Override
  public int getTripTypesCount() {
    return tripTypes_.size();
  }
  /**
   *
   *
   * <pre>
   * Required. Represents the type of proposed trip. Eligible vehicles are those
   * that can support at least one of the specified trip type.
   *
   * `EXCLUSIVE` and `SHARED` may not be included together.
   * `SHARED` is not supported when `current_trips_present` is
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @param index The index of the element to return.
   * @return The tripTypes at the given index.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.TripType getTripTypes(int index) {
    return tripTypes_converter_.convert(tripTypes_.get(index));
  }
  /**
   *
   *
   * <pre>
   * Required. Represents the type of proposed trip. Eligible vehicles are those
   * that can support at least one of the specified trip type.
   *
   * `EXCLUSIVE` and `SHARED` may not be included together.
   * `SHARED` is not supported when `current_trips_present` is
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return A list containing the enum numeric values on the wire for tripTypes.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer> getTripTypesValueList() {
    return tripTypes_;
  }
  /**
   *
   *
   * <pre>
   * Required. Represents the type of proposed trip. Eligible vehicles are those
   * that can support at least one of the specified trip type.
   *
   * `EXCLUSIVE` and `SHARED` may not be included together.
   * `SHARED` is not supported when `current_trips_present` is
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @param index The index of the value to return.
   * @return The enum numeric value on the wire of tripTypes at the given index.
   */
  @java.lang.Override
  public int getTripTypesValue(int index) {
    return tripTypes_.get(index);
  }

  private int tripTypesMemoizedSerializedSize;

  public static final int MAXIMUM_STALENESS_FIELD_NUMBER = 10;
  private com.google.protobuf.Duration maximumStaleness_;
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles that have sent location updates
   * to Fleet Engine within the specified duration. Stationary vehicles still
   * transmitting their locations are not considered stale. If this field is not
   * set, the server uses five minutes as the default value.
   * </pre>
   *
   * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
   *
   * @return Whether the maximumStaleness field is set.
   */
  @java.lang.Override
  public boolean hasMaximumStaleness() {
    return maximumStaleness_ != null;
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles that have sent location updates
   * to Fleet Engine within the specified duration. Stationary vehicles still
   * transmitting their locations are not considered stale. If this field is not
   * set, the server uses five minutes as the default value.
   * </pre>
   *
   * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
   *
   * @return The maximumStaleness.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getMaximumStaleness() {
    return maximumStaleness_ == null
        ? com.google.protobuf.Duration.getDefaultInstance()
        : maximumStaleness_;
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles that have sent location updates
   * to Fleet Engine within the specified duration. Stationary vehicles still
   * transmitting their locations are not considered stale. If this field is not
   * set, the server uses five minutes as the default value.
   * </pre>
   *
   * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getMaximumStalenessOrBuilder() {
    return maximumStaleness_ == null
        ? com.google.protobuf.Duration.getDefaultInstance()
        : maximumStaleness_;
  }

  public static final int VEHICLE_TYPES_FIELD_NUMBER = 14;

  @SuppressWarnings("serial")
  private java.util.List<google.maps.fleetengine.v1.Vehicle.VehicleType> vehicleTypes_;
  /**
   *
   *
   * <pre>
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public java.util.List<google.maps.fleetengine.v1.Vehicle.VehicleType> getVehicleTypesList() {
    return vehicleTypes_;
  }
  /**
   *
   *
   * <pre>
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public java.util.List<? extends google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder>
      getVehicleTypesOrBuilderList() {
    return vehicleTypes_;
  }
  /**
   *
   *
   * <pre>
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public int getVehicleTypesCount() {
    return vehicleTypes_.size();
  }
  /**
   *
   *
   * <pre>
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.Vehicle.VehicleType getVehicleTypes(int index) {
    return vehicleTypes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   * </pre>
   *
   * <code>
   * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder getVehicleTypesOrBuilder(
      int index) {
    return vehicleTypes_.get(index);
  }

  public static final int REQUIRED_ATTRIBUTES_FIELD_NUMBER = 12;

  @SuppressWarnings("serial")
  private java.util.List<google.maps.fleetengine.v1.VehicleAttribute> requiredAttributes_;
  /**
   *
   *
   * <pre>
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
   */
  @java.lang.Override
  public java.util.List<google.maps.fleetengine.v1.VehicleAttribute> getRequiredAttributesList() {
    return requiredAttributes_;
  }
  /**
   *
   *
   * <pre>
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
   */
  @java.lang.Override
  public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeOrBuilder>
      getRequiredAttributesOrBuilderList() {
    return requiredAttributes_;
  }
  /**
   *
   *
   * <pre>
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
   */
  @java.lang.Override
  public int getRequiredAttributesCount() {
    return requiredAttributes_.size();
  }
  /**
   *
   *
   * <pre>
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttribute getRequiredAttributes(int index) {
    return requiredAttributes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttributeOrBuilder getRequiredAttributesOrBuilder(
      int index) {
    return requiredAttributes_.get(index);
  }

  public static final int REQUIRED_ONE_OF_ATTRIBUTES_FIELD_NUMBER = 15;

  @SuppressWarnings("serial")
  private java.util.List<google.maps.fleetengine.v1.VehicleAttributeList> requiredOneOfAttributes_;
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
   * </code>
   */
  @java.lang.Override
  public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
      getRequiredOneOfAttributesList() {
    return requiredOneOfAttributes_;
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
   * </code>
   */
  @java.lang.Override
  public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
      getRequiredOneOfAttributesOrBuilderList() {
    return requiredOneOfAttributes_;
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
   * </code>
   */
  @java.lang.Override
  public int getRequiredOneOfAttributesCount() {
    return requiredOneOfAttributes_.size();
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttributeList getRequiredOneOfAttributes(int index) {
    return requiredOneOfAttributes_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttributeListOrBuilder
      getRequiredOneOfAttributesOrBuilder(int index) {
    return requiredOneOfAttributes_.get(index);
  }

  public static final int REQUIRED_ONE_OF_ATTRIBUTE_SETS_FIELD_NUMBER = 20;

  @SuppressWarnings("serial")
  private java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
      requiredOneOfAttributeSets_;
  /**
   *
   *
   * <pre>
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
   * </code>
   */
  @java.lang.Override
  public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
      getRequiredOneOfAttributeSetsList() {
    return requiredOneOfAttributeSets_;
  }
  /**
   *
   *
   * <pre>
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
   * </code>
   */
  @java.lang.Override
  public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
      getRequiredOneOfAttributeSetsOrBuilderList() {
    return requiredOneOfAttributeSets_;
  }
  /**
   *
   *
   * <pre>
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
   * </code>
   */
  @java.lang.Override
  public int getRequiredOneOfAttributeSetsCount() {
    return requiredOneOfAttributeSets_.size();
  }
  /**
   *
   *
   * <pre>
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttributeList getRequiredOneOfAttributeSets(int index) {
    return requiredOneOfAttributeSets_.get(index);
  }
  /**
   *
   *
   * <pre>
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   * </pre>
   *
   * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
   * </code>
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.VehicleAttributeListOrBuilder
      getRequiredOneOfAttributeSetsOrBuilder(int index) {
    return requiredOneOfAttributeSets_.get(index);
  }

  public static final int ORDER_BY_FIELD_NUMBER = 13;
  private int orderBy_ = 0;
  /**
   *
   *
   * <pre>
   * Required. Specifies the desired ordering criterion for results.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return The enum numeric value on the wire for orderBy.
   */
  @java.lang.Override
  public int getOrderByValue() {
    return orderBy_;
  }
  /**
   *
   *
   * <pre>
   * Required. Specifies the desired ordering criterion for results.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
   * </code>
   *
   * @return The orderBy.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder getOrderBy() {
    google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder result =
        google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder.forNumber(orderBy_);
    return result == null
        ? google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder.UNRECOGNIZED
        : result;
  }

  public static final int INCLUDE_BACK_TO_BACK_FIELD_NUMBER = 18;
  private boolean includeBackToBack_ = false;
  /**
   *
   *
   * <pre>
   * Indicates if a vehicle with a single active trip is eligible for another
   * match. If `false`, vehicles with assigned trips are excluded from the
   * search results. If `true`, search results include vehicles with
   * `TripStatus` of `ENROUTE_TO_DROPOFF`.
   *
   * This field is only considered if a single `trip_type` of `EXCLUSIVE` is
   * specified.
   *
   * The default value is `false`.
   * </pre>
   *
   * <code>bool include_back_to_back = 18;</code>
   *
   * @return The includeBackToBack.
   */
  @java.lang.Override
  public boolean getIncludeBackToBack() {
    return includeBackToBack_;
  }

  public static final int TRIP_ID_FIELD_NUMBER = 19;

  @SuppressWarnings("serial")
  private volatile java.lang.Object tripId_ = "";
  /**
   *
   *
   * <pre>
   * Indicates the trip associated with this `SearchVehicleRequest`.
   * </pre>
   *
   * <code>string trip_id = 19;</code>
   *
   * @return The tripId.
   */
  @java.lang.Override
  public java.lang.String getTripId() {
    java.lang.Object ref = tripId_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      tripId_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Indicates the trip associated with this `SearchVehicleRequest`.
   * </pre>
   *
   * <code>string trip_id = 19;</code>
   *
   * @return The bytes for tripId.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getTripIdBytes() {
    java.lang.Object ref = tripId_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      tripId_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int CURRENT_TRIPS_PRESENT_FIELD_NUMBER = 21;
  private int currentTripsPresent_ = 0;
  /**
   *
   *
   * <pre>
   * Restricts vehicles from appearing in the search results based on
   * their current trips.
   *
   * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
   * `EXCLUSIVE` or `SHARED`, but not both.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
   * </code>
   *
   * @return The enum numeric value on the wire for currentTripsPresent.
   */
  @java.lang.Override
  public int getCurrentTripsPresentValue() {
    return currentTripsPresent_;
  }
  /**
   *
   *
   * <pre>
   * Restricts vehicles from appearing in the search results based on
   * their current trips.
   *
   * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
   * `EXCLUSIVE` or `SHARED`, but not both.
   * </pre>
   *
   * <code>
   * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
   * </code>
   *
   * @return The currentTripsPresent.
   */
  @java.lang.Override
  public google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent
      getCurrentTripsPresent() {
    google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent result =
        google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent.forNumber(
            currentTripsPresent_);
    return result == null
        ? google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent.UNRECOGNIZED
        : result;
  }

  public static final int FILTER_FIELD_NUMBER = 22;

  @SuppressWarnings("serial")
  private volatile java.lang.Object filter_ = "";
  /**
   *
   *
   * <pre>
   * Optional. A filter query to apply when searching vehicles. See
   * http://aip.dev/160 for examples of the filter syntax.
   *
   * This field is designed to replace the `required_attributes`,
   * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
   * If a non-empty value is specified here, the following fields must be empty:
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attributes_sets`.
   *
   * This filter functions as an AND clause with other constraints,
   * such as `minimum_capacity` or `vehicle_types`.
   *
   * Note that the only queries supported are on vehicle attributes (for
   * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
   * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
   * in a filter query is 50.
   *
   * Also, all attributes are stored as strings, so the only supported
   * comparisons against attributes are string comparisons. In order to compare
   * against number or boolean values, the values must be explicitly quoted to
   * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
   * `attributes.&lt;key&gt; = "true"`).
   * </pre>
   *
   * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The filter.
   */
  @java.lang.Override
  public java.lang.String getFilter() {
    java.lang.Object ref = filter_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      filter_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Optional. A filter query to apply when searching vehicles. See
   * http://aip.dev/160 for examples of the filter syntax.
   *
   * This field is designed to replace the `required_attributes`,
   * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
   * If a non-empty value is specified here, the following fields must be empty:
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attributes_sets`.
   *
   * This filter functions as an AND clause with other constraints,
   * such as `minimum_capacity` or `vehicle_types`.
   *
   * Note that the only queries supported are on vehicle attributes (for
   * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
   * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
   * in a filter query is 50.
   *
   * Also, all attributes are stored as strings, so the only supported
   * comparisons against attributes are string comparisons. In order to compare
   * against number or boolean values, the values must be explicitly quoted to
   * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
   * `attributes.&lt;key&gt; = "true"`).
   * </pre>
   *
   * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The bytes for filter.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getFilterBytes() {
    java.lang.Object ref = filter_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      filter_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (header_ != null) {
      output.writeMessage(1, getHeader());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(parent_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, parent_);
    }
    if (pickupPoint_ != null) {
      output.writeMessage(4, getPickupPoint());
    }
    if (dropoffPoint_ != null) {
      output.writeMessage(5, getDropoffPoint());
    }
    if (pickupRadiusMeters_ != 0) {
      output.writeInt32(6, pickupRadiusMeters_);
    }
    if (count_ != 0) {
      output.writeInt32(7, count_);
    }
    if (minimumCapacity_ != 0) {
      output.writeInt32(8, minimumCapacity_);
    }
    if (getTripTypesList().size() > 0) {
      output.writeUInt32NoTag(74);
      output.writeUInt32NoTag(tripTypesMemoizedSerializedSize);
    }
    for (int i = 0; i < tripTypes_.size(); i++) {
      output.writeEnumNoTag(tripTypes_.get(i));
    }
    if (maximumStaleness_ != null) {
      output.writeMessage(10, getMaximumStaleness());
    }
    for (int i = 0; i < requiredAttributes_.size(); i++) {
      output.writeMessage(12, requiredAttributes_.get(i));
    }
    if (orderBy_
        != google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder
            .UNKNOWN_VEHICLE_MATCH_ORDER
            .getNumber()) {
      output.writeEnum(13, orderBy_);
    }
    for (int i = 0; i < vehicleTypes_.size(); i++) {
      output.writeMessage(14, vehicleTypes_.get(i));
    }
    for (int i = 0; i < requiredOneOfAttributes_.size(); i++) {
      output.writeMessage(15, requiredOneOfAttributes_.get(i));
    }
    if (includeBackToBack_ != false) {
      output.writeBool(18, includeBackToBack_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 19, tripId_);
    }
    for (int i = 0; i < requiredOneOfAttributeSets_.size(); i++) {
      output.writeMessage(20, requiredOneOfAttributeSets_.get(i));
    }
    if (currentTripsPresent_
        != google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent
            .CURRENT_TRIPS_PRESENT_UNSPECIFIED
            .getNumber()) {
      output.writeEnum(21, currentTripsPresent_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(filter_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 22, filter_);
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (header_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getHeader());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(parent_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, parent_);
    }
    if (pickupPoint_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, getPickupPoint());
    }
    if (dropoffPoint_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getDropoffPoint());
    }
    if (pickupRadiusMeters_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(6, pickupRadiusMeters_);
    }
    if (count_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(7, count_);
    }
    if (minimumCapacity_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(8, minimumCapacity_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < tripTypes_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream.computeEnumSizeNoTag(tripTypes_.get(i));
      }
      size += dataSize;
      if (!getTripTypesList().isEmpty()) {
        size += 1;
        size += com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(dataSize);
      }
      tripTypesMemoizedSerializedSize = dataSize;
    }
    if (maximumStaleness_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(10, getMaximumStaleness());
    }
    for (int i = 0; i < requiredAttributes_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(12, requiredAttributes_.get(i));
    }
    if (orderBy_
        != google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder
            .UNKNOWN_VEHICLE_MATCH_ORDER
            .getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(13, orderBy_);
    }
    for (int i = 0; i < vehicleTypes_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(14, vehicleTypes_.get(i));
    }
    for (int i = 0; i < requiredOneOfAttributes_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              15, requiredOneOfAttributes_.get(i));
    }
    if (includeBackToBack_ != false) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(18, includeBackToBack_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(tripId_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(19, tripId_);
    }
    for (int i = 0; i < requiredOneOfAttributeSets_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              20, requiredOneOfAttributeSets_.get(i));
    }
    if (currentTripsPresent_
        != google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent
            .CURRENT_TRIPS_PRESENT_UNSPECIFIED
            .getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(21, currentTripsPresent_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(filter_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, filter_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof google.maps.fleetengine.v1.SearchVehiclesRequest)) {
      return super.equals(obj);
    }
    google.maps.fleetengine.v1.SearchVehiclesRequest other =
        (google.maps.fleetengine.v1.SearchVehiclesRequest) obj;

    if (hasHeader() != other.hasHeader()) return false;
    if (hasHeader()) {
      if (!getHeader().equals(other.getHeader())) return false;
    }
    if (!getParent().equals(other.getParent())) return false;
    if (hasPickupPoint() != other.hasPickupPoint()) return false;
    if (hasPickupPoint()) {
      if (!getPickupPoint().equals(other.getPickupPoint())) return false;
    }
    if (hasDropoffPoint() != other.hasDropoffPoint()) return false;
    if (hasDropoffPoint()) {
      if (!getDropoffPoint().equals(other.getDropoffPoint())) return false;
    }
    if (getPickupRadiusMeters() != other.getPickupRadiusMeters()) return false;
    if (getCount() != other.getCount()) return false;
    if (getMinimumCapacity() != other.getMinimumCapacity()) return false;
    if (!tripTypes_.equals(other.tripTypes_)) return false;
    if (hasMaximumStaleness() != other.hasMaximumStaleness()) return false;
    if (hasMaximumStaleness()) {
      if (!getMaximumStaleness().equals(other.getMaximumStaleness())) return false;
    }
    if (!getVehicleTypesList().equals(other.getVehicleTypesList())) return false;
    if (!getRequiredAttributesList().equals(other.getRequiredAttributesList())) return false;
    if (!getRequiredOneOfAttributesList().equals(other.getRequiredOneOfAttributesList()))
      return false;
    if (!getRequiredOneOfAttributeSetsList().equals(other.getRequiredOneOfAttributeSetsList()))
      return false;
    if (orderBy_ != other.orderBy_) return false;
    if (getIncludeBackToBack() != other.getIncludeBackToBack()) return false;
    if (!getTripId().equals(other.getTripId())) return false;
    if (currentTripsPresent_ != other.currentTripsPresent_) return false;
    if (!getFilter().equals(other.getFilter())) return false;
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasHeader()) {
      hash = (37 * hash) + HEADER_FIELD_NUMBER;
      hash = (53 * hash) + getHeader().hashCode();
    }
    hash = (37 * hash) + PARENT_FIELD_NUMBER;
    hash = (53 * hash) + getParent().hashCode();
    if (hasPickupPoint()) {
      hash = (37 * hash) + PICKUP_POINT_FIELD_NUMBER;
      hash = (53 * hash) + getPickupPoint().hashCode();
    }
    if (hasDropoffPoint()) {
      hash = (37 * hash) + DROPOFF_POINT_FIELD_NUMBER;
      hash = (53 * hash) + getDropoffPoint().hashCode();
    }
    hash = (37 * hash) + PICKUP_RADIUS_METERS_FIELD_NUMBER;
    hash = (53 * hash) + getPickupRadiusMeters();
    hash = (37 * hash) + COUNT_FIELD_NUMBER;
    hash = (53 * hash) + getCount();
    hash = (37 * hash) + MINIMUM_CAPACITY_FIELD_NUMBER;
    hash = (53 * hash) + getMinimumCapacity();
    if (getTripTypesCount() > 0) {
      hash = (37 * hash) + TRIP_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + tripTypes_.hashCode();
    }
    if (hasMaximumStaleness()) {
      hash = (37 * hash) + MAXIMUM_STALENESS_FIELD_NUMBER;
      hash = (53 * hash) + getMaximumStaleness().hashCode();
    }
    if (getVehicleTypesCount() > 0) {
      hash = (37 * hash) + VEHICLE_TYPES_FIELD_NUMBER;
      hash = (53 * hash) + getVehicleTypesList().hashCode();
    }
    if (getRequiredAttributesCount() > 0) {
      hash = (37 * hash) + REQUIRED_ATTRIBUTES_FIELD_NUMBER;
      hash = (53 * hash) + getRequiredAttributesList().hashCode();
    }
    if (getRequiredOneOfAttributesCount() > 0) {
      hash = (37 * hash) + REQUIRED_ONE_OF_ATTRIBUTES_FIELD_NUMBER;
      hash = (53 * hash) + getRequiredOneOfAttributesList().hashCode();
    }
    if (getRequiredOneOfAttributeSetsCount() > 0) {
      hash = (37 * hash) + REQUIRED_ONE_OF_ATTRIBUTE_SETS_FIELD_NUMBER;
      hash = (53 * hash) + getRequiredOneOfAttributeSetsList().hashCode();
    }
    hash = (37 * hash) + ORDER_BY_FIELD_NUMBER;
    hash = (53 * hash) + orderBy_;
    hash = (37 * hash) + INCLUDE_BACK_TO_BACK_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getIncludeBackToBack());
    hash = (37 * hash) + TRIP_ID_FIELD_NUMBER;
    hash = (53 * hash) + getTripId().hashCode();
    hash = (37 * hash) + CURRENT_TRIPS_PRESENT_FIELD_NUMBER;
    hash = (53 * hash) + currentTripsPresent_;
    hash = (37 * hash) + FILTER_FIELD_NUMBER;
    hash = (53 * hash) + getFilter().hashCode();
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(google.maps.fleetengine.v1.SearchVehiclesRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * `SearchVehicles` request message.
   * </pre>
   *
   * Protobuf type {@code maps.fleetengine.v1.SearchVehiclesRequest}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:maps.fleetengine.v1.SearchVehiclesRequest)
      google.maps.fleetengine.v1.SearchVehiclesRequestOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return google.maps.fleetengine.v1.VehicleApi
          .internal_static_maps_fleetengine_v1_SearchVehiclesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return google.maps.fleetengine.v1.VehicleApi
          .internal_static_maps_fleetengine_v1_SearchVehiclesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              google.maps.fleetengine.v1.SearchVehiclesRequest.class,
              google.maps.fleetengine.v1.SearchVehiclesRequest.Builder.class);
    }

    // Construct using google.maps.fleetengine.v1.SearchVehiclesRequest.newBuilder()
    private Builder() {}

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      header_ = null;
      if (headerBuilder_ != null) {
        headerBuilder_.dispose();
        headerBuilder_ = null;
      }
      parent_ = "";
      pickupPoint_ = null;
      if (pickupPointBuilder_ != null) {
        pickupPointBuilder_.dispose();
        pickupPointBuilder_ = null;
      }
      dropoffPoint_ = null;
      if (dropoffPointBuilder_ != null) {
        dropoffPointBuilder_.dispose();
        dropoffPointBuilder_ = null;
      }
      pickupRadiusMeters_ = 0;
      count_ = 0;
      minimumCapacity_ = 0;
      tripTypes_ = java.util.Collections.emptyList();
      bitField0_ = (bitField0_ & ~0x00000080);
      maximumStaleness_ = null;
      if (maximumStalenessBuilder_ != null) {
        maximumStalenessBuilder_.dispose();
        maximumStalenessBuilder_ = null;
      }
      if (vehicleTypesBuilder_ == null) {
        vehicleTypes_ = java.util.Collections.emptyList();
      } else {
        vehicleTypes_ = null;
        vehicleTypesBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000200);
      if (requiredAttributesBuilder_ == null) {
        requiredAttributes_ = java.util.Collections.emptyList();
      } else {
        requiredAttributes_ = null;
        requiredAttributesBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000400);
      if (requiredOneOfAttributesBuilder_ == null) {
        requiredOneOfAttributes_ = java.util.Collections.emptyList();
      } else {
        requiredOneOfAttributes_ = null;
        requiredOneOfAttributesBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000800);
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        requiredOneOfAttributeSets_ = java.util.Collections.emptyList();
      } else {
        requiredOneOfAttributeSets_ = null;
        requiredOneOfAttributeSetsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00001000);
      orderBy_ = 0;
      includeBackToBack_ = false;
      tripId_ = "";
      currentTripsPresent_ = 0;
      filter_ = "";
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return google.maps.fleetengine.v1.VehicleApi
          .internal_static_maps_fleetengine_v1_SearchVehiclesRequest_descriptor;
    }

    @java.lang.Override
    public google.maps.fleetengine.v1.SearchVehiclesRequest getDefaultInstanceForType() {
      return google.maps.fleetengine.v1.SearchVehiclesRequest.getDefaultInstance();
    }

    @java.lang.Override
    public google.maps.fleetengine.v1.SearchVehiclesRequest build() {
      google.maps.fleetengine.v1.SearchVehiclesRequest result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public google.maps.fleetengine.v1.SearchVehiclesRequest buildPartial() {
      google.maps.fleetengine.v1.SearchVehiclesRequest result =
          new google.maps.fleetengine.v1.SearchVehiclesRequest(this);
      buildPartialRepeatedFields(result);
      if (bitField0_ != 0) {
        buildPartial0(result);
      }
      onBuilt();
      return result;
    }

    private void buildPartialRepeatedFields(
        google.maps.fleetengine.v1.SearchVehiclesRequest result) {
      if (((bitField0_ & 0x00000080) != 0)) {
        tripTypes_ = java.util.Collections.unmodifiableList(tripTypes_);
        bitField0_ = (bitField0_ & ~0x00000080);
      }
      result.tripTypes_ = tripTypes_;
      if (vehicleTypesBuilder_ == null) {
        if (((bitField0_ & 0x00000200) != 0)) {
          vehicleTypes_ = java.util.Collections.unmodifiableList(vehicleTypes_);
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.vehicleTypes_ = vehicleTypes_;
      } else {
        result.vehicleTypes_ = vehicleTypesBuilder_.build();
      }
      if (requiredAttributesBuilder_ == null) {
        if (((bitField0_ & 0x00000400) != 0)) {
          requiredAttributes_ = java.util.Collections.unmodifiableList(requiredAttributes_);
          bitField0_ = (bitField0_ & ~0x00000400);
        }
        result.requiredAttributes_ = requiredAttributes_;
      } else {
        result.requiredAttributes_ = requiredAttributesBuilder_.build();
      }
      if (requiredOneOfAttributesBuilder_ == null) {
        if (((bitField0_ & 0x00000800) != 0)) {
          requiredOneOfAttributes_ =
              java.util.Collections.unmodifiableList(requiredOneOfAttributes_);
          bitField0_ = (bitField0_ & ~0x00000800);
        }
        result.requiredOneOfAttributes_ = requiredOneOfAttributes_;
      } else {
        result.requiredOneOfAttributes_ = requiredOneOfAttributesBuilder_.build();
      }
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        if (((bitField0_ & 0x00001000) != 0)) {
          requiredOneOfAttributeSets_ =
              java.util.Collections.unmodifiableList(requiredOneOfAttributeSets_);
          bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.requiredOneOfAttributeSets_ = requiredOneOfAttributeSets_;
      } else {
        result.requiredOneOfAttributeSets_ = requiredOneOfAttributeSetsBuilder_.build();
      }
    }

    private void buildPartial0(google.maps.fleetengine.v1.SearchVehiclesRequest result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.header_ = headerBuilder_ == null ? header_ : headerBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.parent_ = parent_;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.pickupPoint_ =
            pickupPointBuilder_ == null ? pickupPoint_ : pickupPointBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.dropoffPoint_ =
            dropoffPointBuilder_ == null ? dropoffPoint_ : dropoffPointBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.pickupRadiusMeters_ = pickupRadiusMeters_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.count_ = count_;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.minimumCapacity_ = minimumCapacity_;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.maximumStaleness_ =
            maximumStalenessBuilder_ == null ? maximumStaleness_ : maximumStalenessBuilder_.build();
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.orderBy_ = orderBy_;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.includeBackToBack_ = includeBackToBack_;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.tripId_ = tripId_;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.currentTripsPresent_ = currentTripsPresent_;
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.filter_ = filter_;
      }
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof google.maps.fleetengine.v1.SearchVehiclesRequest) {
        return mergeFrom((google.maps.fleetengine.v1.SearchVehiclesRequest) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(google.maps.fleetengine.v1.SearchVehiclesRequest other) {
      if (other == google.maps.fleetengine.v1.SearchVehiclesRequest.getDefaultInstance())
        return this;
      if (other.hasHeader()) {
        mergeHeader(other.getHeader());
      }
      if (!other.getParent().isEmpty()) {
        parent_ = other.parent_;
        bitField0_ |= 0x00000002;
        onChanged();
      }
      if (other.hasPickupPoint()) {
        mergePickupPoint(other.getPickupPoint());
      }
      if (other.hasDropoffPoint()) {
        mergeDropoffPoint(other.getDropoffPoint());
      }
      if (other.getPickupRadiusMeters() != 0) {
        setPickupRadiusMeters(other.getPickupRadiusMeters());
      }
      if (other.getCount() != 0) {
        setCount(other.getCount());
      }
      if (other.getMinimumCapacity() != 0) {
        setMinimumCapacity(other.getMinimumCapacity());
      }
      if (!other.tripTypes_.isEmpty()) {
        if (tripTypes_.isEmpty()) {
          tripTypes_ = other.tripTypes_;
          bitField0_ = (bitField0_ & ~0x00000080);
        } else {
          ensureTripTypesIsMutable();
          tripTypes_.addAll(other.tripTypes_);
        }
        onChanged();
      }
      if (other.hasMaximumStaleness()) {
        mergeMaximumStaleness(other.getMaximumStaleness());
      }
      if (vehicleTypesBuilder_ == null) {
        if (!other.vehicleTypes_.isEmpty()) {
          if (vehicleTypes_.isEmpty()) {
            vehicleTypes_ = other.vehicleTypes_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureVehicleTypesIsMutable();
            vehicleTypes_.addAll(other.vehicleTypes_);
          }
          onChanged();
        }
      } else {
        if (!other.vehicleTypes_.isEmpty()) {
          if (vehicleTypesBuilder_.isEmpty()) {
            vehicleTypesBuilder_.dispose();
            vehicleTypesBuilder_ = null;
            vehicleTypes_ = other.vehicleTypes_;
            bitField0_ = (bitField0_ & ~0x00000200);
            vehicleTypesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getVehicleTypesFieldBuilder()
                    : null;
          } else {
            vehicleTypesBuilder_.addAllMessages(other.vehicleTypes_);
          }
        }
      }
      if (requiredAttributesBuilder_ == null) {
        if (!other.requiredAttributes_.isEmpty()) {
          if (requiredAttributes_.isEmpty()) {
            requiredAttributes_ = other.requiredAttributes_;
            bitField0_ = (bitField0_ & ~0x00000400);
          } else {
            ensureRequiredAttributesIsMutable();
            requiredAttributes_.addAll(other.requiredAttributes_);
          }
          onChanged();
        }
      } else {
        if (!other.requiredAttributes_.isEmpty()) {
          if (requiredAttributesBuilder_.isEmpty()) {
            requiredAttributesBuilder_.dispose();
            requiredAttributesBuilder_ = null;
            requiredAttributes_ = other.requiredAttributes_;
            bitField0_ = (bitField0_ & ~0x00000400);
            requiredAttributesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getRequiredAttributesFieldBuilder()
                    : null;
          } else {
            requiredAttributesBuilder_.addAllMessages(other.requiredAttributes_);
          }
        }
      }
      if (requiredOneOfAttributesBuilder_ == null) {
        if (!other.requiredOneOfAttributes_.isEmpty()) {
          if (requiredOneOfAttributes_.isEmpty()) {
            requiredOneOfAttributes_ = other.requiredOneOfAttributes_;
            bitField0_ = (bitField0_ & ~0x00000800);
          } else {
            ensureRequiredOneOfAttributesIsMutable();
            requiredOneOfAttributes_.addAll(other.requiredOneOfAttributes_);
          }
          onChanged();
        }
      } else {
        if (!other.requiredOneOfAttributes_.isEmpty()) {
          if (requiredOneOfAttributesBuilder_.isEmpty()) {
            requiredOneOfAttributesBuilder_.dispose();
            requiredOneOfAttributesBuilder_ = null;
            requiredOneOfAttributes_ = other.requiredOneOfAttributes_;
            bitField0_ = (bitField0_ & ~0x00000800);
            requiredOneOfAttributesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getRequiredOneOfAttributesFieldBuilder()
                    : null;
          } else {
            requiredOneOfAttributesBuilder_.addAllMessages(other.requiredOneOfAttributes_);
          }
        }
      }
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        if (!other.requiredOneOfAttributeSets_.isEmpty()) {
          if (requiredOneOfAttributeSets_.isEmpty()) {
            requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_;
            bitField0_ = (bitField0_ & ~0x00001000);
          } else {
            ensureRequiredOneOfAttributeSetsIsMutable();
            requiredOneOfAttributeSets_.addAll(other.requiredOneOfAttributeSets_);
          }
          onChanged();
        }
      } else {
        if (!other.requiredOneOfAttributeSets_.isEmpty()) {
          if (requiredOneOfAttributeSetsBuilder_.isEmpty()) {
            requiredOneOfAttributeSetsBuilder_.dispose();
            requiredOneOfAttributeSetsBuilder_ = null;
            requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_;
            bitField0_ = (bitField0_ & ~0x00001000);
            requiredOneOfAttributeSetsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getRequiredOneOfAttributeSetsFieldBuilder()
                    : null;
          } else {
            requiredOneOfAttributeSetsBuilder_.addAllMessages(other.requiredOneOfAttributeSets_);
          }
        }
      }
      if (other.orderBy_ != 0) {
        setOrderByValue(other.getOrderByValue());
      }
      if (other.getIncludeBackToBack() != false) {
        setIncludeBackToBack(other.getIncludeBackToBack());
      }
      if (!other.getTripId().isEmpty()) {
        tripId_ = other.tripId_;
        bitField0_ |= 0x00008000;
        onChanged();
      }
      if (other.currentTripsPresent_ != 0) {
        setCurrentTripsPresentValue(other.getCurrentTripsPresentValue());
      }
      if (!other.getFilter().isEmpty()) {
        filter_ = other.filter_;
        bitField0_ |= 0x00020000;
        onChanged();
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                input.readMessage(getHeaderFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
            case 26:
              {
                parent_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 26
            case 34:
              {
                input.readMessage(getPickupPointFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 34
            case 42:
              {
                input.readMessage(getDropoffPointFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 42
            case 48:
              {
                pickupRadiusMeters_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 48
            case 56:
              {
                count_ = input.readInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 56
            case 64:
              {
                minimumCapacity_ = input.readInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 64
            case 72:
              {
                int tmpRaw = input.readEnum();
                ensureTripTypesIsMutable();
                tripTypes_.add(tmpRaw);
                break;
              } // case 72
            case 74:
              {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while (input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  ensureTripTypesIsMutable();
                  tripTypes_.add(tmpRaw);
                }
                input.popLimit(oldLimit);
                break;
              } // case 74
            case 82:
              {
                input.readMessage(
                    getMaximumStalenessFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 82
            case 98:
              {
                google.maps.fleetengine.v1.VehicleAttribute m =
                    input.readMessage(
                        google.maps.fleetengine.v1.VehicleAttribute.parser(), extensionRegistry);
                if (requiredAttributesBuilder_ == null) {
                  ensureRequiredAttributesIsMutable();
                  requiredAttributes_.add(m);
                } else {
                  requiredAttributesBuilder_.addMessage(m);
                }
                break;
              } // case 98
            case 104:
              {
                orderBy_ = input.readEnum();
                bitField0_ |= 0x00002000;
                break;
              } // case 104
            case 114:
              {
                google.maps.fleetengine.v1.Vehicle.VehicleType m =
                    input.readMessage(
                        google.maps.fleetengine.v1.Vehicle.VehicleType.parser(), extensionRegistry);
                if (vehicleTypesBuilder_ == null) {
                  ensureVehicleTypesIsMutable();
                  vehicleTypes_.add(m);
                } else {
                  vehicleTypesBuilder_.addMessage(m);
                }
                break;
              } // case 114
            case 122:
              {
                google.maps.fleetengine.v1.VehicleAttributeList m =
                    input.readMessage(
                        google.maps.fleetengine.v1.VehicleAttributeList.parser(),
                        extensionRegistry);
                if (requiredOneOfAttributesBuilder_ == null) {
                  ensureRequiredOneOfAttributesIsMutable();
                  requiredOneOfAttributes_.add(m);
                } else {
                  requiredOneOfAttributesBuilder_.addMessage(m);
                }
                break;
              } // case 122
            case 144:
              {
                includeBackToBack_ = input.readBool();
                bitField0_ |= 0x00004000;
                break;
              } // case 144
            case 154:
              {
                tripId_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00008000;
                break;
              } // case 154
            case 162:
              {
                google.maps.fleetengine.v1.VehicleAttributeList m =
                    input.readMessage(
                        google.maps.fleetengine.v1.VehicleAttributeList.parser(),
                        extensionRegistry);
                if (requiredOneOfAttributeSetsBuilder_ == null) {
                  ensureRequiredOneOfAttributeSetsIsMutable();
                  requiredOneOfAttributeSets_.add(m);
                } else {
                  requiredOneOfAttributeSetsBuilder_.addMessage(m);
                }
                break;
              } // case 162
            case 168:
              {
                currentTripsPresent_ = input.readEnum();
                bitField0_ |= 0x00010000;
                break;
              } // case 168
            case 178:
              {
                filter_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00020000;
                break;
              } // case 178
            default:
              {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }

    private int bitField0_;

    private google.maps.fleetengine.v1.RequestHeader header_;
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.RequestHeader,
            google.maps.fleetengine.v1.RequestHeader.Builder,
            google.maps.fleetengine.v1.RequestHeaderOrBuilder>
        headerBuilder_;
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     *
     * @return Whether the header field is set.
     */
    public boolean hasHeader() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     *
     * @return The header.
     */
    public google.maps.fleetengine.v1.RequestHeader getHeader() {
      if (headerBuilder_ == null) {
        return header_ == null
            ? google.maps.fleetengine.v1.RequestHeader.getDefaultInstance()
            : header_;
      } else {
        return headerBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public Builder setHeader(google.maps.fleetengine.v1.RequestHeader value) {
      if (headerBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        header_ = value;
      } else {
        headerBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public Builder setHeader(google.maps.fleetengine.v1.RequestHeader.Builder builderForValue) {
      if (headerBuilder_ == null) {
        header_ = builderForValue.build();
      } else {
        headerBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public Builder mergeHeader(google.maps.fleetengine.v1.RequestHeader value) {
      if (headerBuilder_ == null) {
        if (((bitField0_ & 0x00000001) != 0)
            && header_ != null
            && header_ != google.maps.fleetengine.v1.RequestHeader.getDefaultInstance()) {
          getHeaderBuilder().mergeFrom(value);
        } else {
          header_ = value;
        }
      } else {
        headerBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public Builder clearHeader() {
      bitField0_ = (bitField0_ & ~0x00000001);
      header_ = null;
      if (headerBuilder_ != null) {
        headerBuilder_.dispose();
        headerBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public google.maps.fleetengine.v1.RequestHeader.Builder getHeaderBuilder() {
      bitField0_ |= 0x00000001;
      onChanged();
      return getHeaderFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    public google.maps.fleetengine.v1.RequestHeaderOrBuilder getHeaderOrBuilder() {
      if (headerBuilder_ != null) {
        return headerBuilder_.getMessageOrBuilder();
      } else {
        return header_ == null
            ? google.maps.fleetengine.v1.RequestHeader.getDefaultInstance()
            : header_;
      }
    }
    /**
     *
     *
     * <pre>
     * The standard Fleet Engine request header.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.RequestHeader header = 1;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.RequestHeader,
            google.maps.fleetengine.v1.RequestHeader.Builder,
            google.maps.fleetengine.v1.RequestHeaderOrBuilder>
        getHeaderFieldBuilder() {
      if (headerBuilder_ == null) {
        headerBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                google.maps.fleetengine.v1.RequestHeader,
                google.maps.fleetengine.v1.RequestHeader.Builder,
                google.maps.fleetengine.v1.RequestHeaderOrBuilder>(
                getHeader(), getParentForChildren(), isClean());
        header_ = null;
      }
      return headerBuilder_;
    }

    private java.lang.Object parent_ = "";
    /**
     *
     *
     * <pre>
     * Required. Must be in the format `providers/{provider}`.
     * The provider must be the Project ID (for example, `sample-cloud-project`)
     * of the Google Cloud Project of which the service account making
     * this call is a member.
     * </pre>
     *
     * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return The parent.
     */
    public java.lang.String getParent() {
      java.lang.Object ref = parent_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        parent_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Must be in the format `providers/{provider}`.
     * The provider must be the Project ID (for example, `sample-cloud-project`)
     * of the Google Cloud Project of which the service account making
     * this call is a member.
     * </pre>
     *
     * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return The bytes for parent.
     */
    public com.google.protobuf.ByteString getParentBytes() {
      java.lang.Object ref = parent_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        parent_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Must be in the format `providers/{provider}`.
     * The provider must be the Project ID (for example, `sample-cloud-project`)
     * of the Google Cloud Project of which the service account making
     * this call is a member.
     * </pre>
     *
     * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @param value The parent to set.
     * @return This builder for chaining.
     */
    public Builder setParent(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      parent_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Must be in the format `providers/{provider}`.
     * The provider must be the Project ID (for example, `sample-cloud-project`)
     * of the Google Cloud Project of which the service account making
     * this call is a member.
     * </pre>
     *
     * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearParent() {
      parent_ = getDefaultInstance().getParent();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Must be in the format `providers/{provider}`.
     * The provider must be the Project ID (for example, `sample-cloud-project`)
     * of the Google Cloud Project of which the service account making
     * this call is a member.
     * </pre>
     *
     * <code>string parent = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @param value The bytes for parent to set.
     * @return This builder for chaining.
     */
    public Builder setParentBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      parent_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    private google.maps.fleetengine.v1.TerminalLocation pickupPoint_;
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.TerminalLocation,
            google.maps.fleetengine.v1.TerminalLocation.Builder,
            google.maps.fleetengine.v1.TerminalLocationOrBuilder>
        pickupPointBuilder_;
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return Whether the pickupPoint field is set.
     */
    public boolean hasPickupPoint() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return The pickupPoint.
     */
    public google.maps.fleetengine.v1.TerminalLocation getPickupPoint() {
      if (pickupPointBuilder_ == null) {
        return pickupPoint_ == null
            ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
            : pickupPoint_;
      } else {
        return pickupPointBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder setPickupPoint(google.maps.fleetengine.v1.TerminalLocation value) {
      if (pickupPointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        pickupPoint_ = value;
      } else {
        pickupPointBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder setPickupPoint(
        google.maps.fleetengine.v1.TerminalLocation.Builder builderForValue) {
      if (pickupPointBuilder_ == null) {
        pickupPoint_ = builderForValue.build();
      } else {
        pickupPointBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder mergePickupPoint(google.maps.fleetengine.v1.TerminalLocation value) {
      if (pickupPointBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)
            && pickupPoint_ != null
            && pickupPoint_ != google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()) {
          getPickupPointBuilder().mergeFrom(value);
        } else {
          pickupPoint_ = value;
        }
      } else {
        pickupPointBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder clearPickupPoint() {
      bitField0_ = (bitField0_ & ~0x00000004);
      pickupPoint_ = null;
      if (pickupPointBuilder_ != null) {
        pickupPointBuilder_.dispose();
        pickupPointBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.TerminalLocation.Builder getPickupPointBuilder() {
      bitField0_ |= 0x00000004;
      onChanged();
      return getPickupPointFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.TerminalLocationOrBuilder getPickupPointOrBuilder() {
      if (pickupPointBuilder_ != null) {
        return pickupPointBuilder_.getMessageOrBuilder();
      } else {
        return pickupPoint_ == null
            ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
            : pickupPoint_;
      }
    }
    /**
     *
     *
     * <pre>
     * Required. The pickup point to search near.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.TerminalLocation pickup_point = 4 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.TerminalLocation,
            google.maps.fleetengine.v1.TerminalLocation.Builder,
            google.maps.fleetengine.v1.TerminalLocationOrBuilder>
        getPickupPointFieldBuilder() {
      if (pickupPointBuilder_ == null) {
        pickupPointBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                google.maps.fleetengine.v1.TerminalLocation,
                google.maps.fleetengine.v1.TerminalLocation.Builder,
                google.maps.fleetengine.v1.TerminalLocationOrBuilder>(
                getPickupPoint(), getParentForChildren(), isClean());
        pickupPoint_ = null;
      }
      return pickupPointBuilder_;
    }

    private google.maps.fleetengine.v1.TerminalLocation dropoffPoint_;
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.TerminalLocation,
            google.maps.fleetengine.v1.TerminalLocation.Builder,
            google.maps.fleetengine.v1.TerminalLocationOrBuilder>
        dropoffPointBuilder_;
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     *
     * @return Whether the dropoffPoint field is set.
     */
    public boolean hasDropoffPoint() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     *
     * @return The dropoffPoint.
     */
    public google.maps.fleetengine.v1.TerminalLocation getDropoffPoint() {
      if (dropoffPointBuilder_ == null) {
        return dropoffPoint_ == null
            ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
            : dropoffPoint_;
      } else {
        return dropoffPointBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public Builder setDropoffPoint(google.maps.fleetengine.v1.TerminalLocation value) {
      if (dropoffPointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        dropoffPoint_ = value;
      } else {
        dropoffPointBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public Builder setDropoffPoint(
        google.maps.fleetengine.v1.TerminalLocation.Builder builderForValue) {
      if (dropoffPointBuilder_ == null) {
        dropoffPoint_ = builderForValue.build();
      } else {
        dropoffPointBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public Builder mergeDropoffPoint(google.maps.fleetengine.v1.TerminalLocation value) {
      if (dropoffPointBuilder_ == null) {
        if (((bitField0_ & 0x00000008) != 0)
            && dropoffPoint_ != null
            && dropoffPoint_ != google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()) {
          getDropoffPointBuilder().mergeFrom(value);
        } else {
          dropoffPoint_ = value;
        }
      } else {
        dropoffPointBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public Builder clearDropoffPoint() {
      bitField0_ = (bitField0_ & ~0x00000008);
      dropoffPoint_ = null;
      if (dropoffPointBuilder_ != null) {
        dropoffPointBuilder_.dispose();
        dropoffPointBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public google.maps.fleetengine.v1.TerminalLocation.Builder getDropoffPointBuilder() {
      bitField0_ |= 0x00000008;
      onChanged();
      return getDropoffPointFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    public google.maps.fleetengine.v1.TerminalLocationOrBuilder getDropoffPointOrBuilder() {
      if (dropoffPointBuilder_ != null) {
        return dropoffPointBuilder_.getMessageOrBuilder();
      } else {
        return dropoffPoint_ == null
            ? google.maps.fleetengine.v1.TerminalLocation.getDefaultInstance()
            : dropoffPoint_;
      }
    }
    /**
     *
     *
     * <pre>
     * The customer's intended dropoff location. The field is required if
     * `trip_types` contains `TripType.SHARED`.
     * </pre>
     *
     * <code>.maps.fleetengine.v1.TerminalLocation dropoff_point = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            google.maps.fleetengine.v1.TerminalLocation,
            google.maps.fleetengine.v1.TerminalLocation.Builder,
            google.maps.fleetengine.v1.TerminalLocationOrBuilder>
        getDropoffPointFieldBuilder() {
      if (dropoffPointBuilder_ == null) {
        dropoffPointBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                google.maps.fleetengine.v1.TerminalLocation,
                google.maps.fleetengine.v1.TerminalLocation.Builder,
                google.maps.fleetengine.v1.TerminalLocationOrBuilder>(
                getDropoffPoint(), getParentForChildren(), isClean());
        dropoffPoint_ = null;
      }
      return dropoffPointBuilder_;
    }

    private int pickupRadiusMeters_;
    /**
     *
     *
     * <pre>
     * Required. Defines the vehicle search radius around the pickup point. Only
     * vehicles within the search radius will be returned. Value must be between
     * 400 and 10000 meters (inclusive).
     * </pre>
     *
     * <code>int32 pickup_radius_meters = 6 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return The pickupRadiusMeters.
     */
    @java.lang.Override
    public int getPickupRadiusMeters() {
      return pickupRadiusMeters_;
    }
    /**
     *
     *
     * <pre>
     * Required. Defines the vehicle search radius around the pickup point. Only
     * vehicles within the search radius will be returned. Value must be between
     * 400 and 10000 meters (inclusive).
     * </pre>
     *
     * <code>int32 pickup_radius_meters = 6 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @param value The pickupRadiusMeters to set.
     * @return This builder for chaining.
     */
    public Builder setPickupRadiusMeters(int value) {

      pickupRadiusMeters_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Defines the vehicle search radius around the pickup point. Only
     * vehicles within the search radius will be returned. Value must be between
     * 400 and 10000 meters (inclusive).
     * </pre>
     *
     * <code>int32 pickup_radius_meters = 6 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPickupRadiusMeters() {
      bitField0_ = (bitField0_ & ~0x00000010);
      pickupRadiusMeters_ = 0;
      onChanged();
      return this;
    }

    private int count_;
    /**
     *
     *
     * <pre>
     * Required. Specifies the maximum number of vehicles to return. The value
     * must be between 1 and 50 (inclusive).
     * </pre>
     *
     * <code>int32 count = 7 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return The count.
     */
    @java.lang.Override
    public int getCount() {
      return count_;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the maximum number of vehicles to return. The value
     * must be between 1 and 50 (inclusive).
     * </pre>
     *
     * <code>int32 count = 7 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @param value The count to set.
     * @return This builder for chaining.
     */
    public Builder setCount(int value) {

      count_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the maximum number of vehicles to return. The value
     * must be between 1 and 50 (inclusive).
     * </pre>
     *
     * <code>int32 count = 7 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCount() {
      bitField0_ = (bitField0_ & ~0x00000020);
      count_ = 0;
      onChanged();
      return this;
    }

    private int minimumCapacity_;
    /**
     *
     *
     * <pre>
     * Required. Specifies the number of passengers being considered for a trip.
     * The value must be greater than or equal to one. The driver is not
     * considered in the capacity value.
     * </pre>
     *
     * <code>int32 minimum_capacity = 8 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return The minimumCapacity.
     */
    @java.lang.Override
    public int getMinimumCapacity() {
      return minimumCapacity_;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the number of passengers being considered for a trip.
     * The value must be greater than or equal to one. The driver is not
     * considered in the capacity value.
     * </pre>
     *
     * <code>int32 minimum_capacity = 8 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @param value The minimumCapacity to set.
     * @return This builder for chaining.
     */
    public Builder setMinimumCapacity(int value) {

      minimumCapacity_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the number of passengers being considered for a trip.
     * The value must be greater than or equal to one. The driver is not
     * considered in the capacity value.
     * </pre>
     *
     * <code>int32 minimum_capacity = 8 [(.google.api.field_behavior) = REQUIRED];</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMinimumCapacity() {
      bitField0_ = (bitField0_ & ~0x00000040);
      minimumCapacity_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<java.lang.Integer> tripTypes_ = java.util.Collections.emptyList();

    private void ensureTripTypesIsMutable() {
      if (!((bitField0_ & 0x00000080) != 0)) {
        tripTypes_ = new java.util.ArrayList<java.lang.Integer>(tripTypes_);
        bitField0_ |= 0x00000080;
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return A list containing the tripTypes.
     */
    public java.util.List<google.maps.fleetengine.v1.TripType> getTripTypesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, google.maps.fleetengine.v1.TripType>(tripTypes_, tripTypes_converter_);
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return The count of tripTypes.
     */
    public int getTripTypesCount() {
      return tripTypes_.size();
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param index The index of the element to return.
     * @return The tripTypes at the given index.
     */
    public google.maps.fleetengine.v1.TripType getTripTypes(int index) {
      return tripTypes_converter_.convert(tripTypes_.get(index));
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param index The index to set the value at.
     * @param value The tripTypes to set.
     * @return This builder for chaining.
     */
    public Builder setTripTypes(int index, google.maps.fleetengine.v1.TripType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureTripTypesIsMutable();
      tripTypes_.set(index, value.getNumber());
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param value The tripTypes to add.
     * @return This builder for chaining.
     */
    public Builder addTripTypes(google.maps.fleetengine.v1.TripType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureTripTypesIsMutable();
      tripTypes_.add(value.getNumber());
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param values The tripTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllTripTypes(
        java.lang.Iterable<? extends google.maps.fleetengine.v1.TripType> values) {
      ensureTripTypesIsMutable();
      for (google.maps.fleetengine.v1.TripType value : values) {
        tripTypes_.add(value.getNumber());
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTripTypes() {
      tripTypes_ = java.util.Collections.emptyList();
      bitField0_ = (bitField0_ & ~0x00000080);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return A list containing the enum numeric values on the wire for tripTypes.
     */
    public java.util.List<java.lang.Integer> getTripTypesValueList() {
      return java.util.Collections.unmodifiableList(tripTypes_);
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of tripTypes at the given index.
     */
    public int getTripTypesValue(int index) {
      return tripTypes_.get(index);
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param index The index to set the value at.
     * @param value The enum numeric value on the wire for tripTypes to set.
     * @return This builder for chaining.
     */
    public Builder setTripTypesValue(int index, int value) {
      ensureTripTypesIsMutable();
      tripTypes_.set(index, value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param value The enum numeric value on the wire for tripTypes to add.
     * @return This builder for chaining.
     */
    public Builder addTripTypesValue(int value) {
      ensureTripTypesIsMutable();
      tripTypes_.add(value);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Represents the type of proposed trip. Eligible vehicles are those
     * that can support at least one of the specified trip type.
     *
     * `EXCLUSIVE` and `SHARED` may not be included together.
     * `SHARED` is not supported when `current_trips_present` is
     * `CURRENT_TRIPS_PRESENT_UNSPECIFIED`. `UNKNOWN_TRIP_TYPE` is not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.TripType trip_types = 9 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param values The enum numeric values on the wire for tripTypes to add.
     * @return This builder for chaining.
     */
    public Builder addAllTripTypesValue(java.lang.Iterable<java.lang.Integer> values) {
      ensureTripTypesIsMutable();
      for (int value : values) {
        tripTypes_.add(value);
      }
      onChanged();
      return this;
    }

    private com.google.protobuf.Duration maximumStaleness_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration,
            com.google.protobuf.Duration.Builder,
            com.google.protobuf.DurationOrBuilder>
        maximumStalenessBuilder_;
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     *
     * @return Whether the maximumStaleness field is set.
     */
    public boolean hasMaximumStaleness() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     *
     * @return The maximumStaleness.
     */
    public com.google.protobuf.Duration getMaximumStaleness() {
      if (maximumStalenessBuilder_ == null) {
        return maximumStaleness_ == null
            ? com.google.protobuf.Duration.getDefaultInstance()
            : maximumStaleness_;
      } else {
        return maximumStalenessBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public Builder setMaximumStaleness(com.google.protobuf.Duration value) {
      if (maximumStalenessBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maximumStaleness_ = value;
      } else {
        maximumStalenessBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public Builder setMaximumStaleness(com.google.protobuf.Duration.Builder builderForValue) {
      if (maximumStalenessBuilder_ == null) {
        maximumStaleness_ = builderForValue.build();
      } else {
        maximumStalenessBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public Builder mergeMaximumStaleness(com.google.protobuf.Duration value) {
      if (maximumStalenessBuilder_ == null) {
        if (((bitField0_ & 0x00000100) != 0)
            && maximumStaleness_ != null
            && maximumStaleness_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getMaximumStalenessBuilder().mergeFrom(value);
        } else {
          maximumStaleness_ = value;
        }
      } else {
        maximumStalenessBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public Builder clearMaximumStaleness() {
      bitField0_ = (bitField0_ & ~0x00000100);
      maximumStaleness_ = null;
      if (maximumStalenessBuilder_ != null) {
        maximumStalenessBuilder_.dispose();
        maximumStalenessBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public com.google.protobuf.Duration.Builder getMaximumStalenessBuilder() {
      bitField0_ |= 0x00000100;
      onChanged();
      return getMaximumStalenessFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    public com.google.protobuf.DurationOrBuilder getMaximumStalenessOrBuilder() {
      if (maximumStalenessBuilder_ != null) {
        return maximumStalenessBuilder_.getMessageOrBuilder();
      } else {
        return maximumStaleness_ == null
            ? com.google.protobuf.Duration.getDefaultInstance()
            : maximumStaleness_;
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles that have sent location updates
     * to Fleet Engine within the specified duration. Stationary vehicles still
     * transmitting their locations are not considered stale. If this field is not
     * set, the server uses five minutes as the default value.
     * </pre>
     *
     * <code>.google.protobuf.Duration maximum_staleness = 10;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration,
            com.google.protobuf.Duration.Builder,
            com.google.protobuf.DurationOrBuilder>
        getMaximumStalenessFieldBuilder() {
      if (maximumStalenessBuilder_ == null) {
        maximumStalenessBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.protobuf.Duration,
                com.google.protobuf.Duration.Builder,
                com.google.protobuf.DurationOrBuilder>(
                getMaximumStaleness(), getParentForChildren(), isClean());
        maximumStaleness_ = null;
      }
      return maximumStalenessBuilder_;
    }

    private java.util.List<google.maps.fleetengine.v1.Vehicle.VehicleType> vehicleTypes_ =
        java.util.Collections.emptyList();

    private void ensureVehicleTypesIsMutable() {
      if (!((bitField0_ & 0x00000200) != 0)) {
        vehicleTypes_ =
            new java.util.ArrayList<google.maps.fleetengine.v1.Vehicle.VehicleType>(vehicleTypes_);
        bitField0_ |= 0x00000200;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.Vehicle.VehicleType,
            google.maps.fleetengine.v1.Vehicle.VehicleType.Builder,
            google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder>
        vehicleTypesBuilder_;

    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.Vehicle.VehicleType> getVehicleTypesList() {
      if (vehicleTypesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(vehicleTypes_);
      } else {
        return vehicleTypesBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public int getVehicleTypesCount() {
      if (vehicleTypesBuilder_ == null) {
        return vehicleTypes_.size();
      } else {
        return vehicleTypesBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.Vehicle.VehicleType getVehicleTypes(int index) {
      if (vehicleTypesBuilder_ == null) {
        return vehicleTypes_.get(index);
      } else {
        return vehicleTypesBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder setVehicleTypes(
        int index, google.maps.fleetengine.v1.Vehicle.VehicleType value) {
      if (vehicleTypesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVehicleTypesIsMutable();
        vehicleTypes_.set(index, value);
        onChanged();
      } else {
        vehicleTypesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder setVehicleTypes(
        int index, google.maps.fleetengine.v1.Vehicle.VehicleType.Builder builderForValue) {
      if (vehicleTypesBuilder_ == null) {
        ensureVehicleTypesIsMutable();
        vehicleTypes_.set(index, builderForValue.build());
        onChanged();
      } else {
        vehicleTypesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder addVehicleTypes(google.maps.fleetengine.v1.Vehicle.VehicleType value) {
      if (vehicleTypesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVehicleTypesIsMutable();
        vehicleTypes_.add(value);
        onChanged();
      } else {
        vehicleTypesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder addVehicleTypes(
        int index, google.maps.fleetengine.v1.Vehicle.VehicleType value) {
      if (vehicleTypesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVehicleTypesIsMutable();
        vehicleTypes_.add(index, value);
        onChanged();
      } else {
        vehicleTypesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder addVehicleTypes(
        google.maps.fleetengine.v1.Vehicle.VehicleType.Builder builderForValue) {
      if (vehicleTypesBuilder_ == null) {
        ensureVehicleTypesIsMutable();
        vehicleTypes_.add(builderForValue.build());
        onChanged();
      } else {
        vehicleTypesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder addVehicleTypes(
        int index, google.maps.fleetengine.v1.Vehicle.VehicleType.Builder builderForValue) {
      if (vehicleTypesBuilder_ == null) {
        ensureVehicleTypesIsMutable();
        vehicleTypes_.add(index, builderForValue.build());
        onChanged();
      } else {
        vehicleTypesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder addAllVehicleTypes(
        java.lang.Iterable<? extends google.maps.fleetengine.v1.Vehicle.VehicleType> values) {
      if (vehicleTypesBuilder_ == null) {
        ensureVehicleTypesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, vehicleTypes_);
        onChanged();
      } else {
        vehicleTypesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder clearVehicleTypes() {
      if (vehicleTypesBuilder_ == null) {
        vehicleTypes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
      } else {
        vehicleTypesBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public Builder removeVehicleTypes(int index) {
      if (vehicleTypesBuilder_ == null) {
        ensureVehicleTypesIsMutable();
        vehicleTypes_.remove(index);
        onChanged();
      } else {
        vehicleTypesBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.Vehicle.VehicleType.Builder getVehicleTypesBuilder(
        int index) {
      return getVehicleTypesFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder getVehicleTypesOrBuilder(
        int index) {
      if (vehicleTypesBuilder_ == null) {
        return vehicleTypes_.get(index);
      } else {
        return vehicleTypesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public java.util.List<? extends google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder>
        getVehicleTypesOrBuilderList() {
      if (vehicleTypesBuilder_ != null) {
        return vehicleTypesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(vehicleTypes_);
      }
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.Vehicle.VehicleType.Builder addVehicleTypesBuilder() {
      return getVehicleTypesFieldBuilder()
          .addBuilder(google.maps.fleetengine.v1.Vehicle.VehicleType.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public google.maps.fleetengine.v1.Vehicle.VehicleType.Builder addVehicleTypesBuilder(
        int index) {
      return getVehicleTypesFieldBuilder()
          .addBuilder(index, google.maps.fleetengine.v1.Vehicle.VehicleType.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Required. Restricts the search to vehicles with one of the specified types.
     * At least one vehicle type must be specified. VehicleTypes with a category
     * of `UNKNOWN` are not allowed.
     * </pre>
     *
     * <code>
     * repeated .maps.fleetengine.v1.Vehicle.VehicleType vehicle_types = 14 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.Vehicle.VehicleType.Builder>
        getVehicleTypesBuilderList() {
      return getVehicleTypesFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.Vehicle.VehicleType,
            google.maps.fleetengine.v1.Vehicle.VehicleType.Builder,
            google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder>
        getVehicleTypesFieldBuilder() {
      if (vehicleTypesBuilder_ == null) {
        vehicleTypesBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                google.maps.fleetengine.v1.Vehicle.VehicleType,
                google.maps.fleetengine.v1.Vehicle.VehicleType.Builder,
                google.maps.fleetengine.v1.Vehicle.VehicleTypeOrBuilder>(
                vehicleTypes_, ((bitField0_ & 0x00000200) != 0), getParentForChildren(), isClean());
        vehicleTypes_ = null;
      }
      return vehicleTypesBuilder_;
    }

    private java.util.List<google.maps.fleetengine.v1.VehicleAttribute> requiredAttributes_ =
        java.util.Collections.emptyList();

    private void ensureRequiredAttributesIsMutable() {
      if (!((bitField0_ & 0x00000400) != 0)) {
        requiredAttributes_ =
            new java.util.ArrayList<google.maps.fleetengine.v1.VehicleAttribute>(
                requiredAttributes_);
        bitField0_ |= 0x00000400;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttribute,
            google.maps.fleetengine.v1.VehicleAttribute.Builder,
            google.maps.fleetengine.v1.VehicleAttributeOrBuilder>
        requiredAttributesBuilder_;

    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttribute> getRequiredAttributesList() {
      if (requiredAttributesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(requiredAttributes_);
      } else {
        return requiredAttributesBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public int getRequiredAttributesCount() {
      if (requiredAttributesBuilder_ == null) {
        return requiredAttributes_.size();
      } else {
        return requiredAttributesBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public google.maps.fleetengine.v1.VehicleAttribute getRequiredAttributes(int index) {
      if (requiredAttributesBuilder_ == null) {
        return requiredAttributes_.get(index);
      } else {
        return requiredAttributesBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder setRequiredAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttribute value) {
      if (requiredAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.set(index, value);
        onChanged();
      } else {
        requiredAttributesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder setRequiredAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttribute.Builder builderForValue) {
      if (requiredAttributesBuilder_ == null) {
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.set(index, builderForValue.build());
        onChanged();
      } else {
        requiredAttributesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder addRequiredAttributes(google.maps.fleetengine.v1.VehicleAttribute value) {
      if (requiredAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.add(value);
        onChanged();
      } else {
        requiredAttributesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder addRequiredAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttribute value) {
      if (requiredAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.add(index, value);
        onChanged();
      } else {
        requiredAttributesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder addRequiredAttributes(
        google.maps.fleetengine.v1.VehicleAttribute.Builder builderForValue) {
      if (requiredAttributesBuilder_ == null) {
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.add(builderForValue.build());
        onChanged();
      } else {
        requiredAttributesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder addRequiredAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttribute.Builder builderForValue) {
      if (requiredAttributesBuilder_ == null) {
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.add(index, builderForValue.build());
        onChanged();
      } else {
        requiredAttributesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder addAllRequiredAttributes(
        java.lang.Iterable<? extends google.maps.fleetengine.v1.VehicleAttribute> values) {
      if (requiredAttributesBuilder_ == null) {
        ensureRequiredAttributesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, requiredAttributes_);
        onChanged();
      } else {
        requiredAttributesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder clearRequiredAttributes() {
      if (requiredAttributesBuilder_ == null) {
        requiredAttributes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
      } else {
        requiredAttributesBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public Builder removeRequiredAttributes(int index) {
      if (requiredAttributesBuilder_ == null) {
        ensureRequiredAttributesIsMutable();
        requiredAttributes_.remove(index);
        onChanged();
      } else {
        requiredAttributesBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public google.maps.fleetengine.v1.VehicleAttribute.Builder getRequiredAttributesBuilder(
        int index) {
      return getRequiredAttributesFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeOrBuilder getRequiredAttributesOrBuilder(
        int index) {
      if (requiredAttributesBuilder_ == null) {
        return requiredAttributes_.get(index);
      } else {
        return requiredAttributesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeOrBuilder>
        getRequiredAttributesOrBuilderList() {
      if (requiredAttributesBuilder_ != null) {
        return requiredAttributesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(requiredAttributes_);
      }
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public google.maps.fleetengine.v1.VehicleAttribute.Builder addRequiredAttributesBuilder() {
      return getRequiredAttributesFieldBuilder()
          .addBuilder(google.maps.fleetengine.v1.VehicleAttribute.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public google.maps.fleetengine.v1.VehicleAttribute.Builder addRequiredAttributesBuilder(
        int index) {
      return getRequiredAttributesFieldBuilder()
          .addBuilder(index, google.maps.fleetengine.v1.VehicleAttribute.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Callers can form complex logical operations using any combination of the
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attribute_sets` fields.
     *
     * `required_attributes` is a list; `required_one_of_attributes` uses a
     * message which allows a list of lists. In combination, the two fields allow
     * the composition of this expression:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
     * ...)
     * AND
     * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
     * ...)
     * ```
     *
     * Restricts the search to only those vehicles with the specified attributes.
     * This field is a conjunction/AND operation. A max of 50 required_attributes
     * is allowed. This matches the maximum number of attributes allowed on a
     * vehicle.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttribute required_attributes = 12;</code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttribute.Builder>
        getRequiredAttributesBuilderList() {
      return getRequiredAttributesFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttribute,
            google.maps.fleetengine.v1.VehicleAttribute.Builder,
            google.maps.fleetengine.v1.VehicleAttributeOrBuilder>
        getRequiredAttributesFieldBuilder() {
      if (requiredAttributesBuilder_ == null) {
        requiredAttributesBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                google.maps.fleetengine.v1.VehicleAttribute,
                google.maps.fleetengine.v1.VehicleAttribute.Builder,
                google.maps.fleetengine.v1.VehicleAttributeOrBuilder>(
                requiredAttributes_,
                ((bitField0_ & 0x00000400) != 0),
                getParentForChildren(),
                isClean());
        requiredAttributes_ = null;
      }
      return requiredAttributesBuilder_;
    }

    private java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
        requiredOneOfAttributes_ = java.util.Collections.emptyList();

    private void ensureRequiredOneOfAttributesIsMutable() {
      if (!((bitField0_ & 0x00000800) != 0)) {
        requiredOneOfAttributes_ =
            new java.util.ArrayList<google.maps.fleetengine.v1.VehicleAttributeList>(
                requiredOneOfAttributes_);
        bitField0_ |= 0x00000800;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttributeList,
            google.maps.fleetengine.v1.VehicleAttributeList.Builder,
            google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        requiredOneOfAttributesBuilder_;

    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
        getRequiredOneOfAttributesList() {
      if (requiredOneOfAttributesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(requiredOneOfAttributes_);
      } else {
        return requiredOneOfAttributesBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public int getRequiredOneOfAttributesCount() {
      if (requiredOneOfAttributesBuilder_ == null) {
        return requiredOneOfAttributes_.size();
      } else {
        return requiredOneOfAttributesBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList getRequiredOneOfAttributes(int index) {
      if (requiredOneOfAttributesBuilder_ == null) {
        return requiredOneOfAttributes_.get(index);
      } else {
        return requiredOneOfAttributesBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder setRequiredOneOfAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.set(index, value);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder setRequiredOneOfAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributesBuilder_ == null) {
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.set(index, builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder addRequiredOneOfAttributes(
        google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.add(value);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder addRequiredOneOfAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.add(index, value);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder addRequiredOneOfAttributes(
        google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributesBuilder_ == null) {
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.add(builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder addRequiredOneOfAttributes(
        int index, google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributesBuilder_ == null) {
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.add(index, builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder addAllRequiredOneOfAttributes(
        java.lang.Iterable<? extends google.maps.fleetengine.v1.VehicleAttributeList> values) {
      if (requiredOneOfAttributesBuilder_ == null) {
        ensureRequiredOneOfAttributesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, requiredOneOfAttributes_);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder clearRequiredOneOfAttributes() {
      if (requiredOneOfAttributesBuilder_ == null) {
        requiredOneOfAttributes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public Builder removeRequiredOneOfAttributes(int index) {
      if (requiredOneOfAttributesBuilder_ == null) {
        ensureRequiredOneOfAttributesIsMutable();
        requiredOneOfAttributes_.remove(index);
        onChanged();
      } else {
        requiredOneOfAttributesBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        getRequiredOneOfAttributesBuilder(int index) {
      return getRequiredOneOfAttributesFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeListOrBuilder
        getRequiredOneOfAttributesOrBuilder(int index) {
      if (requiredOneOfAttributesBuilder_ == null) {
        return requiredOneOfAttributes_.get(index);
      } else {
        return requiredOneOfAttributesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        getRequiredOneOfAttributesOrBuilderList() {
      if (requiredOneOfAttributesBuilder_ != null) {
        return requiredOneOfAttributesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(requiredOneOfAttributes_);
      }
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        addRequiredOneOfAttributesBuilder() {
      return getRequiredOneOfAttributesFieldBuilder()
          .addBuilder(google.maps.fleetengine.v1.VehicleAttributeList.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        addRequiredOneOfAttributesBuilder(int index) {
      return getRequiredOneOfAttributesFieldBuilder()
          .addBuilder(index, google.maps.fleetengine.v1.VehicleAttributeList.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Restricts the search to only those vehicles with at least one of
     * the specified attributes in each `VehicleAttributeList`. Within each
     * list, a vehicle must match at least one of the attributes. This field is an
     * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
     * conjunction/AND operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attributes = 15;
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList.Builder>
        getRequiredOneOfAttributesBuilderList() {
      return getRequiredOneOfAttributesFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttributeList,
            google.maps.fleetengine.v1.VehicleAttributeList.Builder,
            google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        getRequiredOneOfAttributesFieldBuilder() {
      if (requiredOneOfAttributesBuilder_ == null) {
        requiredOneOfAttributesBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                google.maps.fleetengine.v1.VehicleAttributeList,
                google.maps.fleetengine.v1.VehicleAttributeList.Builder,
                google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>(
                requiredOneOfAttributes_,
                ((bitField0_ & 0x00000800) != 0),
                getParentForChildren(),
                isClean());
        requiredOneOfAttributes_ = null;
      }
      return requiredOneOfAttributesBuilder_;
    }

    private java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
        requiredOneOfAttributeSets_ = java.util.Collections.emptyList();

    private void ensureRequiredOneOfAttributeSetsIsMutable() {
      if (!((bitField0_ & 0x00001000) != 0)) {
        requiredOneOfAttributeSets_ =
            new java.util.ArrayList<google.maps.fleetengine.v1.VehicleAttributeList>(
                requiredOneOfAttributeSets_);
        bitField0_ |= 0x00001000;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttributeList,
            google.maps.fleetengine.v1.VehicleAttributeList.Builder,
            google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        requiredOneOfAttributeSetsBuilder_;

    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList>
        getRequiredOneOfAttributeSetsList() {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(requiredOneOfAttributeSets_);
      } else {
        return requiredOneOfAttributeSetsBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public int getRequiredOneOfAttributeSetsCount() {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        return requiredOneOfAttributeSets_.size();
      } else {
        return requiredOneOfAttributeSetsBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList getRequiredOneOfAttributeSets(
        int index) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        return requiredOneOfAttributeSets_.get(index);
      } else {
        return requiredOneOfAttributeSetsBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder setRequiredOneOfAttributeSets(
        int index, google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.set(index, value);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder setRequiredOneOfAttributeSets(
        int index, google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.set(index, builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder addRequiredOneOfAttributeSets(
        google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.add(value);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder addRequiredOneOfAttributeSets(
        int index, google.maps.fleetengine.v1.VehicleAttributeList value) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.add(index, value);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder addRequiredOneOfAttributeSets(
        google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.add(builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder addRequiredOneOfAttributeSets(
        int index, google.maps.fleetengine.v1.VehicleAttributeList.Builder builderForValue) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.add(index, builderForValue.build());
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder addAllRequiredOneOfAttributeSets(
        java.lang.Iterable<? extends google.maps.fleetengine.v1.VehicleAttributeList> values) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        ensureRequiredOneOfAttributeSetsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, requiredOneOfAttributeSets_);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder clearRequiredOneOfAttributeSets() {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        requiredOneOfAttributeSets_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public Builder removeRequiredOneOfAttributeSets(int index) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        ensureRequiredOneOfAttributeSetsIsMutable();
        requiredOneOfAttributeSets_.remove(index);
        onChanged();
      } else {
        requiredOneOfAttributeSetsBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        getRequiredOneOfAttributeSetsBuilder(int index) {
      return getRequiredOneOfAttributeSetsFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeListOrBuilder
        getRequiredOneOfAttributeSetsOrBuilder(int index) {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        return requiredOneOfAttributeSets_.get(index);
      } else {
        return requiredOneOfAttributeSetsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public java.util.List<? extends google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        getRequiredOneOfAttributeSetsOrBuilderList() {
      if (requiredOneOfAttributeSetsBuilder_ != null) {
        return requiredOneOfAttributeSetsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(requiredOneOfAttributeSets_);
      }
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        addRequiredOneOfAttributeSetsBuilder() {
      return getRequiredOneOfAttributeSetsFieldBuilder()
          .addBuilder(google.maps.fleetengine.v1.VehicleAttributeList.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public google.maps.fleetengine.v1.VehicleAttributeList.Builder
        addRequiredOneOfAttributeSetsBuilder(int index) {
      return getRequiredOneOfAttributeSetsFieldBuilder()
          .addBuilder(index, google.maps.fleetengine.v1.VehicleAttributeList.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * `required_one_of_attribute_sets` provides additional functionality.
     *
     * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
     * uses a message which allows a list of lists, allowing expressions such as
     * this one:
     *
     * ```
     * (required_attributes[0] AND required_attributes[1] AND ...)
     * AND
     * (
     *   (required_one_of_attribute_sets[0][0] AND
     *   required_one_of_attribute_sets[0][1] AND
     *   ...)
     *   OR
     *   (required_one_of_attribute_sets[1][0] AND
     *   required_one_of_attribute_sets[1][1] AND
     *   ...)
     * )
     * ```
     *
     * Restricts the search to only those vehicles with all the attributes in a
     * `VehicleAttributeList`. Within each list, a
     * vehicle must match all of the attributes. This field is a conjunction/AND
     * operation in each `VehicleAttributeList` and inclusive disjunction/OR
     * operation across the collection of `VehicleAttributeList`.
     * </pre>
     *
     * <code>repeated .maps.fleetengine.v1.VehicleAttributeList required_one_of_attribute_sets = 20;
     * </code>
     */
    public java.util.List<google.maps.fleetengine.v1.VehicleAttributeList.Builder>
        getRequiredOneOfAttributeSetsBuilderList() {
      return getRequiredOneOfAttributeSetsFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            google.maps.fleetengine.v1.VehicleAttributeList,
            google.maps.fleetengine.v1.VehicleAttributeList.Builder,
            google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>
        getRequiredOneOfAttributeSetsFieldBuilder() {
      if (requiredOneOfAttributeSetsBuilder_ == null) {
        requiredOneOfAttributeSetsBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                google.maps.fleetengine.v1.VehicleAttributeList,
                google.maps.fleetengine.v1.VehicleAttributeList.Builder,
                google.maps.fleetengine.v1.VehicleAttributeListOrBuilder>(
                requiredOneOfAttributeSets_,
                ((bitField0_ & 0x00001000) != 0),
                getParentForChildren(),
                isClean());
        requiredOneOfAttributeSets_ = null;
      }
      return requiredOneOfAttributeSetsBuilder_;
    }

    private int orderBy_ = 0;
    /**
     *
     *
     * <pre>
     * Required. Specifies the desired ordering criterion for results.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return The enum numeric value on the wire for orderBy.
     */
    @java.lang.Override
    public int getOrderByValue() {
      return orderBy_;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the desired ordering criterion for results.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param value The enum numeric value on the wire for orderBy to set.
     * @return This builder for chaining.
     */
    public Builder setOrderByValue(int value) {
      orderBy_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the desired ordering criterion for results.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return The orderBy.
     */
    @java.lang.Override
    public google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder getOrderBy() {
      google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder result =
          google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder.forNumber(orderBy_);
      return result == null
          ? google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the desired ordering criterion for results.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @param value The orderBy to set.
     * @return This builder for chaining.
     */
    public Builder setOrderBy(
        google.maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00002000;
      orderBy_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Required. Specifies the desired ordering criterion for results.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.VehicleMatchOrder order_by = 13 [(.google.api.field_behavior) = REQUIRED];
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearOrderBy() {
      bitField0_ = (bitField0_ & ~0x00002000);
      orderBy_ = 0;
      onChanged();
      return this;
    }

    private boolean includeBackToBack_;
    /**
     *
     *
     * <pre>
     * Indicates if a vehicle with a single active trip is eligible for another
     * match. If `false`, vehicles with assigned trips are excluded from the
     * search results. If `true`, search results include vehicles with
     * `TripStatus` of `ENROUTE_TO_DROPOFF`.
     *
     * This field is only considered if a single `trip_type` of `EXCLUSIVE` is
     * specified.
     *
     * The default value is `false`.
     * </pre>
     *
     * <code>bool include_back_to_back = 18;</code>
     *
     * @return The includeBackToBack.
     */
    @java.lang.Override
    public boolean getIncludeBackToBack() {
      return includeBackToBack_;
    }
    /**
     *
     *
     * <pre>
     * Indicates if a vehicle with a single active trip is eligible for another
     * match. If `false`, vehicles with assigned trips are excluded from the
     * search results. If `true`, search results include vehicles with
     * `TripStatus` of `ENROUTE_TO_DROPOFF`.
     *
     * This field is only considered if a single `trip_type` of `EXCLUSIVE` is
     * specified.
     *
     * The default value is `false`.
     * </pre>
     *
     * <code>bool include_back_to_back = 18;</code>
     *
     * @param value The includeBackToBack to set.
     * @return This builder for chaining.
     */
    public Builder setIncludeBackToBack(boolean value) {

      includeBackToBack_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates if a vehicle with a single active trip is eligible for another
     * match. If `false`, vehicles with assigned trips are excluded from the
     * search results. If `true`, search results include vehicles with
     * `TripStatus` of `ENROUTE_TO_DROPOFF`.
     *
     * This field is only considered if a single `trip_type` of `EXCLUSIVE` is
     * specified.
     *
     * The default value is `false`.
     * </pre>
     *
     * <code>bool include_back_to_back = 18;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearIncludeBackToBack() {
      bitField0_ = (bitField0_ & ~0x00004000);
      includeBackToBack_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object tripId_ = "";
    /**
     *
     *
     * <pre>
     * Indicates the trip associated with this `SearchVehicleRequest`.
     * </pre>
     *
     * <code>string trip_id = 19;</code>
     *
     * @return The tripId.
     */
    public java.lang.String getTripId() {
      java.lang.Object ref = tripId_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        tripId_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Indicates the trip associated with this `SearchVehicleRequest`.
     * </pre>
     *
     * <code>string trip_id = 19;</code>
     *
     * @return The bytes for tripId.
     */
    public com.google.protobuf.ByteString getTripIdBytes() {
      java.lang.Object ref = tripId_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        tripId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Indicates the trip associated with this `SearchVehicleRequest`.
     * </pre>
     *
     * <code>string trip_id = 19;</code>
     *
     * @param value The tripId to set.
     * @return This builder for chaining.
     */
    public Builder setTripId(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      tripId_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates the trip associated with this `SearchVehicleRequest`.
     * </pre>
     *
     * <code>string trip_id = 19;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTripId() {
      tripId_ = getDefaultInstance().getTripId();
      bitField0_ = (bitField0_ & ~0x00008000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates the trip associated with this `SearchVehicleRequest`.
     * </pre>
     *
     * <code>string trip_id = 19;</code>
     *
     * @param value The bytes for tripId to set.
     * @return This builder for chaining.
     */
    public Builder setTripIdBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      tripId_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    private int currentTripsPresent_ = 0;
    /**
     *
     *
     * <pre>
     * Restricts vehicles from appearing in the search results based on
     * their current trips.
     *
     * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     * `EXCLUSIVE` or `SHARED`, but not both.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
     * </code>
     *
     * @return The enum numeric value on the wire for currentTripsPresent.
     */
    @java.lang.Override
    public int getCurrentTripsPresentValue() {
      return currentTripsPresent_;
    }
    /**
     *
     *
     * <pre>
     * Restricts vehicles from appearing in the search results based on
     * their current trips.
     *
     * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     * `EXCLUSIVE` or `SHARED`, but not both.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
     * </code>
     *
     * @param value The enum numeric value on the wire for currentTripsPresent to set.
     * @return This builder for chaining.
     */
    public Builder setCurrentTripsPresentValue(int value) {
      currentTripsPresent_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts vehicles from appearing in the search results based on
     * their current trips.
     *
     * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     * `EXCLUSIVE` or `SHARED`, but not both.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
     * </code>
     *
     * @return The currentTripsPresent.
     */
    @java.lang.Override
    public google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent
        getCurrentTripsPresent() {
      google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent result =
          google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent.forNumber(
              currentTripsPresent_);
      return result == null
          ? google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Restricts vehicles from appearing in the search results based on
     * their current trips.
     *
     * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     * `EXCLUSIVE` or `SHARED`, but not both.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
     * </code>
     *
     * @param value The currentTripsPresent to set.
     * @return This builder for chaining.
     */
    public Builder setCurrentTripsPresent(
        google.maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00010000;
      currentTripsPresent_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Restricts vehicles from appearing in the search results based on
     * their current trips.
     *
     * When current_trips_present is `NONE` or `ANY`, `trip_types` can be either
     * `EXCLUSIVE` or `SHARED`, but not both.
     * </pre>
     *
     * <code>
     * .maps.fleetengine.v1.SearchVehiclesRequest.CurrentTripsPresent current_trips_present = 21;
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCurrentTripsPresent() {
      bitField0_ = (bitField0_ & ~0x00010000);
      currentTripsPresent_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object filter_ = "";
    /**
     *
     *
     * <pre>
     * Optional. A filter query to apply when searching vehicles. See
     * http://aip.dev/160 for examples of the filter syntax.
     *
     * This field is designed to replace the `required_attributes`,
     * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     * If a non-empty value is specified here, the following fields must be empty:
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attributes_sets`.
     *
     * This filter functions as an AND clause with other constraints,
     * such as `minimum_capacity` or `vehicle_types`.
     *
     * Note that the only queries supported are on vehicle attributes (for
     * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
     * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
     * in a filter query is 50.
     *
     * Also, all attributes are stored as strings, so the only supported
     * comparisons against attributes are string comparisons. In order to compare
     * against number or boolean values, the values must be explicitly quoted to
     * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
     * `attributes.&lt;key&gt; = "true"`).
     * </pre>
     *
     * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The filter.
     */
    public java.lang.String getFilter() {
      java.lang.Object ref = filter_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        filter_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Optional. A filter query to apply when searching vehicles. See
     * http://aip.dev/160 for examples of the filter syntax.
     *
     * This field is designed to replace the `required_attributes`,
     * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     * If a non-empty value is specified here, the following fields must be empty:
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attributes_sets`.
     *
     * This filter functions as an AND clause with other constraints,
     * such as `minimum_capacity` or `vehicle_types`.
     *
     * Note that the only queries supported are on vehicle attributes (for
     * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
     * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
     * in a filter query is 50.
     *
     * Also, all attributes are stored as strings, so the only supported
     * comparisons against attributes are string comparisons. In order to compare
     * against number or boolean values, the values must be explicitly quoted to
     * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
     * `attributes.&lt;key&gt; = "true"`).
     * </pre>
     *
     * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The bytes for filter.
     */
    public com.google.protobuf.ByteString getFilterBytes() {
      java.lang.Object ref = filter_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        filter_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Optional. A filter query to apply when searching vehicles. See
     * http://aip.dev/160 for examples of the filter syntax.
     *
     * This field is designed to replace the `required_attributes`,
     * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     * If a non-empty value is specified here, the following fields must be empty:
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attributes_sets`.
     *
     * This filter functions as an AND clause with other constraints,
     * such as `minimum_capacity` or `vehicle_types`.
     *
     * Note that the only queries supported are on vehicle attributes (for
     * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
     * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
     * in a filter query is 50.
     *
     * Also, all attributes are stored as strings, so the only supported
     * comparisons against attributes are string comparisons. In order to compare
     * against number or boolean values, the values must be explicitly quoted to
     * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
     * `attributes.&lt;key&gt; = "true"`).
     * </pre>
     *
     * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @param value The filter to set.
     * @return This builder for chaining.
     */
    public Builder setFilter(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      filter_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Optional. A filter query to apply when searching vehicles. See
     * http://aip.dev/160 for examples of the filter syntax.
     *
     * This field is designed to replace the `required_attributes`,
     * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     * If a non-empty value is specified here, the following fields must be empty:
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attributes_sets`.
     *
     * This filter functions as an AND clause with other constraints,
     * such as `minimum_capacity` or `vehicle_types`.
     *
     * Note that the only queries supported are on vehicle attributes (for
     * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
     * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
     * in a filter query is 50.
     *
     * Also, all attributes are stored as strings, so the only supported
     * comparisons against attributes are string comparisons. In order to compare
     * against number or boolean values, the values must be explicitly quoted to
     * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
     * `attributes.&lt;key&gt; = "true"`).
     * </pre>
     *
     * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearFilter() {
      filter_ = getDefaultInstance().getFilter();
      bitField0_ = (bitField0_ & ~0x00020000);
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Optional. A filter query to apply when searching vehicles. See
     * http://aip.dev/160 for examples of the filter syntax.
     *
     * This field is designed to replace the `required_attributes`,
     * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
     * If a non-empty value is specified here, the following fields must be empty:
     * `required_attributes`, `required_one_of_attributes`, and
     * `required_one_of_attributes_sets`.
     *
     * This filter functions as an AND clause with other constraints,
     * such as `minimum_capacity` or `vehicle_types`.
     *
     * Note that the only queries supported are on vehicle attributes (for
     * example, `attributes.&lt;key&gt; = &lt;value&gt;` or `attributes.&lt;key1&gt; = &lt;value1&gt; AND
     * attributes.&lt;key2&gt; = &lt;value2&gt;`). The maximum number of restrictions allowed
     * in a filter query is 50.
     *
     * Also, all attributes are stored as strings, so the only supported
     * comparisons against attributes are string comparisons. In order to compare
     * against number or boolean values, the values must be explicitly quoted to
     * be treated as strings (for example, `attributes.&lt;key&gt; = "10"` or
     * `attributes.&lt;key&gt; = "true"`).
     * </pre>
     *
     * <code>string filter = 22 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @param value The bytes for filter to set.
     * @return This builder for chaining.
     */
    public Builder setFilterBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);
      filter_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:maps.fleetengine.v1.SearchVehiclesRequest)
  }

  // @@protoc_insertion_point(class_scope:maps.fleetengine.v1.SearchVehiclesRequest)
  private static final google.maps.fleetengine.v1.SearchVehiclesRequest DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new google.maps.fleetengine.v1.SearchVehiclesRequest();
  }

  public static google.maps.fleetengine.v1.SearchVehiclesRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<SearchVehiclesRequest> PARSER =
      new com.google.protobuf.AbstractParser<SearchVehiclesRequest>() {
        @java.lang.Override
        public SearchVehiclesRequest parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

  public static com.google.protobuf.Parser<SearchVehiclesRequest> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<SearchVehiclesRequest> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public google.maps.fleetengine.v1.SearchVehiclesRequest getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
