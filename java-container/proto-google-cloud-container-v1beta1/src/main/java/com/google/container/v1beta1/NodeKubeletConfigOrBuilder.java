/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/container/v1beta1/cluster_service.proto

// Protobuf Java Version: 3.25.8
package com.google.container.v1beta1;

public interface NodeKubeletConfigOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.container.v1beta1.NodeKubeletConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * Control the CPU management policy on the node.
   * See
   * https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/
   *
   * The following values are allowed.
   * * "none": the default, which represents the existing scheduling behavior.
   * * "static": allows pods with certain resource characteristics to be granted
   * increased CPU affinity and exclusivity on the node.
   * The default value is 'none' if unspecified.
   * </pre>
   *
   * <code>string cpu_manager_policy = 1;</code>
   *
   * @return The cpuManagerPolicy.
   */
  java.lang.String getCpuManagerPolicy();

  /**
   *
   *
   * <pre>
   * Control the CPU management policy on the node.
   * See
   * https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/
   *
   * The following values are allowed.
   * * "none": the default, which represents the existing scheduling behavior.
   * * "static": allows pods with certain resource characteristics to be granted
   * increased CPU affinity and exclusivity on the node.
   * The default value is 'none' if unspecified.
   * </pre>
   *
   * <code>string cpu_manager_policy = 1;</code>
   *
   * @return The bytes for cpuManagerPolicy.
   */
  com.google.protobuf.ByteString getCpuManagerPolicyBytes();

  /**
   *
   *
   * <pre>
   * Optional. Controls Topology Manager configuration on the node.
   * For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.TopologyManager topology_manager = 8 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return Whether the topologyManager field is set.
   */
  boolean hasTopologyManager();

  /**
   *
   *
   * <pre>
   * Optional. Controls Topology Manager configuration on the node.
   * For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.TopologyManager topology_manager = 8 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The topologyManager.
   */
  com.google.container.v1beta1.TopologyManager getTopologyManager();

  /**
   *
   *
   * <pre>
   * Optional. Controls Topology Manager configuration on the node.
   * For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.TopologyManager topology_manager = 8 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   */
  com.google.container.v1beta1.TopologyManagerOrBuilder getTopologyManagerOrBuilder();

  /**
   *
   *
   * <pre>
   * Optional. Controls NUMA-aware Memory Manager configuration on the
   * node. For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.MemoryManager memory_manager = 9 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return Whether the memoryManager field is set.
   */
  boolean hasMemoryManager();

  /**
   *
   *
   * <pre>
   * Optional. Controls NUMA-aware Memory Manager configuration on the
   * node. For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.MemoryManager memory_manager = 9 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The memoryManager.
   */
  com.google.container.v1beta1.MemoryManager getMemoryManager();

  /**
   *
   *
   * <pre>
   * Optional. Controls NUMA-aware Memory Manager configuration on the
   * node. For more information, see:
   * https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.MemoryManager memory_manager = 9 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   */
  com.google.container.v1beta1.MemoryManagerOrBuilder getMemoryManagerOrBuilder();

  /**
   *
   *
   * <pre>
   * Enable CPU CFS quota enforcement for containers that specify CPU limits.
   *
   * This option is enabled by default which makes kubelet use CFS quota
   * (https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) to
   * enforce container CPU limits. Otherwise, CPU limits will not be enforced at
   * all.
   *
   * Disable this option to mitigate CPU throttling problems while still having
   * your pods to be in Guaranteed QoS class by specifying the CPU limits.
   *
   * The default value is 'true' if unspecified.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue cpu_cfs_quota = 2;</code>
   *
   * @return Whether the cpuCfsQuota field is set.
   */
  boolean hasCpuCfsQuota();

  /**
   *
   *
   * <pre>
   * Enable CPU CFS quota enforcement for containers that specify CPU limits.
   *
   * This option is enabled by default which makes kubelet use CFS quota
   * (https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) to
   * enforce container CPU limits. Otherwise, CPU limits will not be enforced at
   * all.
   *
   * Disable this option to mitigate CPU throttling problems while still having
   * your pods to be in Guaranteed QoS class by specifying the CPU limits.
   *
   * The default value is 'true' if unspecified.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue cpu_cfs_quota = 2;</code>
   *
   * @return The cpuCfsQuota.
   */
  com.google.protobuf.BoolValue getCpuCfsQuota();

  /**
   *
   *
   * <pre>
   * Enable CPU CFS quota enforcement for containers that specify CPU limits.
   *
   * This option is enabled by default which makes kubelet use CFS quota
   * (https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) to
   * enforce container CPU limits. Otherwise, CPU limits will not be enforced at
   * all.
   *
   * Disable this option to mitigate CPU throttling problems while still having
   * your pods to be in Guaranteed QoS class by specifying the CPU limits.
   *
   * The default value is 'true' if unspecified.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue cpu_cfs_quota = 2;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getCpuCfsQuotaOrBuilder();

  /**
   *
   *
   * <pre>
   * Set the CPU CFS quota period value 'cpu.cfs_period_us'.
   *
   * The string must be a sequence of decimal numbers, each with optional
   * fraction and a unit suffix, such as "300ms".
   * Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   * The value must be a positive duration.
   * </pre>
   *
   * <code>string cpu_cfs_quota_period = 3;</code>
   *
   * @return The cpuCfsQuotaPeriod.
   */
  java.lang.String getCpuCfsQuotaPeriod();

  /**
   *
   *
   * <pre>
   * Set the CPU CFS quota period value 'cpu.cfs_period_us'.
   *
   * The string must be a sequence of decimal numbers, each with optional
   * fraction and a unit suffix, such as "300ms".
   * Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   * The value must be a positive duration.
   * </pre>
   *
   * <code>string cpu_cfs_quota_period = 3;</code>
   *
   * @return The bytes for cpuCfsQuotaPeriod.
   */
  com.google.protobuf.ByteString getCpuCfsQuotaPeriodBytes();

  /**
   *
   *
   * <pre>
   * Set the Pod PID limits. See
   * https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits
   *
   * Controls the maximum number of processes allowed to run in a pod. The value
   * must be greater than or equal to 1024 and less than 4194304.
   * </pre>
   *
   * <code>int64 pod_pids_limit = 4;</code>
   *
   * @return The podPidsLimit.
   */
  long getPodPidsLimit();

  /**
   *
   *
   * <pre>
   * Enable or disable Kubelet read only port.
   * </pre>
   *
   * <code>optional bool insecure_kubelet_readonly_port_enabled = 7;</code>
   *
   * @return Whether the insecureKubeletReadonlyPortEnabled field is set.
   */
  boolean hasInsecureKubeletReadonlyPortEnabled();

  /**
   *
   *
   * <pre>
   * Enable or disable Kubelet read only port.
   * </pre>
   *
   * <code>optional bool insecure_kubelet_readonly_port_enabled = 7;</code>
   *
   * @return The insecureKubeletReadonlyPortEnabled.
   */
  boolean getInsecureKubeletReadonlyPortEnabled();

  /**
   *
   *
   * <pre>
   * Optional. Defines the percent of disk usage before which image garbage
   * collection is never run. Lowest disk usage to garbage collect to. The
   * percent is calculated as this field value out of 100.
   *
   * The value must be between 10 and 85, inclusive and smaller than
   * image_gc_high_threshold_percent.
   *
   * The default value is 80 if unspecified.
   * </pre>
   *
   * <code>int32 image_gc_low_threshold_percent = 10 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The imageGcLowThresholdPercent.
   */
  int getImageGcLowThresholdPercent();

  /**
   *
   *
   * <pre>
   * Optional. Defines the percent of disk usage after which image garbage
   * collection is always run. The percent is calculated as this field value out
   * of 100.
   *
   * The value must be between 10 and 85, inclusive and greater than
   * image_gc_low_threshold_percent.
   *
   * The default value is 85 if unspecified.
   * </pre>
   *
   * <code>int32 image_gc_high_threshold_percent = 11 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The imageGcHighThresholdPercent.
   */
  int getImageGcHighThresholdPercent();

  /**
   *
   *
   * <pre>
   * Optional. Defines the minimum age for an unused image before it is garbage
   * collected.
   *
   * The string must be a sequence of decimal numbers, each with optional
   * fraction and a unit suffix, such as "300s", "1.5h", and "2h45m". Valid time
   * units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * The value must be a positive duration less than or equal to 2 minutes.
   *
   * The default value is "2m0s" if unspecified.
   * </pre>
   *
   * <code>string image_minimum_gc_age = 12 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The imageMinimumGcAge.
   */
  java.lang.String getImageMinimumGcAge();

  /**
   *
   *
   * <pre>
   * Optional. Defines the minimum age for an unused image before it is garbage
   * collected.
   *
   * The string must be a sequence of decimal numbers, each with optional
   * fraction and a unit suffix, such as "300s", "1.5h", and "2h45m". Valid time
   * units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * The value must be a positive duration less than or equal to 2 minutes.
   *
   * The default value is "2m0s" if unspecified.
   * </pre>
   *
   * <code>string image_minimum_gc_age = 12 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The bytes for imageMinimumGcAge.
   */
  com.google.protobuf.ByteString getImageMinimumGcAgeBytes();

  /**
   *
   *
   * <pre>
   * Optional. Defines the maximum age an image can be unused before it is
   * garbage collected. The string must be a sequence of decimal numbers, each
   * with optional fraction and a unit suffix, such as "300s", "1.5h", and
   * "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * The value must be a positive duration greater than image_minimum_gc_age
   * or "0s".
   *
   * The default value is "0s" if unspecified, which disables this field,
   * meaning images won't be garbage collected based on being unused for too
   * long.
   * </pre>
   *
   * <code>string image_maximum_gc_age = 13 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The imageMaximumGcAge.
   */
  java.lang.String getImageMaximumGcAge();

  /**
   *
   *
   * <pre>
   * Optional. Defines the maximum age an image can be unused before it is
   * garbage collected. The string must be a sequence of decimal numbers, each
   * with optional fraction and a unit suffix, such as "300s", "1.5h", and
   * "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * The value must be a positive duration greater than image_minimum_gc_age
   * or "0s".
   *
   * The default value is "0s" if unspecified, which disables this field,
   * meaning images won't be garbage collected based on being unused for too
   * long.
   * </pre>
   *
   * <code>string image_maximum_gc_age = 13 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The bytes for imageMaximumGcAge.
   */
  com.google.protobuf.ByteString getImageMaximumGcAgeBytes();

  /**
   *
   *
   * <pre>
   * Optional. Defines the maximum size of the container log file before it is
   * rotated. See
   * https://kubernetes.io/docs/concepts/cluster-administration/logging/#log-rotation
   *
   * Valid format is positive number + unit, e.g. 100Ki, 10Mi. Valid units are
   * Ki, Mi, Gi.
   * The value must be between 10Mi and 500Mi, inclusive.
   *
   * Note that the total container log size (container_log_max_size *
   * container_log_max_files) cannot exceed 1% of the total
   * storage of the node, to avoid disk pressure caused by log files.
   *
   * The default value is 10Mi if unspecified.
   * </pre>
   *
   * <code>string container_log_max_size = 14 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The containerLogMaxSize.
   */
  java.lang.String getContainerLogMaxSize();

  /**
   *
   *
   * <pre>
   * Optional. Defines the maximum size of the container log file before it is
   * rotated. See
   * https://kubernetes.io/docs/concepts/cluster-administration/logging/#log-rotation
   *
   * Valid format is positive number + unit, e.g. 100Ki, 10Mi. Valid units are
   * Ki, Mi, Gi.
   * The value must be between 10Mi and 500Mi, inclusive.
   *
   * Note that the total container log size (container_log_max_size *
   * container_log_max_files) cannot exceed 1% of the total
   * storage of the node, to avoid disk pressure caused by log files.
   *
   * The default value is 10Mi if unspecified.
   * </pre>
   *
   * <code>string container_log_max_size = 14 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The bytes for containerLogMaxSize.
   */
  com.google.protobuf.ByteString getContainerLogMaxSizeBytes();

  /**
   *
   *
   * <pre>
   * Optional. Defines the maximum number of container log files that can be
   * present for a container. See
   * https://kubernetes.io/docs/concepts/cluster-administration/logging/#log-rotation
   *
   * The value must be an integer between 2 and 10, inclusive.
   * The default value is 5 if unspecified.
   * </pre>
   *
   * <code>int32 container_log_max_files = 15 [(.google.api.field_behavior) = OPTIONAL];</code>
   *
   * @return The containerLogMaxFiles.
   */
  int getContainerLogMaxFiles();

  /**
   *
   *
   * <pre>
   * Optional. Defines a comma-separated allowlist of unsafe sysctls or sysctl
   * patterns (ending in `*`).
   *
   * The unsafe namespaced sysctl groups are `kernel.shm*`, `kernel.msg*`,
   * `kernel.sem`, `fs.mqueue.*`, and `net.*`. Leaving this allowlist empty
   * means they cannot be set on Pods.
   *
   * To allow certain sysctls or sysctl patterns to be set on Pods, list them
   * separated by commas.
   * For example: `kernel.msg*,net.ipv4.route.min_pmtu`.
   *
   * See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
   * for more details.
   * </pre>
   *
   * <code>repeated string allowed_unsafe_sysctls = 16 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return A list containing the allowedUnsafeSysctls.
   */
  java.util.List<java.lang.String> getAllowedUnsafeSysctlsList();

  /**
   *
   *
   * <pre>
   * Optional. Defines a comma-separated allowlist of unsafe sysctls or sysctl
   * patterns (ending in `*`).
   *
   * The unsafe namespaced sysctl groups are `kernel.shm*`, `kernel.msg*`,
   * `kernel.sem`, `fs.mqueue.*`, and `net.*`. Leaving this allowlist empty
   * means they cannot be set on Pods.
   *
   * To allow certain sysctls or sysctl patterns to be set on Pods, list them
   * separated by commas.
   * For example: `kernel.msg*,net.ipv4.route.min_pmtu`.
   *
   * See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
   * for more details.
   * </pre>
   *
   * <code>repeated string allowed_unsafe_sysctls = 16 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The count of allowedUnsafeSysctls.
   */
  int getAllowedUnsafeSysctlsCount();

  /**
   *
   *
   * <pre>
   * Optional. Defines a comma-separated allowlist of unsafe sysctls or sysctl
   * patterns (ending in `*`).
   *
   * The unsafe namespaced sysctl groups are `kernel.shm*`, `kernel.msg*`,
   * `kernel.sem`, `fs.mqueue.*`, and `net.*`. Leaving this allowlist empty
   * means they cannot be set on Pods.
   *
   * To allow certain sysctls or sysctl patterns to be set on Pods, list them
   * separated by commas.
   * For example: `kernel.msg*,net.ipv4.route.min_pmtu`.
   *
   * See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
   * for more details.
   * </pre>
   *
   * <code>repeated string allowed_unsafe_sysctls = 16 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @param index The index of the element to return.
   * @return The allowedUnsafeSysctls at the given index.
   */
  java.lang.String getAllowedUnsafeSysctls(int index);

  /**
   *
   *
   * <pre>
   * Optional. Defines a comma-separated allowlist of unsafe sysctls or sysctl
   * patterns (ending in `*`).
   *
   * The unsafe namespaced sysctl groups are `kernel.shm*`, `kernel.msg*`,
   * `kernel.sem`, `fs.mqueue.*`, and `net.*`. Leaving this allowlist empty
   * means they cannot be set on Pods.
   *
   * To allow certain sysctls or sysctl patterns to be set on Pods, list them
   * separated by commas.
   * For example: `kernel.msg*,net.ipv4.route.min_pmtu`.
   *
   * See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/
   * for more details.
   * </pre>
   *
   * <code>repeated string allowed_unsafe_sysctls = 16 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the allowedUnsafeSysctls at the given index.
   */
  com.google.protobuf.ByteString getAllowedUnsafeSysctlsBytes(int index);
}
