/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/container/v1beta1/cluster_service.proto

// Protobuf Java Version: 3.25.8
package com.google.container.v1beta1;

/**
 *
 *
 * <pre>
 * Parameters that can be configured on Linux nodes.
 * </pre>
 *
 * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig}
 */
public final class LinuxNodeConfig extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig)
    LinuxNodeConfigOrBuilder {
  private static final long serialVersionUID = 0L;

  // Use LinuxNodeConfig.newBuilder() to construct.
  private LinuxNodeConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private LinuxNodeConfig() {
    cgroupMode_ = 0;
    transparentHugepageEnabled_ = 0;
    transparentHugepageDefrag_ = 0;
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new LinuxNodeConfig();
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.container.v1beta1.ClusterServiceProto
        .internal_static_google_container_v1beta1_LinuxNodeConfig_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
      int number) {
    switch (number) {
      case 1:
        return internalGetSysctls();
      default:
        throw new RuntimeException("Invalid map field number: " + number);
    }
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.container.v1beta1.ClusterServiceProto
        .internal_static_google_container_v1beta1_LinuxNodeConfig_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.container.v1beta1.LinuxNodeConfig.class,
            com.google.container.v1beta1.LinuxNodeConfig.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * Possible cgroup modes that can be used.
   * </pre>
   *
   * Protobuf enum {@code google.container.v1beta1.LinuxNodeConfig.CgroupMode}
   */
  public enum CgroupMode implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
     * The default for the GKE node OS image will be used.
     * </pre>
     *
     * <code>CGROUP_MODE_UNSPECIFIED = 0;</code>
     */
    CGROUP_MODE_UNSPECIFIED(0),
    /**
     *
     *
     * <pre>
     * CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
     * the node image.
     * </pre>
     *
     * <code>CGROUP_MODE_V1 = 1;</code>
     */
    CGROUP_MODE_V1(1),
    /**
     *
     *
     * <pre>
     * CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
     * the node image.
     * </pre>
     *
     * <code>CGROUP_MODE_V2 = 2;</code>
     */
    CGROUP_MODE_V2(2),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
     * The default for the GKE node OS image will be used.
     * </pre>
     *
     * <code>CGROUP_MODE_UNSPECIFIED = 0;</code>
     */
    public static final int CGROUP_MODE_UNSPECIFIED_VALUE = 0;

    /**
     *
     *
     * <pre>
     * CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
     * the node image.
     * </pre>
     *
     * <code>CGROUP_MODE_V1 = 1;</code>
     */
    public static final int CGROUP_MODE_V1_VALUE = 1;

    /**
     *
     *
     * <pre>
     * CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
     * the node image.
     * </pre>
     *
     * <code>CGROUP_MODE_V2 = 2;</code>
     */
    public static final int CGROUP_MODE_V2_VALUE = 2;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CgroupMode valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CgroupMode forNumber(int value) {
      switch (value) {
        case 0:
          return CGROUP_MODE_UNSPECIFIED;
        case 1:
          return CGROUP_MODE_V1;
        case 2:
          return CGROUP_MODE_V2;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CgroupMode> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<CgroupMode> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<CgroupMode>() {
          public CgroupMode findValueByNumber(int number) {
            return CgroupMode.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.container.v1beta1.LinuxNodeConfig.getDescriptor().getEnumTypes().get(0);
    }

    private static final CgroupMode[] VALUES = values();

    public static CgroupMode valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CgroupMode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.container.v1beta1.LinuxNodeConfig.CgroupMode)
  }

  /**
   *
   *
   * <pre>
   * Possible values for transparent hugepage enabled support.
   * </pre>
   *
   * Protobuf enum {@code google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled}
   */
  public enum TransparentHugepageEnabled implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Default value. GKE will not modify the kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED = 0;</code>
     */
    TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED(0),
    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is enabled system wide.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS = 1;</code>
     */
    TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS(1),
    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is enabled inside
     * MADV_HUGEPAGE regions. This is the default kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_MADVISE = 2;</code>
     */
    TRANSPARENT_HUGEPAGE_ENABLED_MADVISE(2),
    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is disabled.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_NEVER = 3;</code>
     */
    TRANSPARENT_HUGEPAGE_ENABLED_NEVER(3),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Default value. GKE will not modify the kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED = 0;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED_VALUE = 0;

    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is enabled system wide.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS = 1;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS_VALUE = 1;

    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is enabled inside
     * MADV_HUGEPAGE regions. This is the default kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_MADVISE = 2;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_ENABLED_MADVISE_VALUE = 2;

    /**
     *
     *
     * <pre>
     * Transparent hugepage support for anonymous memory is disabled.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_ENABLED_NEVER = 3;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_ENABLED_NEVER_VALUE = 3;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static TransparentHugepageEnabled valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static TransparentHugepageEnabled forNumber(int value) {
      switch (value) {
        case 0:
          return TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED;
        case 1:
          return TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS;
        case 2:
          return TRANSPARENT_HUGEPAGE_ENABLED_MADVISE;
        case 3:
          return TRANSPARENT_HUGEPAGE_ENABLED_NEVER;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageEnabled>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageEnabled>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageEnabled>() {
              public TransparentHugepageEnabled findValueByNumber(int number) {
                return TransparentHugepageEnabled.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.container.v1beta1.LinuxNodeConfig.getDescriptor().getEnumTypes().get(1);
    }

    private static final TransparentHugepageEnabled[] VALUES = values();

    public static TransparentHugepageEnabled valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private TransparentHugepageEnabled(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled)
  }

  /**
   *
   *
   * <pre>
   * Possible values for transparent hugepage defrag support.
   * </pre>
   *
   * Protobuf enum {@code google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag}
   */
  public enum TransparentHugepageDefrag implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Default value. GKE will not modify the kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED = 0;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED(0),
    /**
     *
     *
     * <pre>
     * It means that an application requesting THP will stall on allocation
     * failure and directly reclaim pages and compact memory in an effort to
     * allocate a THP immediately.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS = 1;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS(1),
    /**
     *
     *
     * <pre>
     * It means that an application will wake kswapd in the background to
     * reclaim pages and wake kcompactd to compact memory so that THP is
     * available in the near future. It's the responsibility of khugepaged to
     * then install the THP pages later.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_DEFER = 2;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_DEFER(2),
    /**
     *
     *
     * <pre>
     * It means that an application will enter direct reclaim and compaction
     * like always, but only for regions that have used madvise(MADV_HUGEPAGE);
     * all other regions will wake kswapd in the background to reclaim pages and
     * wake kcompactd to compact memory so that THP is available in the near
     * future.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE = 3;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE(3),
    /**
     *
     *
     * <pre>
     * It means that an application will enter direct reclaim like always but
     * only for regions that are have used madvise(MADV_HUGEPAGE). This is the
     * default kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE = 4;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE(4),
    /**
     *
     *
     * <pre>
     * It means that an application will never enter direct reclaim or
     * compaction.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_NEVER = 5;</code>
     */
    TRANSPARENT_HUGEPAGE_DEFRAG_NEVER(5),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Default value. GKE will not modify the kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED = 0;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED_VALUE = 0;

    /**
     *
     *
     * <pre>
     * It means that an application requesting THP will stall on allocation
     * failure and directly reclaim pages and compact memory in an effort to
     * allocate a THP immediately.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS = 1;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS_VALUE = 1;

    /**
     *
     *
     * <pre>
     * It means that an application will wake kswapd in the background to
     * reclaim pages and wake kcompactd to compact memory so that THP is
     * available in the near future. It's the responsibility of khugepaged to
     * then install the THP pages later.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_DEFER = 2;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_VALUE = 2;

    /**
     *
     *
     * <pre>
     * It means that an application will enter direct reclaim and compaction
     * like always, but only for regions that have used madvise(MADV_HUGEPAGE);
     * all other regions will wake kswapd in the background to reclaim pages and
     * wake kcompactd to compact memory so that THP is available in the near
     * future.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE = 3;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE_VALUE = 3;

    /**
     *
     *
     * <pre>
     * It means that an application will enter direct reclaim like always but
     * only for regions that are have used madvise(MADV_HUGEPAGE). This is the
     * default kernel configuration.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE = 4;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE_VALUE = 4;

    /**
     *
     *
     * <pre>
     * It means that an application will never enter direct reclaim or
     * compaction.
     * </pre>
     *
     * <code>TRANSPARENT_HUGEPAGE_DEFRAG_NEVER = 5;</code>
     */
    public static final int TRANSPARENT_HUGEPAGE_DEFRAG_NEVER_VALUE = 5;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static TransparentHugepageDefrag valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static TransparentHugepageDefrag forNumber(int value) {
      switch (value) {
        case 0:
          return TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED;
        case 1:
          return TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS;
        case 2:
          return TRANSPARENT_HUGEPAGE_DEFRAG_DEFER;
        case 3:
          return TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE;
        case 4:
          return TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE;
        case 5:
          return TRANSPARENT_HUGEPAGE_DEFRAG_NEVER;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageDefrag>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageDefrag>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TransparentHugepageDefrag>() {
              public TransparentHugepageDefrag findValueByNumber(int number) {
                return TransparentHugepageDefrag.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.container.v1beta1.LinuxNodeConfig.getDescriptor().getEnumTypes().get(2);
    }

    private static final TransparentHugepageDefrag[] VALUES = values();

    public static TransparentHugepageDefrag valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private TransparentHugepageDefrag(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag)
  }

  public interface HugepagesConfigOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Optional. Amount of 2M hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the hugepageSize2m field is set.
     */
    boolean hasHugepageSize2M();

    /**
     *
     *
     * <pre>
     * Optional. Amount of 2M hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The hugepageSize2m.
     */
    int getHugepageSize2M();

    /**
     *
     *
     * <pre>
     * Optional. Amount of 1G hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the hugepageSize1g field is set.
     */
    boolean hasHugepageSize1G();

    /**
     *
     *
     * <pre>
     * Optional. Amount of 1G hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The hugepageSize1g.
     */
    int getHugepageSize1G();
  }

  /**
   *
   *
   * <pre>
   * Hugepages amount in both 2m and 1g size
   * </pre>
   *
   * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.HugepagesConfig}
   */
  public static final class HugepagesConfig extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)
      HugepagesConfigOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use HugepagesConfig.newBuilder() to construct.
    private HugepagesConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private HugepagesConfig() {}

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
      return new HugepagesConfig();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_HugepagesConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_HugepagesConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.class,
              com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder.class);
    }

    private int bitField0_;
    public static final int HUGEPAGE_SIZE2M_FIELD_NUMBER = 1;
    private int hugepageSize2M_ = 0;

    /**
     *
     *
     * <pre>
     * Optional. Amount of 2M hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the hugepageSize2m field is set.
     */
    @java.lang.Override
    public boolean hasHugepageSize2M() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Amount of 2M hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The hugepageSize2m.
     */
    @java.lang.Override
    public int getHugepageSize2M() {
      return hugepageSize2M_;
    }

    public static final int HUGEPAGE_SIZE1G_FIELD_NUMBER = 2;
    private int hugepageSize1G_ = 0;

    /**
     *
     *
     * <pre>
     * Optional. Amount of 1G hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the hugepageSize1g field is set.
     */
    @java.lang.Override
    public boolean hasHugepageSize1G() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Amount of 1G hugepages
     * </pre>
     *
     * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The hugepageSize1g.
     */
    @java.lang.Override
    public int getHugepageSize1G() {
      return hugepageSize1G_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, hugepageSize2M_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, hugepageSize1G_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, hugepageSize2M_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, hugepageSize1G_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)) {
        return super.equals(obj);
      }
      com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig other =
          (com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig) obj;

      if (hasHugepageSize2M() != other.hasHugepageSize2M()) return false;
      if (hasHugepageSize2M()) {
        if (getHugepageSize2M() != other.getHugepageSize2M()) return false;
      }
      if (hasHugepageSize1G() != other.hasHugepageSize1G()) return false;
      if (hasHugepageSize1G()) {
        if (getHugepageSize1G() != other.getHugepageSize1G()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHugepageSize2M()) {
        hash = (37 * hash) + HUGEPAGE_SIZE2M_FIELD_NUMBER;
        hash = (53 * hash) + getHugepageSize2M();
      }
      if (hasHugepageSize1G()) {
        hash = (37 * hash) + HUGEPAGE_SIZE1G_FIELD_NUMBER;
        hash = (53 * hash) + getHugepageSize1G();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Hugepages amount in both 2m and 1g size
     * </pre>
     *
     * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.HugepagesConfig}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_HugepagesConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_HugepagesConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.class,
                com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder.class);
      }

      // Construct using com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.newBuilder()
      private Builder() {}

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        hugepageSize2M_ = 0;
        hugepageSize1G_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_HugepagesConfig_descriptor;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig
          getDefaultInstanceForType() {
        return com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig build() {
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig buildPartial() {
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig result =
            new com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(
          com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.hugepageSize2M_ = hugepageSize2M_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.hugepageSize1G_ = hugepageSize1G_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig) {
          return mergeFrom((com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig other) {
        if (other
            == com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance())
          return this;
        if (other.hasHugepageSize2M()) {
          setHugepageSize2M(other.getHugepageSize2M());
        }
        if (other.hasHugepageSize1G()) {
          setHugepageSize1G(other.getHugepageSize1G());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  hugepageSize2M_ = input.readInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              case 16:
                {
                  hugepageSize1G_ = input.readInt32();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private int hugepageSize2M_;

      /**
       *
       *
       * <pre>
       * Optional. Amount of 2M hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return Whether the hugepageSize2m field is set.
       */
      @java.lang.Override
      public boolean hasHugepageSize2M() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 2M hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return The hugepageSize2m.
       */
      @java.lang.Override
      public int getHugepageSize2M() {
        return hugepageSize2M_;
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 2M hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @param value The hugepageSize2m to set.
       * @return This builder for chaining.
       */
      public Builder setHugepageSize2M(int value) {

        hugepageSize2M_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 2M hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size2m = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHugepageSize2M() {
        bitField0_ = (bitField0_ & ~0x00000001);
        hugepageSize2M_ = 0;
        onChanged();
        return this;
      }

      private int hugepageSize1G_;

      /**
       *
       *
       * <pre>
       * Optional. Amount of 1G hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return Whether the hugepageSize1g field is set.
       */
      @java.lang.Override
      public boolean hasHugepageSize1G() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 1G hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return The hugepageSize1g.
       */
      @java.lang.Override
      public int getHugepageSize1G() {
        return hugepageSize1G_;
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 1G hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @param value The hugepageSize1g to set.
       * @return This builder for chaining.
       */
      public Builder setHugepageSize1G(int value) {

        hugepageSize1G_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. Amount of 1G hugepages
       * </pre>
       *
       * <code>optional int32 hugepage_size1g = 2 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHugepageSize1G() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hugepageSize1G_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)
    }

    // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.HugepagesConfig)
    private static final com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig();
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HugepagesConfig> PARSER =
        new com.google.protobuf.AbstractParser<HugepagesConfig>() {
          @java.lang.Override
          public HugepagesConfig parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<HugepagesConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HugepagesConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface SwapConfigOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.SwapConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Optional. Enables or disables swap for the node pool.
     * </pre>
     *
     * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the enabled field is set.
     */
    boolean hasEnabled();

    /**
     *
     *
     * <pre>
     * Optional. Enables or disables swap for the node pool.
     * </pre>
     *
     * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The enabled.
     */
    boolean getEnabled();

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return Whether the encryptionConfig field is set.
     */
    boolean hasEncryptionConfig();

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The encryptionConfig.
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig getEncryptionConfig();

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder
        getEncryptionConfigOrBuilder();

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     *
     * @return Whether the bootDiskProfile field is set.
     */
    boolean hasBootDiskProfile();

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     *
     * @return The bootDiskProfile.
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile getBootDiskProfile();

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder
        getBootDiskProfileOrBuilder();

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     *
     * @return Whether the ephemeralLocalSsdProfile field is set.
     */
    boolean hasEphemeralLocalSsdProfile();

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     *
     * @return The ephemeralLocalSsdProfile.
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
        getEphemeralLocalSsdProfile();

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfileOrBuilder
        getEphemeralLocalSsdProfileOrBuilder();

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     *
     * @return Whether the dedicatedLocalSsdProfile field is set.
     */
    boolean hasDedicatedLocalSsdProfile();

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     *
     * @return The dedicatedLocalSsdProfile.
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
        getDedicatedLocalSsdProfile();

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     */
    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfileOrBuilder
        getDedicatedLocalSsdProfileOrBuilder();

    com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.PerformanceProfileCase
        getPerformanceProfileCase();
  }

  /**
   *
   *
   * <pre>
   * Configuration for swap memory on a node pool.
   * </pre>
   *
   * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig}
   */
  public static final class SwapConfig extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig)
      SwapConfigOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use SwapConfig.newBuilder() to construct.
    private SwapConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private SwapConfig() {}

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
      return new SwapConfig();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.class,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder.class);
    }

    public interface EncryptionConfigOrBuilder
        extends
        // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       *
       *
       * <pre>
       * Optional. If true, swap space will not be encrypted.
       * Defaults to false (encrypted).
       * </pre>
       *
       * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return Whether the disabled field is set.
       */
      boolean hasDisabled();

      /**
       *
       *
       * <pre>
       * Optional. If true, swap space will not be encrypted.
       * Defaults to false (encrypted).
       * </pre>
       *
       * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return The disabled.
       */
      boolean getDisabled();
    }

    /**
     *
     *
     * <pre>
     * Defines encryption settings for the swap space.
     * </pre>
     *
     * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig}
     */
    public static final class EncryptionConfig extends com.google.protobuf.GeneratedMessageV3
        implements
        // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)
        EncryptionConfigOrBuilder {
      private static final long serialVersionUID = 0L;

      // Use EncryptionConfig.newBuilder() to construct.
      private EncryptionConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }

      private EncryptionConfig() {}

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
        return new EncryptionConfig();
      }

      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EncryptionConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EncryptionConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.class,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder
                    .class);
      }

      private int bitField0_;
      public static final int DISABLED_FIELD_NUMBER = 1;
      private boolean disabled_ = false;

      /**
       *
       *
       * <pre>
       * Optional. If true, swap space will not be encrypted.
       * Defaults to false (encrypted).
       * </pre>
       *
       * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return Whether the disabled field is set.
       */
      @java.lang.Override
      public boolean hasDisabled() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional. If true, swap space will not be encrypted.
       * Defaults to false (encrypted).
       * </pre>
       *
       * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return The disabled.
       */
      @java.lang.Override
      public boolean getDisabled() {
        return disabled_;
      }

      private byte memoizedIsInitialized = -1;

      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeBool(1, disabled_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, disabled_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
          return true;
        }
        if (!(obj
            instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)) {
          return super.equals(obj);
        }
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig other =
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig) obj;

        if (hasDisabled() != other.hasDisabled()) return false;
        if (hasDisabled()) {
          if (getDisabled() != other.getDisabled()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasDisabled()) {
          hash = (37 * hash) + DISABLED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getDisabled());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(java.nio.ByteBuffer data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(
              java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() {
        return newBuilder();
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }

      public static Builder newBuilder(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }

      /**
       *
       *
       * <pre>
       * Defines encryption settings for the swap space.
       * </pre>
       *
       * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig}
       */
      public static final class Builder
          extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
          implements
          // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EncryptionConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EncryptionConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.class,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder
                      .class);
        }

        // Construct using
        // com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.newBuilder()
        private Builder() {}

        private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
        }

        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          disabled_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EncryptionConfig_descriptor;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
            getDefaultInstanceForType() {
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
              .getDefaultInstance();
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig build() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig result =
              buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
            buildPartial() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig result =
              new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig(this);
          if (bitField0_ != 0) {
            buildPartial0(result);
          }
          onBuilt();
          return result;
        }

        private void buildPartial0(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.disabled_ = disabled_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }

        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.setField(field, value);
        }

        @java.lang.Override
        public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }

        @java.lang.Override
        public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }

        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index,
            java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }

        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other
              instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig) {
            return mergeFrom(
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig) other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig other) {
          if (other
              == com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
                  .getDefaultInstance()) return this;
          if (other.hasDisabled()) {
            setDisabled(other.getDisabled());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8:
                  {
                    disabled_ = input.readBool();
                    bitField0_ |= 0x00000001;
                    break;
                  } // case 8
                default:
                  {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }

        private int bitField0_;

        private boolean disabled_;

        /**
         *
         *
         * <pre>
         * Optional. If true, swap space will not be encrypted.
         * Defaults to false (encrypted).
         * </pre>
         *
         * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
         *
         * @return Whether the disabled field is set.
         */
        @java.lang.Override
        public boolean hasDisabled() {
          return ((bitField0_ & 0x00000001) != 0);
        }

        /**
         *
         *
         * <pre>
         * Optional. If true, swap space will not be encrypted.
         * Defaults to false (encrypted).
         * </pre>
         *
         * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
         *
         * @return The disabled.
         */
        @java.lang.Override
        public boolean getDisabled() {
          return disabled_;
        }

        /**
         *
         *
         * <pre>
         * Optional. If true, swap space will not be encrypted.
         * Defaults to false (encrypted).
         * </pre>
         *
         * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
         *
         * @param value The disabled to set.
         * @return This builder for chaining.
         */
        public Builder setDisabled(boolean value) {

          disabled_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * Optional. If true, swap space will not be encrypted.
         * Defaults to false (encrypted).
         * </pre>
         *
         * <code>optional bool disabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearDisabled() {
          bitField0_ = (bitField0_ & ~0x00000001);
          disabled_ = false;
          onChanged();
          return this;
        }

        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }

        // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)
      }

      // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig)
      private static final com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          DEFAULT_INSTANCE;

      static {
        DEFAULT_INSTANCE =
            new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig();
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<EncryptionConfig> PARSER =
          new com.google.protobuf.AbstractParser<EncryptionConfig>() {
            @java.lang.Override
            public EncryptionConfig parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
              Builder builder = newBuilder();
              try {
                builder.mergeFrom(input, extensionRegistry);
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
              } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException()
                    .setUnfinishedMessage(builder.buildPartial());
              } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                    .setUnfinishedMessage(builder.buildPartial());
              }
              return builder.buildPartial();
            }
          };

      public static com.google.protobuf.Parser<EncryptionConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<EncryptionConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }
    }

    public interface BootDiskProfileOrBuilder
        extends
        // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
        com.google.protobuf.MessageOrBuilder {

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return Whether the swapSizeGib field is set.
       */
      boolean hasSwapSizeGib();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return The swapSizeGib.
       */
      long getSwapSizeGib();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the boot disk
       * size.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return Whether the swapSizePercent field is set.
       */
      boolean hasSwapSizePercent();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the boot disk
       * size.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return The swapSizePercent.
       */
      int getSwapSizePercent();

      com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.SwapSizeCase
          getSwapSizeCase();
    }

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile}
     */
    public static final class BootDiskProfile extends com.google.protobuf.GeneratedMessageV3
        implements
        // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
        BootDiskProfileOrBuilder {
      private static final long serialVersionUID = 0L;

      // Use BootDiskProfile.newBuilder() to construct.
      private BootDiskProfile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }

      private BootDiskProfile() {}

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
        return new BootDiskProfile();
      }

      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_BootDiskProfile_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_BootDiskProfile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.class,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder
                    .class);
      }

      private int swapSizeCase_ = 0;

      @SuppressWarnings("serial")
      private java.lang.Object swapSize_;

      public enum SwapSizeCase
          implements
              com.google.protobuf.Internal.EnumLite,
              com.google.protobuf.AbstractMessage.InternalOneOfEnum {
        SWAP_SIZE_GIB(1),
        SWAP_SIZE_PERCENT(2),
        SWAPSIZE_NOT_SET(0);
        private final int value;

        private SwapSizeCase(int value) {
          this.value = value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static SwapSizeCase valueOf(int value) {
          return forNumber(value);
        }

        public static SwapSizeCase forNumber(int value) {
          switch (value) {
            case 1:
              return SWAP_SIZE_GIB;
            case 2:
              return SWAP_SIZE_PERCENT;
            case 0:
              return SWAPSIZE_NOT_SET;
            default:
              return null;
          }
        }

        public int getNumber() {
          return this.value;
        }
      };

      public SwapSizeCase getSwapSizeCase() {
        return SwapSizeCase.forNumber(swapSizeCase_);
      }

      public static final int SWAP_SIZE_GIB_FIELD_NUMBER = 1;

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return Whether the swapSizeGib field is set.
       */
      @java.lang.Override
      public boolean hasSwapSizeGib() {
        return swapSizeCase_ == 1;
      }

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return The swapSizeGib.
       */
      @java.lang.Override
      public long getSwapSizeGib() {
        if (swapSizeCase_ == 1) {
          return (java.lang.Long) swapSize_;
        }
        return 0L;
      }

      public static final int SWAP_SIZE_PERCENT_FIELD_NUMBER = 2;

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the boot disk
       * size.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return Whether the swapSizePercent field is set.
       */
      @java.lang.Override
      public boolean hasSwapSizePercent() {
        return swapSizeCase_ == 2;
      }

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the boot disk
       * size.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return The swapSizePercent.
       */
      @java.lang.Override
      public int getSwapSizePercent() {
        if (swapSizeCase_ == 2) {
          return (java.lang.Integer) swapSize_;
        }
        return 0;
      }

      private byte memoizedIsInitialized = -1;

      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
        if (swapSizeCase_ == 1) {
          output.writeInt64(1, (long) ((java.lang.Long) swapSize_));
        }
        if (swapSizeCase_ == 2) {
          output.writeInt32(2, (int) ((java.lang.Integer) swapSize_));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (swapSizeCase_ == 1) {
          size +=
              com.google.protobuf.CodedOutputStream.computeInt64Size(
                  1, (long) ((java.lang.Long) swapSize_));
        }
        if (swapSizeCase_ == 2) {
          size +=
              com.google.protobuf.CodedOutputStream.computeInt32Size(
                  2, (int) ((java.lang.Integer) swapSize_));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
          return true;
        }
        if (!(obj
            instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)) {
          return super.equals(obj);
        }
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile other =
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile) obj;

        if (!getSwapSizeCase().equals(other.getSwapSizeCase())) return false;
        switch (swapSizeCase_) {
          case 1:
            if (getSwapSizeGib() != other.getSwapSizeGib()) return false;
            break;
          case 2:
            if (getSwapSizePercent() != other.getSwapSizePercent()) return false;
            break;
          case 0:
          default:
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        switch (swapSizeCase_) {
          case 1:
            hash = (37 * hash) + SWAP_SIZE_GIB_FIELD_NUMBER;
            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSwapSizeGib());
            break;
          case 2:
            hash = (37 * hash) + SWAP_SIZE_PERCENT_FIELD_NUMBER;
            hash = (53 * hash) + getSwapSizePercent();
            break;
          case 0:
          default:
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(java.nio.ByteBuffer data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(
              java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() {
        return newBuilder();
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }

      public static Builder newBuilder(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile}
       */
      public static final class Builder
          extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
          implements
          // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_BootDiskProfile_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_BootDiskProfile_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.class,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder
                      .class);
        }

        // Construct using
        // com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.newBuilder()
        private Builder() {}

        private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
        }

        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          swapSizeCase_ = 0;
          swapSize_ = null;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_BootDiskProfile_descriptor;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
            getDefaultInstanceForType() {
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
              .getDefaultInstance();
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile build() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile result =
              buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
            buildPartial() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile result =
              new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile(this);
          if (bitField0_ != 0) {
            buildPartial0(result);
          }
          buildPartialOneofs(result);
          onBuilt();
          return result;
        }

        private void buildPartial0(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile result) {
          int from_bitField0_ = bitField0_;
        }

        private void buildPartialOneofs(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile result) {
          result.swapSizeCase_ = swapSizeCase_;
          result.swapSize_ = this.swapSize_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }

        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.setField(field, value);
        }

        @java.lang.Override
        public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }

        @java.lang.Override
        public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }

        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index,
            java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }

        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other
              instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile) {
            return mergeFrom(
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile) other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile other) {
          if (other
              == com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
                  .getDefaultInstance()) return this;
          switch (other.getSwapSizeCase()) {
            case SWAP_SIZE_GIB:
              {
                setSwapSizeGib(other.getSwapSizeGib());
                break;
              }
            case SWAP_SIZE_PERCENT:
              {
                setSwapSizePercent(other.getSwapSizePercent());
                break;
              }
            case SWAPSIZE_NOT_SET:
              {
                break;
              }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8:
                  {
                    swapSize_ = input.readInt64();
                    swapSizeCase_ = 1;
                    break;
                  } // case 8
                case 16:
                  {
                    swapSize_ = input.readInt32();
                    swapSizeCase_ = 2;
                    break;
                  } // case 16
                default:
                  {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }

        private int swapSizeCase_ = 0;
        private java.lang.Object swapSize_;

        public SwapSizeCase getSwapSizeCase() {
          return SwapSizeCase.forNumber(swapSizeCase_);
        }

        public Builder clearSwapSize() {
          swapSizeCase_ = 0;
          swapSize_ = null;
          onChanged();
          return this;
        }

        private int bitField0_;

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return Whether the swapSizeGib field is set.
         */
        public boolean hasSwapSizeGib() {
          return swapSizeCase_ == 1;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return The swapSizeGib.
         */
        public long getSwapSizeGib() {
          if (swapSizeCase_ == 1) {
            return (java.lang.Long) swapSize_;
          }
          return 0L;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @param value The swapSizeGib to set.
         * @return This builder for chaining.
         */
        public Builder setSwapSizeGib(long value) {

          swapSizeCase_ = 1;
          swapSize_ = value;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearSwapSizeGib() {
          if (swapSizeCase_ == 1) {
            swapSizeCase_ = 0;
            swapSize_ = null;
            onChanged();
          }
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the boot disk
         * size.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return Whether the swapSizePercent field is set.
         */
        public boolean hasSwapSizePercent() {
          return swapSizeCase_ == 2;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the boot disk
         * size.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return The swapSizePercent.
         */
        public int getSwapSizePercent() {
          if (swapSizeCase_ == 2) {
            return (java.lang.Integer) swapSize_;
          }
          return 0;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the boot disk
         * size.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @param value The swapSizePercent to set.
         * @return This builder for chaining.
         */
        public Builder setSwapSizePercent(int value) {

          swapSizeCase_ = 2;
          swapSize_ = value;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the boot disk
         * size.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearSwapSizePercent() {
          if (swapSizeCase_ == 2) {
            swapSizeCase_ = 0;
            swapSize_ = null;
            onChanged();
          }
          return this;
        }

        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }

        // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
      }

      // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
      private static final com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          DEFAULT_INSTANCE;

      static {
        DEFAULT_INSTANCE =
            new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile();
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<BootDiskProfile> PARSER =
          new com.google.protobuf.AbstractParser<BootDiskProfile>() {
            @java.lang.Override
            public BootDiskProfile parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
              Builder builder = newBuilder();
              try {
                builder.mergeFrom(input, extensionRegistry);
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
              } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException()
                    .setUnfinishedMessage(builder.buildPartial());
              } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                    .setUnfinishedMessage(builder.buildPartial());
              }
              return builder.buildPartial();
            }
          };

      public static com.google.protobuf.Parser<BootDiskProfile> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<BootDiskProfile> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }
    }

    public interface EphemeralLocalSsdProfileOrBuilder
        extends
        // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
        com.google.protobuf.MessageOrBuilder {

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return Whether the swapSizeGib field is set.
       */
      boolean hasSwapSizeGib();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return The swapSizeGib.
       */
      long getSwapSizeGib();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the ephemeral
       * local SSD capacity.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return Whether the swapSizePercent field is set.
       */
      boolean hasSwapSizePercent();

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the ephemeral
       * local SSD capacity.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return The swapSizePercent.
       */
      int getSwapSizePercent();

      com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile.SwapSizeCase
          getSwapSizeCase();
    }

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * Protobuf type {@code
     * google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile}
     */
    public static final class EphemeralLocalSsdProfile
        extends com.google.protobuf.GeneratedMessageV3
        implements
        // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
        EphemeralLocalSsdProfileOrBuilder {
      private static final long serialVersionUID = 0L;

      // Use EphemeralLocalSsdProfile.newBuilder() to construct.
      private EphemeralLocalSsdProfile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }

      private EphemeralLocalSsdProfile() {}

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
        return new EphemeralLocalSsdProfile();
      }

      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EphemeralLocalSsdProfile_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EphemeralLocalSsdProfile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                    .class,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                    .Builder.class);
      }

      private int swapSizeCase_ = 0;

      @SuppressWarnings("serial")
      private java.lang.Object swapSize_;

      public enum SwapSizeCase
          implements
              com.google.protobuf.Internal.EnumLite,
              com.google.protobuf.AbstractMessage.InternalOneOfEnum {
        SWAP_SIZE_GIB(1),
        SWAP_SIZE_PERCENT(2),
        SWAPSIZE_NOT_SET(0);
        private final int value;

        private SwapSizeCase(int value) {
          this.value = value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static SwapSizeCase valueOf(int value) {
          return forNumber(value);
        }

        public static SwapSizeCase forNumber(int value) {
          switch (value) {
            case 1:
              return SWAP_SIZE_GIB;
            case 2:
              return SWAP_SIZE_PERCENT;
            case 0:
              return SWAPSIZE_NOT_SET;
            default:
              return null;
          }
        }

        public int getNumber() {
          return this.value;
        }
      };

      public SwapSizeCase getSwapSizeCase() {
        return SwapSizeCase.forNumber(swapSizeCase_);
      }

      public static final int SWAP_SIZE_GIB_FIELD_NUMBER = 1;

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return Whether the swapSizeGib field is set.
       */
      @java.lang.Override
      public boolean hasSwapSizeGib() {
        return swapSizeCase_ == 1;
      }

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space in gibibytes (GiB).
       * </pre>
       *
       * <code>int64 swap_size_gib = 1;</code>
       *
       * @return The swapSizeGib.
       */
      @java.lang.Override
      public long getSwapSizeGib() {
        if (swapSizeCase_ == 1) {
          return (java.lang.Long) swapSize_;
        }
        return 0L;
      }

      public static final int SWAP_SIZE_PERCENT_FIELD_NUMBER = 2;

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the ephemeral
       * local SSD capacity.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return Whether the swapSizePercent field is set.
       */
      @java.lang.Override
      public boolean hasSwapSizePercent() {
        return swapSizeCase_ == 2;
      }

      /**
       *
       *
       * <pre>
       * Specifies the size of the swap space as a percentage of the ephemeral
       * local SSD capacity.
       * </pre>
       *
       * <code>int32 swap_size_percent = 2;</code>
       *
       * @return The swapSizePercent.
       */
      @java.lang.Override
      public int getSwapSizePercent() {
        if (swapSizeCase_ == 2) {
          return (java.lang.Integer) swapSize_;
        }
        return 0;
      }

      private byte memoizedIsInitialized = -1;

      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
        if (swapSizeCase_ == 1) {
          output.writeInt64(1, (long) ((java.lang.Long) swapSize_));
        }
        if (swapSizeCase_ == 2) {
          output.writeInt32(2, (int) ((java.lang.Integer) swapSize_));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (swapSizeCase_ == 1) {
          size +=
              com.google.protobuf.CodedOutputStream.computeInt64Size(
                  1, (long) ((java.lang.Long) swapSize_));
        }
        if (swapSizeCase_ == 2) {
          size +=
              com.google.protobuf.CodedOutputStream.computeInt32Size(
                  2, (int) ((java.lang.Integer) swapSize_));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
          return true;
        }
        if (!(obj
            instanceof
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)) {
          return super.equals(obj);
        }
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile other =
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile) obj;

        if (!getSwapSizeCase().equals(other.getSwapSizeCase())) return false;
        switch (swapSizeCase_) {
          case 1:
            if (getSwapSizeGib() != other.getSwapSizeGib()) return false;
            break;
          case 2:
            if (getSwapSizePercent() != other.getSwapSizePercent()) return false;
            break;
          case 0:
          default:
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        switch (swapSizeCase_) {
          case 1:
            hash = (37 * hash) + SWAP_SIZE_GIB_FIELD_NUMBER;
            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSwapSizeGib());
            break;
          case 2:
            hash = (37 * hash) + SWAP_SIZE_PERCENT_FIELD_NUMBER;
            hash = (53 * hash) + getSwapSizePercent();
            break;
          case 0:
          default:
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(java.nio.ByteBuffer data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(
              java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() {
        return newBuilder();
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }

      public static Builder newBuilder(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * Protobuf type {@code
       * google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile}
       */
      public static final class Builder
          extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
          implements
          // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .EphemeralLocalSsdProfileOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EphemeralLocalSsdProfile_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EphemeralLocalSsdProfile_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                      .class,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                      .Builder.class);
        }

        // Construct using
        // com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile.newBuilder()
        private Builder() {}

        private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
        }

        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          swapSizeCase_ = 0;
          swapSize_ = null;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_EphemeralLocalSsdProfile_descriptor;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
            getDefaultInstanceForType() {
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              .getDefaultInstance();
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
            build() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile result =
              buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
            buildPartial() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile result =
              new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile(
                  this);
          if (bitField0_ != 0) {
            buildPartial0(result);
          }
          buildPartialOneofs(result);
          onBuilt();
          return result;
        }

        private void buildPartial0(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                result) {
          int from_bitField0_ = bitField0_;
        }

        private void buildPartialOneofs(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                result) {
          result.swapSizeCase_ = swapSizeCase_;
          result.swapSize_ = this.swapSize_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }

        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.setField(field, value);
        }

        @java.lang.Override
        public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }

        @java.lang.Override
        public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }

        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index,
            java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }

        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other
              instanceof
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile) {
            return mergeFrom(
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
                    other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                other) {
          if (other
              == com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                  .getDefaultInstance()) return this;
          switch (other.getSwapSizeCase()) {
            case SWAP_SIZE_GIB:
              {
                setSwapSizeGib(other.getSwapSizeGib());
                break;
              }
            case SWAP_SIZE_PERCENT:
              {
                setSwapSizePercent(other.getSwapSizePercent());
                break;
              }
            case SWAPSIZE_NOT_SET:
              {
                break;
              }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8:
                  {
                    swapSize_ = input.readInt64();
                    swapSizeCase_ = 1;
                    break;
                  } // case 8
                case 16:
                  {
                    swapSize_ = input.readInt32();
                    swapSizeCase_ = 2;
                    break;
                  } // case 16
                default:
                  {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }

        private int swapSizeCase_ = 0;
        private java.lang.Object swapSize_;

        public SwapSizeCase getSwapSizeCase() {
          return SwapSizeCase.forNumber(swapSizeCase_);
        }

        public Builder clearSwapSize() {
          swapSizeCase_ = 0;
          swapSize_ = null;
          onChanged();
          return this;
        }

        private int bitField0_;

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return Whether the swapSizeGib field is set.
         */
        public boolean hasSwapSizeGib() {
          return swapSizeCase_ == 1;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return The swapSizeGib.
         */
        public long getSwapSizeGib() {
          if (swapSizeCase_ == 1) {
            return (java.lang.Long) swapSize_;
          }
          return 0L;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @param value The swapSizeGib to set.
         * @return This builder for chaining.
         */
        public Builder setSwapSizeGib(long value) {

          swapSizeCase_ = 1;
          swapSize_ = value;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space in gibibytes (GiB).
         * </pre>
         *
         * <code>int64 swap_size_gib = 1;</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearSwapSizeGib() {
          if (swapSizeCase_ == 1) {
            swapSizeCase_ = 0;
            swapSize_ = null;
            onChanged();
          }
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the ephemeral
         * local SSD capacity.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return Whether the swapSizePercent field is set.
         */
        public boolean hasSwapSizePercent() {
          return swapSizeCase_ == 2;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the ephemeral
         * local SSD capacity.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return The swapSizePercent.
         */
        public int getSwapSizePercent() {
          if (swapSizeCase_ == 2) {
            return (java.lang.Integer) swapSize_;
          }
          return 0;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the ephemeral
         * local SSD capacity.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @param value The swapSizePercent to set.
         * @return This builder for chaining.
         */
        public Builder setSwapSizePercent(int value) {

          swapSizeCase_ = 2;
          swapSize_ = value;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * Specifies the size of the swap space as a percentage of the ephemeral
         * local SSD capacity.
         * </pre>
         *
         * <code>int32 swap_size_percent = 2;</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearSwapSizePercent() {
          if (swapSizeCase_ == 2) {
            swapSizeCase_ = 0;
            swapSize_ = null;
            onChanged();
          }
          return this;
        }

        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }

        // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
      }

      // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
      private static final com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .EphemeralLocalSsdProfile
          DEFAULT_INSTANCE;

      static {
        DEFAULT_INSTANCE =
            new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile();
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<EphemeralLocalSsdProfile> PARSER =
          new com.google.protobuf.AbstractParser<EphemeralLocalSsdProfile>() {
            @java.lang.Override
            public EphemeralLocalSsdProfile parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
              Builder builder = newBuilder();
              try {
                builder.mergeFrom(input, extensionRegistry);
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
              } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException()
                    .setUnfinishedMessage(builder.buildPartial());
              } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                    .setUnfinishedMessage(builder.buildPartial());
              }
              return builder.buildPartial();
            }
          };

      public static com.google.protobuf.Parser<EphemeralLocalSsdProfile> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<EphemeralLocalSsdProfile> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }
    }

    public interface DedicatedLocalSsdProfileOrBuilder
        extends
        // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
        com.google.protobuf.MessageOrBuilder {

      /**
       *
       *
       * <pre>
       * The number of physical local NVMe SSD disks to attach.
       * </pre>
       *
       * <code>int64 disk_count = 1;</code>
       *
       * @return The diskCount.
       */
      long getDiskCount();
    }

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * Protobuf type {@code
     * google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile}
     */
    public static final class DedicatedLocalSsdProfile
        extends com.google.protobuf.GeneratedMessageV3
        implements
        // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
        DedicatedLocalSsdProfileOrBuilder {
      private static final long serialVersionUID = 0L;

      // Use DedicatedLocalSsdProfile.newBuilder() to construct.
      private DedicatedLocalSsdProfile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }

      private DedicatedLocalSsdProfile() {}

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
        return new DedicatedLocalSsdProfile();
      }

      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_DedicatedLocalSsdProfile_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_DedicatedLocalSsdProfile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                    .class,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                    .Builder.class);
      }

      public static final int DISK_COUNT_FIELD_NUMBER = 1;
      private long diskCount_ = 0L;

      /**
       *
       *
       * <pre>
       * The number of physical local NVMe SSD disks to attach.
       * </pre>
       *
       * <code>int64 disk_count = 1;</code>
       *
       * @return The diskCount.
       */
      @java.lang.Override
      public long getDiskCount() {
        return diskCount_;
      }

      private byte memoizedIsInitialized = -1;

      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
        if (diskCount_ != 0L) {
          output.writeInt64(1, diskCount_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (diskCount_ != 0L) {
          size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, diskCount_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
          return true;
        }
        if (!(obj
            instanceof
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)) {
          return super.equals(obj);
        }
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile other =
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile) obj;

        if (getDiskCount() != other.getDiskCount()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + DISK_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getDiskCount());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(java.nio.ByteBuffer data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(
              java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
            PARSER, input, extensionRegistry);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
            PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() {
        return newBuilder();
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }

      public static Builder newBuilder(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * Protobuf type {@code
       * google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile}
       */
      public static final class Builder
          extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
          implements
          // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .DedicatedLocalSsdProfileOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_DedicatedLocalSsdProfile_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_DedicatedLocalSsdProfile_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                      .class,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                      .Builder.class);
        }

        // Construct using
        // com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile.newBuilder()
        private Builder() {}

        private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
        }

        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          diskCount_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
          return com.google.container.v1beta1.ClusterServiceProto
              .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_DedicatedLocalSsdProfile_descriptor;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
            getDefaultInstanceForType() {
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              .getDefaultInstance();
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
            build() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile result =
              buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
            buildPartial() {
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile result =
              new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile(
                  this);
          if (bitField0_ != 0) {
            buildPartial0(result);
          }
          onBuilt();
          return result;
        }

        private void buildPartial0(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.diskCount_ = diskCount_;
          }
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }

        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.setField(field, value);
        }

        @java.lang.Override
        public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }

        @java.lang.Override
        public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }

        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index,
            java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }

        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other
              instanceof
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile) {
            return mergeFrom(
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
                    other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                other) {
          if (other
              == com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                  .getDefaultInstance()) return this;
          if (other.getDiskCount() != 0L) {
            setDiskCount(other.getDiskCount());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8:
                  {
                    diskCount_ = input.readInt64();
                    bitField0_ |= 0x00000001;
                    break;
                  } // case 8
                default:
                  {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }

        private int bitField0_;

        private long diskCount_;

        /**
         *
         *
         * <pre>
         * The number of physical local NVMe SSD disks to attach.
         * </pre>
         *
         * <code>int64 disk_count = 1;</code>
         *
         * @return The diskCount.
         */
        @java.lang.Override
        public long getDiskCount() {
          return diskCount_;
        }

        /**
         *
         *
         * <pre>
         * The number of physical local NVMe SSD disks to attach.
         * </pre>
         *
         * <code>int64 disk_count = 1;</code>
         *
         * @param value The diskCount to set.
         * @return This builder for chaining.
         */
        public Builder setDiskCount(long value) {

          diskCount_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        /**
         *
         *
         * <pre>
         * The number of physical local NVMe SSD disks to attach.
         * </pre>
         *
         * <code>int64 disk_count = 1;</code>
         *
         * @return This builder for chaining.
         */
        public Builder clearDiskCount() {
          bitField0_ = (bitField0_ & ~0x00000001);
          diskCount_ = 0L;
          onChanged();
          return this;
        }

        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }

        // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
      }

      // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
      private static final com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .DedicatedLocalSsdProfile
          DEFAULT_INSTANCE;

      static {
        DEFAULT_INSTANCE =
            new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile();
      }

      public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<DedicatedLocalSsdProfile> PARSER =
          new com.google.protobuf.AbstractParser<DedicatedLocalSsdProfile>() {
            @java.lang.Override
            public DedicatedLocalSsdProfile parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
              Builder builder = newBuilder();
              try {
                builder.mergeFrom(input, extensionRegistry);
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
              } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException()
                    .setUnfinishedMessage(builder.buildPartial());
              } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                    .setUnfinishedMessage(builder.buildPartial());
              }
              return builder.buildPartial();
            }
          };

      public static com.google.protobuf.Parser<DedicatedLocalSsdProfile> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<DedicatedLocalSsdProfile> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }
    }

    private int bitField0_;
    private int performanceProfileCase_ = 0;

    @SuppressWarnings("serial")
    private java.lang.Object performanceProfile_;

    public enum PerformanceProfileCase
        implements
            com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      BOOT_DISK_PROFILE(3),
      EPHEMERAL_LOCAL_SSD_PROFILE(4),
      DEDICATED_LOCAL_SSD_PROFILE(5),
      PERFORMANCEPROFILE_NOT_SET(0);
      private final int value;

      private PerformanceProfileCase(int value) {
        this.value = value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PerformanceProfileCase valueOf(int value) {
        return forNumber(value);
      }

      public static PerformanceProfileCase forNumber(int value) {
        switch (value) {
          case 3:
            return BOOT_DISK_PROFILE;
          case 4:
            return EPHEMERAL_LOCAL_SSD_PROFILE;
          case 5:
            return DEDICATED_LOCAL_SSD_PROFILE;
          case 0:
            return PERFORMANCEPROFILE_NOT_SET;
          default:
            return null;
        }
      }

      public int getNumber() {
        return this.value;
      }
    };

    public PerformanceProfileCase getPerformanceProfileCase() {
      return PerformanceProfileCase.forNumber(performanceProfileCase_);
    }

    public static final int ENABLED_FIELD_NUMBER = 1;
    private boolean enabled_ = false;

    /**
     *
     *
     * <pre>
     * Optional. Enables or disables swap for the node pool.
     * </pre>
     *
     * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return Whether the enabled field is set.
     */
    @java.lang.Override
    public boolean hasEnabled() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables or disables swap for the node pool.
     * </pre>
     *
     * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
     *
     * @return The enabled.
     */
    @java.lang.Override
    public boolean getEnabled() {
      return enabled_;
    }

    public static final int ENCRYPTION_CONFIG_FIELD_NUMBER = 2;
    private com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
        encryptionConfig_;

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return Whether the encryptionConfig field is set.
     */
    @java.lang.Override
    public boolean hasEncryptionConfig() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The encryptionConfig.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
        getEncryptionConfig() {
      return encryptionConfig_ == null
          ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
              .getDefaultInstance()
          : encryptionConfig_;
    }

    /**
     *
     *
     * <pre>
     * Optional. If omitted, swap space is encrypted by default.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder
        getEncryptionConfigOrBuilder() {
      return encryptionConfig_ == null
          ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
              .getDefaultInstance()
          : encryptionConfig_;
    }

    public static final int BOOT_DISK_PROFILE_FIELD_NUMBER = 3;

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     *
     * @return Whether the bootDiskProfile field is set.
     */
    @java.lang.Override
    public boolean hasBootDiskProfile() {
      return performanceProfileCase_ == 3;
    }

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     *
     * @return The bootDiskProfile.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
        getBootDiskProfile() {
      if (performanceProfileCase_ == 3) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          .getDefaultInstance();
    }

    /**
     *
     *
     * <pre>
     * Swap on the node's boot disk.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
     * </code>
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder
        getBootDiskProfileOrBuilder() {
      if (performanceProfileCase_ == 3) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          .getDefaultInstance();
    }

    public static final int EPHEMERAL_LOCAL_SSD_PROFILE_FIELD_NUMBER = 4;

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     *
     * @return Whether the ephemeralLocalSsdProfile field is set.
     */
    @java.lang.Override
    public boolean hasEphemeralLocalSsdProfile() {
      return performanceProfileCase_ == 4;
    }

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     *
     * @return The ephemeralLocalSsdProfile.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
        getEphemeralLocalSsdProfile() {
      if (performanceProfileCase_ == 4) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          .getDefaultInstance();
    }

    /**
     *
     *
     * <pre>
     * Swap on the local SSD shared with pod ephemeral storage.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
     * </code>
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfileOrBuilder
        getEphemeralLocalSsdProfileOrBuilder() {
      if (performanceProfileCase_ == 4) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          .getDefaultInstance();
    }

    public static final int DEDICATED_LOCAL_SSD_PROFILE_FIELD_NUMBER = 5;

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     *
     * @return Whether the dedicatedLocalSsdProfile field is set.
     */
    @java.lang.Override
    public boolean hasDedicatedLocalSsdProfile() {
      return performanceProfileCase_ == 5;
    }

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     *
     * @return The dedicatedLocalSsdProfile.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
        getDedicatedLocalSsdProfile() {
      if (performanceProfileCase_ == 5) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          .getDefaultInstance();
    }

    /**
     *
     *
     * <pre>
     * Provisions a new, separate local NVMe SSD exclusively for swap.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
     * </code>
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfileOrBuilder
        getDedicatedLocalSsdProfileOrBuilder() {
      if (performanceProfileCase_ == 5) {
        return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
            performanceProfile_;
      }
      return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          .getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, enabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getEncryptionConfig());
      }
      if (performanceProfileCase_ == 3) {
        output.writeMessage(
            3,
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                performanceProfile_);
      }
      if (performanceProfileCase_ == 4) {
        output.writeMessage(
            4,
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
                performanceProfile_);
      }
      if (performanceProfileCase_ == 5) {
        output.writeMessage(
            5,
            (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
                performanceProfile_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, enabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getEncryptionConfig());
      }
      if (performanceProfileCase_ == 3) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                3,
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                    performanceProfile_);
      }
      if (performanceProfileCase_ == 4) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                4,
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
                    performanceProfile_);
      }
      if (performanceProfileCase_ == 5) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                5,
                (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
                    performanceProfile_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig)) {
        return super.equals(obj);
      }
      com.google.container.v1beta1.LinuxNodeConfig.SwapConfig other =
          (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig) obj;

      if (hasEnabled() != other.hasEnabled()) return false;
      if (hasEnabled()) {
        if (getEnabled() != other.getEnabled()) return false;
      }
      if (hasEncryptionConfig() != other.hasEncryptionConfig()) return false;
      if (hasEncryptionConfig()) {
        if (!getEncryptionConfig().equals(other.getEncryptionConfig())) return false;
      }
      if (!getPerformanceProfileCase().equals(other.getPerformanceProfileCase())) return false;
      switch (performanceProfileCase_) {
        case 3:
          if (!getBootDiskProfile().equals(other.getBootDiskProfile())) return false;
          break;
        case 4:
          if (!getEphemeralLocalSsdProfile().equals(other.getEphemeralLocalSsdProfile()))
            return false;
          break;
        case 5:
          if (!getDedicatedLocalSsdProfile().equals(other.getDedicatedLocalSsdProfile()))
            return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasEnabled()) {
        hash = (37 * hash) + ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getEnabled());
      }
      if (hasEncryptionConfig()) {
        hash = (37 * hash) + ENCRYPTION_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getEncryptionConfig().hashCode();
      }
      switch (performanceProfileCase_) {
        case 3:
          hash = (37 * hash) + BOOT_DISK_PROFILE_FIELD_NUMBER;
          hash = (53 * hash) + getBootDiskProfile().hashCode();
          break;
        case 4:
          hash = (37 * hash) + EPHEMERAL_LOCAL_SSD_PROFILE_FIELD_NUMBER;
          hash = (53 * hash) + getEphemeralLocalSsdProfile().hashCode();
          break;
        case 5:
          hash = (37 * hash) + DEDICATED_LOCAL_SSD_PROFILE_FIELD_NUMBER;
          hash = (53 * hash) + getDedicatedLocalSsdProfile().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseDelimitedFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Configuration for swap memory on a node pool.
     * </pre>
     *
     * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.SwapConfig}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.SwapConfig)
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.class,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder.class);
      }

      // Construct using com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getEncryptionConfigFieldBuilder();
        }
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        enabled_ = false;
        encryptionConfig_ = null;
        if (encryptionConfigBuilder_ != null) {
          encryptionConfigBuilder_.dispose();
          encryptionConfigBuilder_ = null;
        }
        if (bootDiskProfileBuilder_ != null) {
          bootDiskProfileBuilder_.clear();
        }
        if (ephemeralLocalSsdProfileBuilder_ != null) {
          ephemeralLocalSsdProfileBuilder_.clear();
        }
        if (dedicatedLocalSsdProfileBuilder_ != null) {
          dedicatedLocalSsdProfileBuilder_.clear();
        }
        performanceProfileCase_ = 0;
        performanceProfile_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_SwapConfig_descriptor;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig getDefaultInstanceForType() {
        return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance();
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig build() {
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig buildPartial() {
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig result =
            new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(com.google.container.v1beta1.LinuxNodeConfig.SwapConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.enabled_ = enabled_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.encryptionConfig_ =
              encryptionConfigBuilder_ == null
                  ? encryptionConfig_
                  : encryptionConfigBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartialOneofs(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig result) {
        result.performanceProfileCase_ = performanceProfileCase_;
        result.performanceProfile_ = this.performanceProfile_;
        if (performanceProfileCase_ == 3 && bootDiskProfileBuilder_ != null) {
          result.performanceProfile_ = bootDiskProfileBuilder_.build();
        }
        if (performanceProfileCase_ == 4 && ephemeralLocalSsdProfileBuilder_ != null) {
          result.performanceProfile_ = ephemeralLocalSsdProfileBuilder_.build();
        }
        if (performanceProfileCase_ == 5 && dedicatedLocalSsdProfileBuilder_ != null) {
          result.performanceProfile_ = dedicatedLocalSsdProfileBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.container.v1beta1.LinuxNodeConfig.SwapConfig) {
          return mergeFrom((com.google.container.v1beta1.LinuxNodeConfig.SwapConfig) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.google.container.v1beta1.LinuxNodeConfig.SwapConfig other) {
        if (other == com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance())
          return this;
        if (other.hasEnabled()) {
          setEnabled(other.getEnabled());
        }
        if (other.hasEncryptionConfig()) {
          mergeEncryptionConfig(other.getEncryptionConfig());
        }
        switch (other.getPerformanceProfileCase()) {
          case BOOT_DISK_PROFILE:
            {
              mergeBootDiskProfile(other.getBootDiskProfile());
              break;
            }
          case EPHEMERAL_LOCAL_SSD_PROFILE:
            {
              mergeEphemeralLocalSsdProfile(other.getEphemeralLocalSsdProfile());
              break;
            }
          case DEDICATED_LOCAL_SSD_PROFILE:
            {
              mergeDedicatedLocalSsdProfile(other.getDedicatedLocalSsdProfile());
              break;
            }
          case PERFORMANCEPROFILE_NOT_SET:
            {
              break;
            }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  enabled_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              case 18:
                {
                  input.readMessage(
                      getEncryptionConfigFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(
                      getBootDiskProfileFieldBuilder().getBuilder(), extensionRegistry);
                  performanceProfileCase_ = 3;
                  break;
                } // case 26
              case 34:
                {
                  input.readMessage(
                      getEphemeralLocalSsdProfileFieldBuilder().getBuilder(), extensionRegistry);
                  performanceProfileCase_ = 4;
                  break;
                } // case 34
              case 42:
                {
                  input.readMessage(
                      getDedicatedLocalSsdProfileFieldBuilder().getBuilder(), extensionRegistry);
                  performanceProfileCase_ = 5;
                  break;
                } // case 42
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int performanceProfileCase_ = 0;
      private java.lang.Object performanceProfile_;

      public PerformanceProfileCase getPerformanceProfileCase() {
        return PerformanceProfileCase.forNumber(performanceProfileCase_);
      }

      public Builder clearPerformanceProfile() {
        performanceProfileCase_ = 0;
        performanceProfile_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private boolean enabled_;

      /**
       *
       *
       * <pre>
       * Optional. Enables or disables swap for the node pool.
       * </pre>
       *
       * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return Whether the enabled field is set.
       */
      @java.lang.Override
      public boolean hasEnabled() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional. Enables or disables swap for the node pool.
       * </pre>
       *
       * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return The enabled.
       */
      @java.lang.Override
      public boolean getEnabled() {
        return enabled_;
      }

      /**
       *
       *
       * <pre>
       * Optional. Enables or disables swap for the node pool.
       * </pre>
       *
       * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @param value The enabled to set.
       * @return This builder for chaining.
       */
      public Builder setEnabled(boolean value) {

        enabled_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. Enables or disables swap for the node pool.
       * </pre>
       *
       * <code>optional bool enabled = 1 [(.google.api.field_behavior) = OPTIONAL];</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearEnabled() {
        bitField0_ = (bitField0_ & ~0x00000001);
        enabled_ = false;
        onChanged();
        return this;
      }

      private com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          encryptionConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder>
          encryptionConfigBuilder_;

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       *
       * @return Whether the encryptionConfig field is set.
       */
      public boolean hasEncryptionConfig() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       *
       * @return The encryptionConfig.
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
          getEncryptionConfig() {
        if (encryptionConfigBuilder_ == null) {
          return encryptionConfig_ == null
              ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
                  .getDefaultInstance()
              : encryptionConfig_;
        } else {
          return encryptionConfigBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public Builder setEncryptionConfig(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig value) {
        if (encryptionConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          encryptionConfig_ = value;
        } else {
          encryptionConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public Builder setEncryptionConfig(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder
              builderForValue) {
        if (encryptionConfigBuilder_ == null) {
          encryptionConfig_ = builderForValue.build();
        } else {
          encryptionConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public Builder mergeEncryptionConfig(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig value) {
        if (encryptionConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && encryptionConfig_ != null
              && encryptionConfig_
                  != com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
                      .getDefaultInstance()) {
            getEncryptionConfigBuilder().mergeFrom(value);
          } else {
            encryptionConfig_ = value;
          }
        } else {
          encryptionConfigBuilder_.mergeFrom(value);
        }
        if (encryptionConfig_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public Builder clearEncryptionConfig() {
        bitField0_ = (bitField0_ & ~0x00000002);
        encryptionConfig_ = null;
        if (encryptionConfigBuilder_ != null) {
          encryptionConfigBuilder_.dispose();
          encryptionConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder
          getEncryptionConfigBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getEncryptionConfigFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder
          getEncryptionConfigOrBuilder() {
        if (encryptionConfigBuilder_ != null) {
          return encryptionConfigBuilder_.getMessageOrBuilder();
        } else {
          return encryptionConfig_ == null
              ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig
                  .getDefaultInstance()
              : encryptionConfig_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional. If omitted, swap space is encrypted by default.
       * </pre>
       *
       * <code>
       * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig encryption_config = 2 [(.google.api.field_behavior) = OPTIONAL];
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfigOrBuilder>
          getEncryptionConfigFieldBuilder() {
        if (encryptionConfigBuilder_ == null) {
          encryptionConfigBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EncryptionConfig.Builder,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                      .EncryptionConfigOrBuilder>(
                  getEncryptionConfig(), getParentForChildren(), isClean());
          encryptionConfig_ = null;
        }
        return encryptionConfigBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder>
          bootDiskProfileBuilder_;

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       *
       * @return Whether the bootDiskProfile field is set.
       */
      @java.lang.Override
      public boolean hasBootDiskProfile() {
        return performanceProfileCase_ == 3;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       *
       * @return The bootDiskProfile.
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
          getBootDiskProfile() {
        if (bootDiskProfileBuilder_ == null) {
          if (performanceProfileCase_ == 3) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
              .getDefaultInstance();
        } else {
          if (performanceProfileCase_ == 3) {
            return bootDiskProfileBuilder_.getMessage();
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      public Builder setBootDiskProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile value) {
        if (bootDiskProfileBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          performanceProfile_ = value;
          onChanged();
        } else {
          bootDiskProfileBuilder_.setMessage(value);
        }
        performanceProfileCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      public Builder setBootDiskProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder
              builderForValue) {
        if (bootDiskProfileBuilder_ == null) {
          performanceProfile_ = builderForValue.build();
          onChanged();
        } else {
          bootDiskProfileBuilder_.setMessage(builderForValue.build());
        }
        performanceProfileCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      public Builder mergeBootDiskProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile value) {
        if (bootDiskProfileBuilder_ == null) {
          if (performanceProfileCase_ == 3
              && performanceProfile_
                  != com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
                      .getDefaultInstance()) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.newBuilder(
                        (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                            performanceProfile_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            performanceProfile_ = value;
          }
          onChanged();
        } else {
          if (performanceProfileCase_ == 3) {
            bootDiskProfileBuilder_.mergeFrom(value);
          } else {
            bootDiskProfileBuilder_.setMessage(value);
          }
        }
        performanceProfileCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      public Builder clearBootDiskProfile() {
        if (bootDiskProfileBuilder_ == null) {
          if (performanceProfileCase_ == 3) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
            onChanged();
          }
        } else {
          if (performanceProfileCase_ == 3) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
          }
          bootDiskProfileBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder
          getBootDiskProfileBuilder() {
        return getBootDiskProfileFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder
          getBootDiskProfileOrBuilder() {
        if ((performanceProfileCase_ == 3) && (bootDiskProfileBuilder_ != null)) {
          return bootDiskProfileBuilder_.getMessageOrBuilder();
        } else {
          if (performanceProfileCase_ == 3) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Swap on the node's boot disk.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile boot_disk_profile = 3;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder>
          getBootDiskProfileFieldBuilder() {
        if (bootDiskProfileBuilder_ == null) {
          if (!(performanceProfileCase_ == 3)) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile
                    .getDefaultInstance();
          }
          bootDiskProfileBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile.Builder,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfileOrBuilder>(
                  (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.BootDiskProfile)
                      performanceProfile_,
                  getParentForChildren(),
                  isClean());
          performanceProfile_ = null;
        }
        performanceProfileCase_ = 3;
        onChanged();
        return bootDiskProfileBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                  .Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                  .EphemeralLocalSsdProfileOrBuilder>
          ephemeralLocalSsdProfileBuilder_;

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       *
       * @return Whether the ephemeralLocalSsdProfile field is set.
       */
      @java.lang.Override
      public boolean hasEphemeralLocalSsdProfile() {
        return performanceProfileCase_ == 4;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       *
       * @return The ephemeralLocalSsdProfile.
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
          getEphemeralLocalSsdProfile() {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 4) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                    .EphemeralLocalSsdProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              .getDefaultInstance();
        } else {
          if (performanceProfileCase_ == 4) {
            return ephemeralLocalSsdProfileBuilder_.getMessage();
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      public Builder setEphemeralLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile value) {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          performanceProfile_ = value;
          onChanged();
        } else {
          ephemeralLocalSsdProfileBuilder_.setMessage(value);
        }
        performanceProfileCase_ = 4;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      public Builder setEphemeralLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile.Builder
              builderForValue) {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          performanceProfile_ = builderForValue.build();
          onChanged();
        } else {
          ephemeralLocalSsdProfileBuilder_.setMessage(builderForValue.build());
        }
        performanceProfileCase_ = 4;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      public Builder mergeEphemeralLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile value) {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 4
              && performanceProfile_
                  != com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                      .EphemeralLocalSsdProfile.getDefaultInstance()) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                    .newBuilder(
                        (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                                .EphemeralLocalSsdProfile)
                            performanceProfile_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            performanceProfile_ = value;
          }
          onChanged();
        } else {
          if (performanceProfileCase_ == 4) {
            ephemeralLocalSsdProfileBuilder_.mergeFrom(value);
          } else {
            ephemeralLocalSsdProfileBuilder_.setMessage(value);
          }
        }
        performanceProfileCase_ = 4;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      public Builder clearEphemeralLocalSsdProfile() {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 4) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
            onChanged();
          }
        } else {
          if (performanceProfileCase_ == 4) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
          }
          ephemeralLocalSsdProfileBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              .Builder
          getEphemeralLocalSsdProfileBuilder() {
        return getEphemeralLocalSsdProfileFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .EphemeralLocalSsdProfileOrBuilder
          getEphemeralLocalSsdProfileOrBuilder() {
        if ((performanceProfileCase_ == 4) && (ephemeralLocalSsdProfileBuilder_ != null)) {
          return ephemeralLocalSsdProfileBuilder_.getMessageOrBuilder();
        } else {
          if (performanceProfileCase_ == 4) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                    .EphemeralLocalSsdProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Swap on the local SSD shared with pod ephemeral storage.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile ephemeral_local_ssd_profile = 4;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                  .Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                  .EphemeralLocalSsdProfileOrBuilder>
          getEphemeralLocalSsdProfileFieldBuilder() {
        if (ephemeralLocalSsdProfileBuilder_ == null) {
          if (!(performanceProfileCase_ == 4)) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                    .getDefaultInstance();
          }
          ephemeralLocalSsdProfileBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile
                      .Builder,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                      .EphemeralLocalSsdProfileOrBuilder>(
                  (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.EphemeralLocalSsdProfile)
                      performanceProfile_,
                  getParentForChildren(),
                  isClean());
          performanceProfile_ = null;
        }
        performanceProfileCase_ = 4;
        onChanged();
        return ephemeralLocalSsdProfileBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                  .Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                  .DedicatedLocalSsdProfileOrBuilder>
          dedicatedLocalSsdProfileBuilder_;

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       *
       * @return Whether the dedicatedLocalSsdProfile field is set.
       */
      @java.lang.Override
      public boolean hasDedicatedLocalSsdProfile() {
        return performanceProfileCase_ == 5;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       *
       * @return The dedicatedLocalSsdProfile.
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
          getDedicatedLocalSsdProfile() {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 5) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                    .DedicatedLocalSsdProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              .getDefaultInstance();
        } else {
          if (performanceProfileCase_ == 5) {
            return dedicatedLocalSsdProfileBuilder_.getMessage();
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      public Builder setDedicatedLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile value) {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          performanceProfile_ = value;
          onChanged();
        } else {
          dedicatedLocalSsdProfileBuilder_.setMessage(value);
        }
        performanceProfileCase_ = 5;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      public Builder setDedicatedLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile.Builder
              builderForValue) {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          performanceProfile_ = builderForValue.build();
          onChanged();
        } else {
          dedicatedLocalSsdProfileBuilder_.setMessage(builderForValue.build());
        }
        performanceProfileCase_ = 5;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      public Builder mergeDedicatedLocalSsdProfile(
          com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile value) {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 5
              && performanceProfile_
                  != com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                      .DedicatedLocalSsdProfile.getDefaultInstance()) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                    .newBuilder(
                        (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                                .DedicatedLocalSsdProfile)
                            performanceProfile_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            performanceProfile_ = value;
          }
          onChanged();
        } else {
          if (performanceProfileCase_ == 5) {
            dedicatedLocalSsdProfileBuilder_.mergeFrom(value);
          } else {
            dedicatedLocalSsdProfileBuilder_.setMessage(value);
          }
        }
        performanceProfileCase_ = 5;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      public Builder clearDedicatedLocalSsdProfile() {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          if (performanceProfileCase_ == 5) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
            onChanged();
          }
        } else {
          if (performanceProfileCase_ == 5) {
            performanceProfileCase_ = 0;
            performanceProfile_ = null;
          }
          dedicatedLocalSsdProfileBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              .Builder
          getDedicatedLocalSsdProfileBuilder() {
        return getDedicatedLocalSsdProfileFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
              .DedicatedLocalSsdProfileOrBuilder
          getDedicatedLocalSsdProfileOrBuilder() {
        if ((performanceProfileCase_ == 5) && (dedicatedLocalSsdProfileBuilder_ != null)) {
          return dedicatedLocalSsdProfileBuilder_.getMessageOrBuilder();
        } else {
          if (performanceProfileCase_ == 5) {
            return (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                    .DedicatedLocalSsdProfile)
                performanceProfile_;
          }
          return com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
              .getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Provisions a new, separate local NVMe SSD exclusively for swap.
       * </pre>
       *
       * <code>
       * .google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile dedicated_local_ssd_profile = 5;
       * </code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                  .Builder,
              com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                  .DedicatedLocalSsdProfileOrBuilder>
          getDedicatedLocalSsdProfileFieldBuilder() {
        if (dedicatedLocalSsdProfileBuilder_ == null) {
          if (!(performanceProfileCase_ == 5)) {
            performanceProfile_ =
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                    .getDefaultInstance();
          }
          dedicatedLocalSsdProfileBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile
                      .Builder,
                  com.google.container.v1beta1.LinuxNodeConfig.SwapConfig
                      .DedicatedLocalSsdProfileOrBuilder>(
                  (com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.DedicatedLocalSsdProfile)
                      performanceProfile_,
                  getParentForChildren(),
                  isClean());
          performanceProfile_ = null;
        }
        performanceProfileCase_ = 5;
        onChanged();
        return dedicatedLocalSsdProfileBuilder_;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig)
    }

    // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.SwapConfig)
    private static final com.google.container.v1beta1.LinuxNodeConfig.SwapConfig DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new com.google.container.v1beta1.LinuxNodeConfig.SwapConfig();
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.SwapConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SwapConfig> PARSER =
        new com.google.protobuf.AbstractParser<SwapConfig>() {
          @java.lang.Override
          public SwapConfig parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<SwapConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SwapConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface NodeKernelModuleLoadingOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Set the node module loading policy for nodes in the node pool.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
     * </code>
     *
     * @return The enum numeric value on the wire for policy.
     */
    int getPolicyValue();

    /**
     *
     *
     * <pre>
     * Set the node module loading policy for nodes in the node pool.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
     * </code>
     *
     * @return The policy.
     */
    com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy getPolicy();
  }

  /**
   *
   *
   * <pre>
   * Configuration for kernel module loading on nodes.
   * </pre>
   *
   * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading}
   */
  public static final class NodeKernelModuleLoading extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)
      NodeKernelModuleLoadingOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use NodeKernelModuleLoading.newBuilder() to construct.
    private NodeKernelModuleLoading(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private NodeKernelModuleLoading() {
      policy_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
      return new NodeKernelModuleLoading();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_NodeKernelModuleLoading_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_NodeKernelModuleLoading_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.class,
              com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder.class);
    }

    /**
     *
     *
     * <pre>
     * Defines the kernel module loading policy for nodes in the nodepool.
     * </pre>
     *
     * Protobuf enum {@code google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy}
     */
    public enum Policy implements com.google.protobuf.ProtocolMessageEnum {
      /**
       *
       *
       * <pre>
       * Default behavior. GKE selects the image based on node type.
       * For CPU and TPU nodes, the image will not allow loading external
       * kernel modules.
       * For GPU nodes, the image will allow loading any module, whether it
       * is signed or not.
       * </pre>
       *
       * <code>POLICY_UNSPECIFIED = 0;</code>
       */
      POLICY_UNSPECIFIED(0),
      /**
       *
       *
       * <pre>
       * Enforced signature verification: Node pools will use a
       * Container-Optimized OS image configured to allow loading of
       * *Google-signed* external kernel modules.
       * Loadpin is enabled but configured to exclude modules, and kernel
       * module signature checking is enforced.
       * </pre>
       *
       * <code>ENFORCE_SIGNED_MODULES = 1;</code>
       */
      ENFORCE_SIGNED_MODULES(1),
      /**
       *
       *
       * <pre>
       * Mirrors existing DEFAULT behavior:
       * For CPU and TPU nodes, the image will not allow loading external
       * kernel modules.
       * For GPU nodes, the image will allow loading any module, whether it
       * is signed or not.
       * </pre>
       *
       * <code>DO_NOT_ENFORCE_SIGNED_MODULES = 2;</code>
       */
      DO_NOT_ENFORCE_SIGNED_MODULES(2),
      UNRECOGNIZED(-1),
      ;

      /**
       *
       *
       * <pre>
       * Default behavior. GKE selects the image based on node type.
       * For CPU and TPU nodes, the image will not allow loading external
       * kernel modules.
       * For GPU nodes, the image will allow loading any module, whether it
       * is signed or not.
       * </pre>
       *
       * <code>POLICY_UNSPECIFIED = 0;</code>
       */
      public static final int POLICY_UNSPECIFIED_VALUE = 0;

      /**
       *
       *
       * <pre>
       * Enforced signature verification: Node pools will use a
       * Container-Optimized OS image configured to allow loading of
       * *Google-signed* external kernel modules.
       * Loadpin is enabled but configured to exclude modules, and kernel
       * module signature checking is enforced.
       * </pre>
       *
       * <code>ENFORCE_SIGNED_MODULES = 1;</code>
       */
      public static final int ENFORCE_SIGNED_MODULES_VALUE = 1;

      /**
       *
       *
       * <pre>
       * Mirrors existing DEFAULT behavior:
       * For CPU and TPU nodes, the image will not allow loading external
       * kernel modules.
       * For GPU nodes, the image will allow loading any module, whether it
       * is signed or not.
       * </pre>
       *
       * <code>DO_NOT_ENFORCE_SIGNED_MODULES = 2;</code>
       */
      public static final int DO_NOT_ENFORCE_SIGNED_MODULES_VALUE = 2;

      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Policy valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Policy forNumber(int value) {
        switch (value) {
          case 0:
            return POLICY_UNSPECIFIED;
          case 1:
            return ENFORCE_SIGNED_MODULES;
          case 2:
            return DO_NOT_ENFORCE_SIGNED_MODULES;
          default:
            return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Policy> internalGetValueMap() {
        return internalValueMap;
      }

      private static final com.google.protobuf.Internal.EnumLiteMap<Policy> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Policy>() {
            public Policy findValueByNumber(int number) {
              return Policy.forNumber(number);
            }
          };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }

      public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
        return getDescriptor();
      }

      public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
        return com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.getDescriptor()
            .getEnumTypes()
            .get(0);
      }

      private static final Policy[] VALUES = values();

      public static Policy valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Policy(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy)
    }

    public static final int POLICY_FIELD_NUMBER = 1;
    private int policy_ = 0;

    /**
     *
     *
     * <pre>
     * Set the node module loading policy for nodes in the node pool.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
     * </code>
     *
     * @return The enum numeric value on the wire for policy.
     */
    @java.lang.Override
    public int getPolicyValue() {
      return policy_;
    }

    /**
     *
     *
     * <pre>
     * Set the node module loading policy for nodes in the node pool.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
     * </code>
     *
     * @return The policy.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy getPolicy() {
      com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy result =
          com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy.forNumber(
              policy_);
      return result == null
          ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy.UNRECOGNIZED
          : result;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (policy_
          != com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy
              .POLICY_UNSPECIFIED
              .getNumber()) {
        output.writeEnum(1, policy_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (policy_
          != com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy
              .POLICY_UNSPECIFIED
              .getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, policy_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)) {
        return super.equals(obj);
      }
      com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading other =
          (com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading) obj;

      if (policy_ != other.policy_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + POLICY_FIELD_NUMBER;
      hash = (53 * hash) + policy_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        parseDelimitedFrom(
            java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Configuration for kernel module loading on nodes.
     * </pre>
     *
     * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_NodeKernelModuleLoading_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_NodeKernelModuleLoading_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.class,
                com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder.class);
      }

      // Construct using
      // com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.newBuilder()
      private Builder() {}

      private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
      }

      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        policy_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return com.google.container.v1beta1.ClusterServiceProto
            .internal_static_google_container_v1beta1_LinuxNodeConfig_NodeKernelModuleLoading_descriptor;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
          getDefaultInstanceForType() {
        return com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
            .getDefaultInstance();
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading build() {
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading result =
            buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading buildPartial() {
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading result =
            new com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(
          com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.policy_ = policy_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }

      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.setField(field, value);
      }

      @java.lang.Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @java.lang.Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index,
          java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading) {
          return mergeFrom(
              (com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(
          com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading other) {
        if (other
            == com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
                .getDefaultInstance()) return this;
        if (other.policy_ != 0) {
          setPolicyValue(other.getPolicyValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  policy_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private int policy_ = 0;

      /**
       *
       *
       * <pre>
       * Set the node module loading policy for nodes in the node pool.
       * </pre>
       *
       * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
       * </code>
       *
       * @return The enum numeric value on the wire for policy.
       */
      @java.lang.Override
      public int getPolicyValue() {
        return policy_;
      }

      /**
       *
       *
       * <pre>
       * Set the node module loading policy for nodes in the node pool.
       * </pre>
       *
       * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
       * </code>
       *
       * @param value The enum numeric value on the wire for policy to set.
       * @return This builder for chaining.
       */
      public Builder setPolicyValue(int value) {
        policy_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Set the node module loading policy for nodes in the node pool.
       * </pre>
       *
       * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
       * </code>
       *
       * @return The policy.
       */
      @java.lang.Override
      public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy
          getPolicy() {
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy result =
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy.forNumber(
                policy_);
        return result == null
            ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy
                .UNRECOGNIZED
            : result;
      }

      /**
       *
       *
       * <pre>
       * Set the node module loading policy for nodes in the node pool.
       * </pre>
       *
       * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
       * </code>
       *
       * @param value The policy to set.
       * @return This builder for chaining.
       */
      public Builder setPolicy(
          com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        policy_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Set the node module loading policy for nodes in the node pool.
       * </pre>
       *
       * <code>.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Policy policy = 1;
       * </code>
       *
       * @return This builder for chaining.
       */
      public Builder clearPolicy() {
        bitField0_ = (bitField0_ & ~0x00000001);
        policy_ = 0;
        onChanged();
        return this;
      }

      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)
    }

    // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading)
    private static final com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading();
    }

    public static com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeKernelModuleLoading> PARSER =
        new com.google.protobuf.AbstractParser<NodeKernelModuleLoading>() {
          @java.lang.Override
          public NodeKernelModuleLoading parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<NodeKernelModuleLoading> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeKernelModuleLoading> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  private int bitField0_;
  public static final int SYSCTLS_FIELD_NUMBER = 1;

  private static final class SysctlsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<java.lang.String, java.lang.String> defaultEntry =
        com.google.protobuf.MapEntry.<java.lang.String, java.lang.String>newDefaultInstance(
            com.google.container.v1beta1.ClusterServiceProto
                .internal_static_google_container_v1beta1_LinuxNodeConfig_SysctlsEntry_descriptor,
            com.google.protobuf.WireFormat.FieldType.STRING,
            "",
            com.google.protobuf.WireFormat.FieldType.STRING,
            "");
  }

  @SuppressWarnings("serial")
  private com.google.protobuf.MapField<java.lang.String, java.lang.String> sysctls_;

  private com.google.protobuf.MapField<java.lang.String, java.lang.String> internalGetSysctls() {
    if (sysctls_ == null) {
      return com.google.protobuf.MapField.emptyMapField(SysctlsDefaultEntryHolder.defaultEntry);
    }
    return sysctls_;
  }

  public int getSysctlsCount() {
    return internalGetSysctls().getMap().size();
  }

  /**
   *
   *
   * <pre>
   * The Linux kernel parameters to be applied to the nodes and all pods running
   * on the nodes.
   *
   * The following parameters are supported.
   *
   * net.core.busy_poll
   * net.core.busy_read
   * net.core.netdev_max_backlog
   * net.core.rmem_max
   * net.core.rmem_default
   * net.core.wmem_default
   * net.core.wmem_max
   * net.core.optmem_max
   * net.core.somaxconn
   * net.ipv4.tcp_rmem
   * net.ipv4.tcp_wmem
   * net.ipv4.tcp_tw_reuse
   * net.ipv4.tcp_max_orphans
   * net.netfilter.nf_conntrack_max
   * net.netfilter.nf_conntrack_buckets
   * net.netfilter.nf_conntrack_tcp_timeout_close_wait
   * net.netfilter.nf_conntrack_tcp_timeout_time_wait
   * net.netfilter.nf_conntrack_tcp_timeout_established
   * net.netfilter.nf_conntrack_acct
   * kernel.shmmni
   * kernel.shmmax
   * kernel.shmall
   * fs.aio-max-nr
   * fs.file-max
   * fs.inotify.max_user_instances
   * fs.inotify.max_user_watches
   * fs.nr_open
   * vm.dirty_background_ratio
   * vm.dirty_expire_centisecs
   * vm.dirty_ratio
   * vm.dirty_writeback_centisecs
   * vm.max_map_count
   * vm.overcommit_memory
   * vm.overcommit_ratio
   * vm.vfs_cache_pressure
   * vm.swappiness
   * vm.watermark_scale_factor
   * vm.min_free_kbytes
   * </pre>
   *
   * <code>map&lt;string, string&gt; sysctls = 1;</code>
   */
  @java.lang.Override
  public boolean containsSysctls(java.lang.String key) {
    if (key == null) {
      throw new NullPointerException("map key");
    }
    return internalGetSysctls().getMap().containsKey(key);
  }

  /** Use {@link #getSysctlsMap()} instead. */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getSysctls() {
    return getSysctlsMap();
  }

  /**
   *
   *
   * <pre>
   * The Linux kernel parameters to be applied to the nodes and all pods running
   * on the nodes.
   *
   * The following parameters are supported.
   *
   * net.core.busy_poll
   * net.core.busy_read
   * net.core.netdev_max_backlog
   * net.core.rmem_max
   * net.core.rmem_default
   * net.core.wmem_default
   * net.core.wmem_max
   * net.core.optmem_max
   * net.core.somaxconn
   * net.ipv4.tcp_rmem
   * net.ipv4.tcp_wmem
   * net.ipv4.tcp_tw_reuse
   * net.ipv4.tcp_max_orphans
   * net.netfilter.nf_conntrack_max
   * net.netfilter.nf_conntrack_buckets
   * net.netfilter.nf_conntrack_tcp_timeout_close_wait
   * net.netfilter.nf_conntrack_tcp_timeout_time_wait
   * net.netfilter.nf_conntrack_tcp_timeout_established
   * net.netfilter.nf_conntrack_acct
   * kernel.shmmni
   * kernel.shmmax
   * kernel.shmall
   * fs.aio-max-nr
   * fs.file-max
   * fs.inotify.max_user_instances
   * fs.inotify.max_user_watches
   * fs.nr_open
   * vm.dirty_background_ratio
   * vm.dirty_expire_centisecs
   * vm.dirty_ratio
   * vm.dirty_writeback_centisecs
   * vm.max_map_count
   * vm.overcommit_memory
   * vm.overcommit_ratio
   * vm.vfs_cache_pressure
   * vm.swappiness
   * vm.watermark_scale_factor
   * vm.min_free_kbytes
   * </pre>
   *
   * <code>map&lt;string, string&gt; sysctls = 1;</code>
   */
  @java.lang.Override
  public java.util.Map<java.lang.String, java.lang.String> getSysctlsMap() {
    return internalGetSysctls().getMap();
  }

  /**
   *
   *
   * <pre>
   * The Linux kernel parameters to be applied to the nodes and all pods running
   * on the nodes.
   *
   * The following parameters are supported.
   *
   * net.core.busy_poll
   * net.core.busy_read
   * net.core.netdev_max_backlog
   * net.core.rmem_max
   * net.core.rmem_default
   * net.core.wmem_default
   * net.core.wmem_max
   * net.core.optmem_max
   * net.core.somaxconn
   * net.ipv4.tcp_rmem
   * net.ipv4.tcp_wmem
   * net.ipv4.tcp_tw_reuse
   * net.ipv4.tcp_max_orphans
   * net.netfilter.nf_conntrack_max
   * net.netfilter.nf_conntrack_buckets
   * net.netfilter.nf_conntrack_tcp_timeout_close_wait
   * net.netfilter.nf_conntrack_tcp_timeout_time_wait
   * net.netfilter.nf_conntrack_tcp_timeout_established
   * net.netfilter.nf_conntrack_acct
   * kernel.shmmni
   * kernel.shmmax
   * kernel.shmall
   * fs.aio-max-nr
   * fs.file-max
   * fs.inotify.max_user_instances
   * fs.inotify.max_user_watches
   * fs.nr_open
   * vm.dirty_background_ratio
   * vm.dirty_expire_centisecs
   * vm.dirty_ratio
   * vm.dirty_writeback_centisecs
   * vm.max_map_count
   * vm.overcommit_memory
   * vm.overcommit_ratio
   * vm.vfs_cache_pressure
   * vm.swappiness
   * vm.watermark_scale_factor
   * vm.min_free_kbytes
   * </pre>
   *
   * <code>map&lt;string, string&gt; sysctls = 1;</code>
   */
  @java.lang.Override
  public /* nullable */ java.lang.String getSysctlsOrDefault(
      java.lang.String key,
      /* nullable */
      java.lang.String defaultValue) {
    if (key == null) {
      throw new NullPointerException("map key");
    }
    java.util.Map<java.lang.String, java.lang.String> map = internalGetSysctls().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }

  /**
   *
   *
   * <pre>
   * The Linux kernel parameters to be applied to the nodes and all pods running
   * on the nodes.
   *
   * The following parameters are supported.
   *
   * net.core.busy_poll
   * net.core.busy_read
   * net.core.netdev_max_backlog
   * net.core.rmem_max
   * net.core.rmem_default
   * net.core.wmem_default
   * net.core.wmem_max
   * net.core.optmem_max
   * net.core.somaxconn
   * net.ipv4.tcp_rmem
   * net.ipv4.tcp_wmem
   * net.ipv4.tcp_tw_reuse
   * net.ipv4.tcp_max_orphans
   * net.netfilter.nf_conntrack_max
   * net.netfilter.nf_conntrack_buckets
   * net.netfilter.nf_conntrack_tcp_timeout_close_wait
   * net.netfilter.nf_conntrack_tcp_timeout_time_wait
   * net.netfilter.nf_conntrack_tcp_timeout_established
   * net.netfilter.nf_conntrack_acct
   * kernel.shmmni
   * kernel.shmmax
   * kernel.shmall
   * fs.aio-max-nr
   * fs.file-max
   * fs.inotify.max_user_instances
   * fs.inotify.max_user_watches
   * fs.nr_open
   * vm.dirty_background_ratio
   * vm.dirty_expire_centisecs
   * vm.dirty_ratio
   * vm.dirty_writeback_centisecs
   * vm.max_map_count
   * vm.overcommit_memory
   * vm.overcommit_ratio
   * vm.vfs_cache_pressure
   * vm.swappiness
   * vm.watermark_scale_factor
   * vm.min_free_kbytes
   * </pre>
   *
   * <code>map&lt;string, string&gt; sysctls = 1;</code>
   */
  @java.lang.Override
  public java.lang.String getSysctlsOrThrow(java.lang.String key) {
    if (key == null) {
      throw new NullPointerException("map key");
    }
    java.util.Map<java.lang.String, java.lang.String> map = internalGetSysctls().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int CGROUP_MODE_FIELD_NUMBER = 2;
  private int cgroupMode_ = 0;

  /**
   *
   *
   * <pre>
   * cgroup_mode specifies the cgroup mode to be used on the node.
   * </pre>
   *
   * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
   *
   * @return The enum numeric value on the wire for cgroupMode.
   */
  @java.lang.Override
  public int getCgroupModeValue() {
    return cgroupMode_;
  }

  /**
   *
   *
   * <pre>
   * cgroup_mode specifies the cgroup mode to be used on the node.
   * </pre>
   *
   * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
   *
   * @return The cgroupMode.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.CgroupMode getCgroupMode() {
    com.google.container.v1beta1.LinuxNodeConfig.CgroupMode result =
        com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.forNumber(cgroupMode_);
    return result == null
        ? com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.UNRECOGNIZED
        : result;
  }

  public static final int HUGEPAGES_FIELD_NUMBER = 3;
  private com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages_;

  /**
   *
   *
   * <pre>
   * Optional. Amounts for 2M and 1G hugepages
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return Whether the hugepages field is set.
   */
  @java.lang.Override
  public boolean hasHugepages() {
    return ((bitField0_ & 0x00000001) != 0);
  }

  /**
   *
   *
   * <pre>
   * Optional. Amounts for 2M and 1G hugepages
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The hugepages.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig getHugepages() {
    return hugepages_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance()
        : hugepages_;
  }

  /**
   *
   *
   * <pre>
   * Optional. Amounts for 2M and 1G hugepages
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder
      getHugepagesOrBuilder() {
    return hugepages_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance()
        : hugepages_;
  }

  public static final int TRANSPARENT_HUGEPAGE_ENABLED_FIELD_NUMBER = 4;
  private int transparentHugepageEnabled_ = 0;

  /**
   *
   *
   * <pre>
   * Optional. Transparent hugepage support for anonymous memory can be entirely
   * disabled (mostly for debugging purposes) or only enabled inside
   * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
   * resources) or enabled system wide.
   *
   * See https://docs.kernel.org/admin-guide/mm/transhuge.html
   * for more details.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The enum numeric value on the wire for transparentHugepageEnabled.
   */
  @java.lang.Override
  public int getTransparentHugepageEnabledValue() {
    return transparentHugepageEnabled_;
  }

  /**
   *
   *
   * <pre>
   * Optional. Transparent hugepage support for anonymous memory can be entirely
   * disabled (mostly for debugging purposes) or only enabled inside
   * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
   * resources) or enabled system wide.
   *
   * See https://docs.kernel.org/admin-guide/mm/transhuge.html
   * for more details.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The transparentHugepageEnabled.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled
      getTransparentHugepageEnabled() {
    com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled result =
        com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled.forNumber(
            transparentHugepageEnabled_);
    return result == null
        ? com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled.UNRECOGNIZED
        : result;
  }

  public static final int TRANSPARENT_HUGEPAGE_DEFRAG_FIELD_NUMBER = 5;
  private int transparentHugepageDefrag_ = 0;

  /**
   *
   *
   * <pre>
   * Optional. Defines the transparent hugepage defrag configuration on the
   * node. VM hugepage allocation can be managed by either limiting
   * defragmentation for delayed allocation or skipping it entirely for
   * immediate allocation only.
   *
   * See https://docs.kernel.org/admin-guide/mm/transhuge.html
   * for more details.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The enum numeric value on the wire for transparentHugepageDefrag.
   */
  @java.lang.Override
  public int getTransparentHugepageDefragValue() {
    return transparentHugepageDefrag_;
  }

  /**
   *
   *
   * <pre>
   * Optional. Defines the transparent hugepage defrag configuration on the
   * node. VM hugepage allocation can be managed by either limiting
   * defragmentation for delayed allocation or skipping it entirely for
   * immediate allocation only.
   *
   * See https://docs.kernel.org/admin-guide/mm/transhuge.html
   * for more details.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The transparentHugepageDefrag.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag
      getTransparentHugepageDefrag() {
    com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag result =
        com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag.forNumber(
            transparentHugepageDefrag_);
    return result == null
        ? com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag.UNRECOGNIZED
        : result;
  }

  public static final int SWAP_CONFIG_FIELD_NUMBER = 12;
  private com.google.container.v1beta1.LinuxNodeConfig.SwapConfig swapConfig_;

  /**
   *
   *
   * <pre>
   * Optional. Enables and configures swap space on nodes.
   * If omitted, swap is disabled.
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return Whether the swapConfig field is set.
   */
  @java.lang.Override
  public boolean hasSwapConfig() {
    return ((bitField0_ & 0x00000002) != 0);
  }

  /**
   *
   *
   * <pre>
   * Optional. Enables and configures swap space on nodes.
   * If omitted, swap is disabled.
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The swapConfig.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig getSwapConfig() {
    return swapConfig_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance()
        : swapConfig_;
  }

  /**
   *
   *
   * <pre>
   * Optional. Enables and configures swap space on nodes.
   * If omitted, swap is disabled.
   * </pre>
   *
   * <code>
   * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder getSwapConfigOrBuilder() {
    return swapConfig_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance()
        : swapConfig_;
  }

  public static final int NODE_KERNEL_MODULE_LOADING_FIELD_NUMBER = 13;
  private com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
      nodeKernelModuleLoading_;

  /**
   *
   *
   * <pre>
   * Optional. Configuration for kernel module loading on nodes.
   * When enabled, the node pool will be provisioned with a Container-Optimized
   * OS image that enforces kernel module signature verification.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return Whether the nodeKernelModuleLoading field is set.
   */
  @java.lang.Override
  public boolean hasNodeKernelModuleLoading() {
    return ((bitField0_ & 0x00000004) != 0);
  }

  /**
   *
   *
   * <pre>
   * Optional. Configuration for kernel module loading on nodes.
   * When enabled, the node pool will be provisioned with a Container-Optimized
   * OS image that enforces kernel module signature verification.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   *
   * @return The nodeKernelModuleLoading.
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
      getNodeKernelModuleLoading() {
    return nodeKernelModuleLoading_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.getDefaultInstance()
        : nodeKernelModuleLoading_;
  }

  /**
   *
   *
   * <pre>
   * Optional. Configuration for kernel module loading on nodes.
   * When enabled, the node pool will be provisioned with a Container-Optimized
   * OS image that enforces kernel module signature verification.
   * </pre>
   *
   * <code>
   * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
   * </code>
   */
  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder
      getNodeKernelModuleLoadingOrBuilder() {
    return nodeKernelModuleLoading_ == null
        ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.getDefaultInstance()
        : nodeKernelModuleLoading_;
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
        output, internalGetSysctls(), SysctlsDefaultEntryHolder.defaultEntry, 1);
    if (cgroupMode_
        != com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.CGROUP_MODE_UNSPECIFIED
            .getNumber()) {
      output.writeEnum(2, cgroupMode_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeMessage(3, getHugepages());
    }
    if (transparentHugepageEnabled_
        != com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled
            .TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED
            .getNumber()) {
      output.writeEnum(4, transparentHugepageEnabled_);
    }
    if (transparentHugepageDefrag_
        != com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag
            .TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED
            .getNumber()) {
      output.writeEnum(5, transparentHugepageDefrag_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeMessage(12, getSwapConfig());
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      output.writeMessage(13, getNodeKernelModuleLoading());
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry :
        internalGetSysctls().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, java.lang.String> sysctls__ =
          SysctlsDefaultEntryHolder.defaultEntry
              .newBuilderForType()
              .setKey(entry.getKey())
              .setValue(entry.getValue())
              .build();
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, sysctls__);
    }
    if (cgroupMode_
        != com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.CGROUP_MODE_UNSPECIFIED
            .getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(2, cgroupMode_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getHugepages());
    }
    if (transparentHugepageEnabled_
        != com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled
            .TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED
            .getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(4, transparentHugepageEnabled_);
    }
    if (transparentHugepageDefrag_
        != com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag
            .TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED
            .getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(5, transparentHugepageDefrag_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(12, getSwapConfig());
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(
              13, getNodeKernelModuleLoading());
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.container.v1beta1.LinuxNodeConfig)) {
      return super.equals(obj);
    }
    com.google.container.v1beta1.LinuxNodeConfig other =
        (com.google.container.v1beta1.LinuxNodeConfig) obj;

    if (!internalGetSysctls().equals(other.internalGetSysctls())) return false;
    if (cgroupMode_ != other.cgroupMode_) return false;
    if (hasHugepages() != other.hasHugepages()) return false;
    if (hasHugepages()) {
      if (!getHugepages().equals(other.getHugepages())) return false;
    }
    if (transparentHugepageEnabled_ != other.transparentHugepageEnabled_) return false;
    if (transparentHugepageDefrag_ != other.transparentHugepageDefrag_) return false;
    if (hasSwapConfig() != other.hasSwapConfig()) return false;
    if (hasSwapConfig()) {
      if (!getSwapConfig().equals(other.getSwapConfig())) return false;
    }
    if (hasNodeKernelModuleLoading() != other.hasNodeKernelModuleLoading()) return false;
    if (hasNodeKernelModuleLoading()) {
      if (!getNodeKernelModuleLoading().equals(other.getNodeKernelModuleLoading())) return false;
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (!internalGetSysctls().getMap().isEmpty()) {
      hash = (37 * hash) + SYSCTLS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetSysctls().hashCode();
    }
    hash = (37 * hash) + CGROUP_MODE_FIELD_NUMBER;
    hash = (53 * hash) + cgroupMode_;
    if (hasHugepages()) {
      hash = (37 * hash) + HUGEPAGES_FIELD_NUMBER;
      hash = (53 * hash) + getHugepages().hashCode();
    }
    hash = (37 * hash) + TRANSPARENT_HUGEPAGE_ENABLED_FIELD_NUMBER;
    hash = (53 * hash) + transparentHugepageEnabled_;
    hash = (37 * hash) + TRANSPARENT_HUGEPAGE_DEFRAG_FIELD_NUMBER;
    hash = (53 * hash) + transparentHugepageDefrag_;
    if (hasSwapConfig()) {
      hash = (37 * hash) + SWAP_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getSwapConfig().hashCode();
    }
    if (hasNodeKernelModuleLoading()) {
      hash = (37 * hash) + NODE_KERNEL_MODULE_LOADING_FIELD_NUMBER;
      hash = (53 * hash) + getNodeKernelModuleLoading().hashCode();
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.container.v1beta1.LinuxNodeConfig parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.container.v1beta1.LinuxNodeConfig prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }

  /**
   *
   *
   * <pre>
   * Parameters that can be configured on Linux nodes.
   * </pre>
   *
   * Protobuf type {@code google.container.v1beta1.LinuxNodeConfig}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.container.v1beta1.LinuxNodeConfig)
      com.google.container.v1beta1.LinuxNodeConfigOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetSysctls();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetMutableSysctls();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.container.v1beta1.LinuxNodeConfig.class,
              com.google.container.v1beta1.LinuxNodeConfig.Builder.class);
    }

    // Construct using com.google.container.v1beta1.LinuxNodeConfig.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getHugepagesFieldBuilder();
        getSwapConfigFieldBuilder();
        getNodeKernelModuleLoadingFieldBuilder();
      }
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      internalGetMutableSysctls().clear();
      cgroupMode_ = 0;
      hugepages_ = null;
      if (hugepagesBuilder_ != null) {
        hugepagesBuilder_.dispose();
        hugepagesBuilder_ = null;
      }
      transparentHugepageEnabled_ = 0;
      transparentHugepageDefrag_ = 0;
      swapConfig_ = null;
      if (swapConfigBuilder_ != null) {
        swapConfigBuilder_.dispose();
        swapConfigBuilder_ = null;
      }
      nodeKernelModuleLoading_ = null;
      if (nodeKernelModuleLoadingBuilder_ != null) {
        nodeKernelModuleLoadingBuilder_.dispose();
        nodeKernelModuleLoadingBuilder_ = null;
      }
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.container.v1beta1.ClusterServiceProto
          .internal_static_google_container_v1beta1_LinuxNodeConfig_descriptor;
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig getDefaultInstanceForType() {
      return com.google.container.v1beta1.LinuxNodeConfig.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig build() {
      com.google.container.v1beta1.LinuxNodeConfig result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig buildPartial() {
      com.google.container.v1beta1.LinuxNodeConfig result =
          new com.google.container.v1beta1.LinuxNodeConfig(this);
      if (bitField0_ != 0) {
        buildPartial0(result);
      }
      onBuilt();
      return result;
    }

    private void buildPartial0(com.google.container.v1beta1.LinuxNodeConfig result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.sysctls_ = internalGetSysctls();
        result.sysctls_.makeImmutable();
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.cgroupMode_ = cgroupMode_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.hugepages_ = hugepagesBuilder_ == null ? hugepages_ : hugepagesBuilder_.build();
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.transparentHugepageEnabled_ = transparentHugepageEnabled_;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.transparentHugepageDefrag_ = transparentHugepageDefrag_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.swapConfig_ = swapConfigBuilder_ == null ? swapConfig_ : swapConfigBuilder_.build();
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.nodeKernelModuleLoading_ =
            nodeKernelModuleLoadingBuilder_ == null
                ? nodeKernelModuleLoading_
                : nodeKernelModuleLoadingBuilder_.build();
        to_bitField0_ |= 0x00000004;
      }
      result.bitField0_ |= to_bitField0_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.container.v1beta1.LinuxNodeConfig) {
        return mergeFrom((com.google.container.v1beta1.LinuxNodeConfig) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.container.v1beta1.LinuxNodeConfig other) {
      if (other == com.google.container.v1beta1.LinuxNodeConfig.getDefaultInstance()) return this;
      internalGetMutableSysctls().mergeFrom(other.internalGetSysctls());
      bitField0_ |= 0x00000001;
      if (other.cgroupMode_ != 0) {
        setCgroupModeValue(other.getCgroupModeValue());
      }
      if (other.hasHugepages()) {
        mergeHugepages(other.getHugepages());
      }
      if (other.transparentHugepageEnabled_ != 0) {
        setTransparentHugepageEnabledValue(other.getTransparentHugepageEnabledValue());
      }
      if (other.transparentHugepageDefrag_ != 0) {
        setTransparentHugepageDefragValue(other.getTransparentHugepageDefragValue());
      }
      if (other.hasSwapConfig()) {
        mergeSwapConfig(other.getSwapConfig());
      }
      if (other.hasNodeKernelModuleLoading()) {
        mergeNodeKernelModuleLoading(other.getNodeKernelModuleLoading());
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10:
              {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String> sysctls__ =
                    input.readMessage(
                        SysctlsDefaultEntryHolder.defaultEntry.getParserForType(),
                        extensionRegistry);
                internalGetMutableSysctls()
                    .getMutableMap()
                    .put(sysctls__.getKey(), sysctls__.getValue());
                bitField0_ |= 0x00000001;
                break;
              } // case 10
            case 16:
              {
                cgroupMode_ = input.readEnum();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
            case 26:
              {
                input.readMessage(getHugepagesFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
            case 32:
              {
                transparentHugepageEnabled_ = input.readEnum();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
            case 40:
              {
                transparentHugepageDefrag_ = input.readEnum();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
            case 98:
              {
                input.readMessage(getSwapConfigFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 98
            case 106:
              {
                input.readMessage(
                    getNodeKernelModuleLoadingFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 106
            default:
              {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }

    private int bitField0_;

    private com.google.protobuf.MapField<java.lang.String, java.lang.String> sysctls_;

    private com.google.protobuf.MapField<java.lang.String, java.lang.String> internalGetSysctls() {
      if (sysctls_ == null) {
        return com.google.protobuf.MapField.emptyMapField(SysctlsDefaultEntryHolder.defaultEntry);
      }
      return sysctls_;
    }

    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetMutableSysctls() {
      if (sysctls_ == null) {
        sysctls_ = com.google.protobuf.MapField.newMapField(SysctlsDefaultEntryHolder.defaultEntry);
      }
      if (!sysctls_.isMutable()) {
        sysctls_ = sysctls_.copy();
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return sysctls_;
    }

    public int getSysctlsCount() {
      return internalGetSysctls().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    @java.lang.Override
    public boolean containsSysctls(java.lang.String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetSysctls().getMap().containsKey(key);
    }

    /** Use {@link #getSysctlsMap()} instead. */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSysctls() {
      return getSysctlsMap();
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getSysctlsMap() {
      return internalGetSysctls().getMap();
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    @java.lang.Override
    public /* nullable */ java.lang.String getSysctlsOrDefault(
        java.lang.String key,
        /* nullable */
        java.lang.String defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<java.lang.String, java.lang.String> map = internalGetSysctls().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    @java.lang.Override
    public java.lang.String getSysctlsOrThrow(java.lang.String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<java.lang.String, java.lang.String> map = internalGetSysctls().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearSysctls() {
      bitField0_ = (bitField0_ & ~0x00000001);
      internalGetMutableSysctls().getMutableMap().clear();
      return this;
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    public Builder removeSysctls(java.lang.String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      internalGetMutableSysctls().getMutableMap().remove(key);
      return this;
    }

    /** Use alternate mutation accessors instead. */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getMutableSysctls() {
      bitField0_ |= 0x00000001;
      return internalGetMutableSysctls().getMutableMap();
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    public Builder putSysctls(java.lang.String key, java.lang.String value) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      if (value == null) {
        throw new NullPointerException("map value");
      }
      internalGetMutableSysctls().getMutableMap().put(key, value);
      bitField0_ |= 0x00000001;
      return this;
    }

    /**
     *
     *
     * <pre>
     * The Linux kernel parameters to be applied to the nodes and all pods running
     * on the nodes.
     *
     * The following parameters are supported.
     *
     * net.core.busy_poll
     * net.core.busy_read
     * net.core.netdev_max_backlog
     * net.core.rmem_max
     * net.core.rmem_default
     * net.core.wmem_default
     * net.core.wmem_max
     * net.core.optmem_max
     * net.core.somaxconn
     * net.ipv4.tcp_rmem
     * net.ipv4.tcp_wmem
     * net.ipv4.tcp_tw_reuse
     * net.ipv4.tcp_max_orphans
     * net.netfilter.nf_conntrack_max
     * net.netfilter.nf_conntrack_buckets
     * net.netfilter.nf_conntrack_tcp_timeout_close_wait
     * net.netfilter.nf_conntrack_tcp_timeout_time_wait
     * net.netfilter.nf_conntrack_tcp_timeout_established
     * net.netfilter.nf_conntrack_acct
     * kernel.shmmni
     * kernel.shmmax
     * kernel.shmall
     * fs.aio-max-nr
     * fs.file-max
     * fs.inotify.max_user_instances
     * fs.inotify.max_user_watches
     * fs.nr_open
     * vm.dirty_background_ratio
     * vm.dirty_expire_centisecs
     * vm.dirty_ratio
     * vm.dirty_writeback_centisecs
     * vm.max_map_count
     * vm.overcommit_memory
     * vm.overcommit_ratio
     * vm.vfs_cache_pressure
     * vm.swappiness
     * vm.watermark_scale_factor
     * vm.min_free_kbytes
     * </pre>
     *
     * <code>map&lt;string, string&gt; sysctls = 1;</code>
     */
    public Builder putAllSysctls(java.util.Map<java.lang.String, java.lang.String> values) {
      internalGetMutableSysctls().getMutableMap().putAll(values);
      bitField0_ |= 0x00000001;
      return this;
    }

    private int cgroupMode_ = 0;

    /**
     *
     *
     * <pre>
     * cgroup_mode specifies the cgroup mode to be used on the node.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
     *
     * @return The enum numeric value on the wire for cgroupMode.
     */
    @java.lang.Override
    public int getCgroupModeValue() {
      return cgroupMode_;
    }

    /**
     *
     *
     * <pre>
     * cgroup_mode specifies the cgroup mode to be used on the node.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
     *
     * @param value The enum numeric value on the wire for cgroupMode to set.
     * @return This builder for chaining.
     */
    public Builder setCgroupModeValue(int value) {
      cgroupMode_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * cgroup_mode specifies the cgroup mode to be used on the node.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
     *
     * @return The cgroupMode.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.CgroupMode getCgroupMode() {
      com.google.container.v1beta1.LinuxNodeConfig.CgroupMode result =
          com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.forNumber(cgroupMode_);
      return result == null
          ? com.google.container.v1beta1.LinuxNodeConfig.CgroupMode.UNRECOGNIZED
          : result;
    }

    /**
     *
     *
     * <pre>
     * cgroup_mode specifies the cgroup mode to be used on the node.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
     *
     * @param value The cgroupMode to set.
     * @return This builder for chaining.
     */
    public Builder setCgroupMode(com.google.container.v1beta1.LinuxNodeConfig.CgroupMode value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      cgroupMode_ = value.getNumber();
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * cgroup_mode specifies the cgroup mode to be used on the node.
     * </pre>
     *
     * <code>.google.container.v1beta1.LinuxNodeConfig.CgroupMode cgroup_mode = 2;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCgroupMode() {
      bitField0_ = (bitField0_ & ~0x00000002);
      cgroupMode_ = 0;
      onChanged();
      return this;
    }

    private com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig,
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder>
        hugepagesBuilder_;

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return Whether the hugepages field is set.
     */
    public boolean hasHugepages() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The hugepages.
     */
    public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig getHugepages() {
      if (hugepagesBuilder_ == null) {
        return hugepages_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance()
            : hugepages_;
      } else {
        return hugepagesBuilder_.getMessage();
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setHugepages(
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig value) {
      if (hugepagesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        hugepages_ = value;
      } else {
        hugepagesBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setHugepages(
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder builderForValue) {
      if (hugepagesBuilder_ == null) {
        hugepages_ = builderForValue.build();
      } else {
        hugepagesBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder mergeHugepages(
        com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig value) {
      if (hugepagesBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)
            && hugepages_ != null
            && hugepages_
                != com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig
                    .getDefaultInstance()) {
          getHugepagesBuilder().mergeFrom(value);
        } else {
          hugepages_ = value;
        }
      } else {
        hugepagesBuilder_.mergeFrom(value);
      }
      if (hugepages_ != null) {
        bitField0_ |= 0x00000004;
        onChanged();
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder clearHugepages() {
      bitField0_ = (bitField0_ & ~0x00000004);
      hugepages_ = null;
      if (hugepagesBuilder_ != null) {
        hugepagesBuilder_.dispose();
        hugepagesBuilder_ = null;
      }
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder
        getHugepagesBuilder() {
      bitField0_ |= 0x00000004;
      onChanged();
      return getHugepagesFieldBuilder().getBuilder();
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder
        getHugepagesOrBuilder() {
      if (hugepagesBuilder_ != null) {
        return hugepagesBuilder_.getMessageOrBuilder();
      } else {
        return hugepages_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.getDefaultInstance()
            : hugepages_;
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Amounts for 2M and 1G hugepages
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.HugepagesConfig hugepages = 3 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig,
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder>
        getHugepagesFieldBuilder() {
      if (hugepagesBuilder_ == null) {
        hugepagesBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig,
                com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfig.Builder,
                com.google.container.v1beta1.LinuxNodeConfig.HugepagesConfigOrBuilder>(
                getHugepages(), getParentForChildren(), isClean());
        hugepages_ = null;
      }
      return hugepagesBuilder_;
    }

    private int transparentHugepageEnabled_ = 0;

    /**
     *
     *
     * <pre>
     * Optional. Transparent hugepage support for anonymous memory can be entirely
     * disabled (mostly for debugging purposes) or only enabled inside
     * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
     * resources) or enabled system wide.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The enum numeric value on the wire for transparentHugepageEnabled.
     */
    @java.lang.Override
    public int getTransparentHugepageEnabledValue() {
      return transparentHugepageEnabled_;
    }

    /**
     *
     *
     * <pre>
     * Optional. Transparent hugepage support for anonymous memory can be entirely
     * disabled (mostly for debugging purposes) or only enabled inside
     * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
     * resources) or enabled system wide.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @param value The enum numeric value on the wire for transparentHugepageEnabled to set.
     * @return This builder for chaining.
     */
    public Builder setTransparentHugepageEnabledValue(int value) {
      transparentHugepageEnabled_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Transparent hugepage support for anonymous memory can be entirely
     * disabled (mostly for debugging purposes) or only enabled inside
     * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
     * resources) or enabled system wide.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The transparentHugepageEnabled.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled
        getTransparentHugepageEnabled() {
      com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled result =
          com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled.forNumber(
              transparentHugepageEnabled_);
      return result == null
          ? com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled.UNRECOGNIZED
          : result;
    }

    /**
     *
     *
     * <pre>
     * Optional. Transparent hugepage support for anonymous memory can be entirely
     * disabled (mostly for debugging purposes) or only enabled inside
     * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
     * resources) or enabled system wide.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @param value The transparentHugepageEnabled to set.
     * @return This builder for chaining.
     */
    public Builder setTransparentHugepageEnabled(
        com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000008;
      transparentHugepageEnabled_ = value.getNumber();
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Transparent hugepage support for anonymous memory can be entirely
     * disabled (mostly for debugging purposes) or only enabled inside
     * MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
     * resources) or enabled system wide.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageEnabled transparent_hugepage_enabled = 4 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTransparentHugepageEnabled() {
      bitField0_ = (bitField0_ & ~0x00000008);
      transparentHugepageEnabled_ = 0;
      onChanged();
      return this;
    }

    private int transparentHugepageDefrag_ = 0;

    /**
     *
     *
     * <pre>
     * Optional. Defines the transparent hugepage defrag configuration on the
     * node. VM hugepage allocation can be managed by either limiting
     * defragmentation for delayed allocation or skipping it entirely for
     * immediate allocation only.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The enum numeric value on the wire for transparentHugepageDefrag.
     */
    @java.lang.Override
    public int getTransparentHugepageDefragValue() {
      return transparentHugepageDefrag_;
    }

    /**
     *
     *
     * <pre>
     * Optional. Defines the transparent hugepage defrag configuration on the
     * node. VM hugepage allocation can be managed by either limiting
     * defragmentation for delayed allocation or skipping it entirely for
     * immediate allocation only.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @param value The enum numeric value on the wire for transparentHugepageDefrag to set.
     * @return This builder for chaining.
     */
    public Builder setTransparentHugepageDefragValue(int value) {
      transparentHugepageDefrag_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Defines the transparent hugepage defrag configuration on the
     * node. VM hugepage allocation can be managed by either limiting
     * defragmentation for delayed allocation or skipping it entirely for
     * immediate allocation only.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The transparentHugepageDefrag.
     */
    @java.lang.Override
    public com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag
        getTransparentHugepageDefrag() {
      com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag result =
          com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag.forNumber(
              transparentHugepageDefrag_);
      return result == null
          ? com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag.UNRECOGNIZED
          : result;
    }

    /**
     *
     *
     * <pre>
     * Optional. Defines the transparent hugepage defrag configuration on the
     * node. VM hugepage allocation can be managed by either limiting
     * defragmentation for delayed allocation or skipping it entirely for
     * immediate allocation only.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @param value The transparentHugepageDefrag to set.
     * @return This builder for chaining.
     */
    public Builder setTransparentHugepageDefrag(
        com.google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      transparentHugepageDefrag_ = value.getNumber();
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Defines the transparent hugepage defrag configuration on the
     * node. VM hugepage allocation can be managed by either limiting
     * defragmentation for delayed allocation or skipping it entirely for
     * immediate allocation only.
     *
     * See https://docs.kernel.org/admin-guide/mm/transhuge.html
     * for more details.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.TransparentHugepageDefrag transparent_hugepage_defrag = 5 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return This builder for chaining.
     */
    public Builder clearTransparentHugepageDefrag() {
      bitField0_ = (bitField0_ & ~0x00000010);
      transparentHugepageDefrag_ = 0;
      onChanged();
      return this;
    }

    private com.google.container.v1beta1.LinuxNodeConfig.SwapConfig swapConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig,
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder>
        swapConfigBuilder_;

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return Whether the swapConfig field is set.
     */
    public boolean hasSwapConfig() {
      return ((bitField0_ & 0x00000020) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The swapConfig.
     */
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig getSwapConfig() {
      if (swapConfigBuilder_ == null) {
        return swapConfig_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance()
            : swapConfig_;
      } else {
        return swapConfigBuilder_.getMessage();
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setSwapConfig(com.google.container.v1beta1.LinuxNodeConfig.SwapConfig value) {
      if (swapConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        swapConfig_ = value;
      } else {
        swapConfigBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setSwapConfig(
        com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder builderForValue) {
      if (swapConfigBuilder_ == null) {
        swapConfig_ = builderForValue.build();
      } else {
        swapConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder mergeSwapConfig(com.google.container.v1beta1.LinuxNodeConfig.SwapConfig value) {
      if (swapConfigBuilder_ == null) {
        if (((bitField0_ & 0x00000020) != 0)
            && swapConfig_ != null
            && swapConfig_
                != com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance()) {
          getSwapConfigBuilder().mergeFrom(value);
        } else {
          swapConfig_ = value;
        }
      } else {
        swapConfigBuilder_.mergeFrom(value);
      }
      if (swapConfig_ != null) {
        bitField0_ |= 0x00000020;
        onChanged();
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder clearSwapConfig() {
      bitField0_ = (bitField0_ & ~0x00000020);
      swapConfig_ = null;
      if (swapConfigBuilder_ != null) {
        swapConfigBuilder_.dispose();
        swapConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder getSwapConfigBuilder() {
      bitField0_ |= 0x00000020;
      onChanged();
      return getSwapConfigFieldBuilder().getBuilder();
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder
        getSwapConfigOrBuilder() {
      if (swapConfigBuilder_ != null) {
        return swapConfigBuilder_.getMessageOrBuilder();
      } else {
        return swapConfig_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.getDefaultInstance()
            : swapConfig_;
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Enables and configures swap space on nodes.
     * If omitted, swap is disabled.
     * </pre>
     *
     * <code>
     * optional .google.container.v1beta1.LinuxNodeConfig.SwapConfig swap_config = 12 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig,
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder>
        getSwapConfigFieldBuilder() {
      if (swapConfigBuilder_ == null) {
        swapConfigBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfig.Builder,
                com.google.container.v1beta1.LinuxNodeConfig.SwapConfigOrBuilder>(
                getSwapConfig(), getParentForChildren(), isClean());
        swapConfig_ = null;
      }
      return swapConfigBuilder_;
    }

    private com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        nodeKernelModuleLoading_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading,
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder>
        nodeKernelModuleLoadingBuilder_;

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return Whether the nodeKernelModuleLoading field is set.
     */
    public boolean hasNodeKernelModuleLoading() {
      return ((bitField0_ & 0x00000040) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     *
     * @return The nodeKernelModuleLoading.
     */
    public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
        getNodeKernelModuleLoading() {
      if (nodeKernelModuleLoadingBuilder_ == null) {
        return nodeKernelModuleLoading_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
                .getDefaultInstance()
            : nodeKernelModuleLoading_;
      } else {
        return nodeKernelModuleLoadingBuilder_.getMessage();
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setNodeKernelModuleLoading(
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading value) {
      if (nodeKernelModuleLoadingBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        nodeKernelModuleLoading_ = value;
      } else {
        nodeKernelModuleLoadingBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder setNodeKernelModuleLoading(
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder
            builderForValue) {
      if (nodeKernelModuleLoadingBuilder_ == null) {
        nodeKernelModuleLoading_ = builderForValue.build();
      } else {
        nodeKernelModuleLoadingBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder mergeNodeKernelModuleLoading(
        com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading value) {
      if (nodeKernelModuleLoadingBuilder_ == null) {
        if (((bitField0_ & 0x00000040) != 0)
            && nodeKernelModuleLoading_ != null
            && nodeKernelModuleLoading_
                != com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
                    .getDefaultInstance()) {
          getNodeKernelModuleLoadingBuilder().mergeFrom(value);
        } else {
          nodeKernelModuleLoading_ = value;
        }
      } else {
        nodeKernelModuleLoadingBuilder_.mergeFrom(value);
      }
      if (nodeKernelModuleLoading_ != null) {
        bitField0_ |= 0x00000040;
        onChanged();
      }
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public Builder clearNodeKernelModuleLoading() {
      bitField0_ = (bitField0_ & ~0x00000040);
      nodeKernelModuleLoading_ = null;
      if (nodeKernelModuleLoadingBuilder_ != null) {
        nodeKernelModuleLoadingBuilder_.dispose();
        nodeKernelModuleLoadingBuilder_ = null;
      }
      onChanged();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder
        getNodeKernelModuleLoadingBuilder() {
      bitField0_ |= 0x00000040;
      onChanged();
      return getNodeKernelModuleLoadingFieldBuilder().getBuilder();
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    public com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder
        getNodeKernelModuleLoadingOrBuilder() {
      if (nodeKernelModuleLoadingBuilder_ != null) {
        return nodeKernelModuleLoadingBuilder_.getMessageOrBuilder();
      } else {
        return nodeKernelModuleLoading_ == null
            ? com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading
                .getDefaultInstance()
            : nodeKernelModuleLoading_;
      }
    }

    /**
     *
     *
     * <pre>
     * Optional. Configuration for kernel module loading on nodes.
     * When enabled, the node pool will be provisioned with a Container-Optimized
     * OS image that enforces kernel module signature verification.
     * </pre>
     *
     * <code>
     * .google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading node_kernel_module_loading = 13 [(.google.api.field_behavior) = OPTIONAL];
     * </code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading,
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder,
            com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder>
        getNodeKernelModuleLoadingFieldBuilder() {
      if (nodeKernelModuleLoadingBuilder_ == null) {
        nodeKernelModuleLoadingBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading,
                com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoading.Builder,
                com.google.container.v1beta1.LinuxNodeConfig.NodeKernelModuleLoadingOrBuilder>(
                getNodeKernelModuleLoading(), getParentForChildren(), isClean());
        nodeKernelModuleLoading_ = null;
      }
      return nodeKernelModuleLoadingBuilder_;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.container.v1beta1.LinuxNodeConfig)
  }

  // @@protoc_insertion_point(class_scope:google.container.v1beta1.LinuxNodeConfig)
  private static final com.google.container.v1beta1.LinuxNodeConfig DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.container.v1beta1.LinuxNodeConfig();
  }

  public static com.google.container.v1beta1.LinuxNodeConfig getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<LinuxNodeConfig> PARSER =
      new com.google.protobuf.AbstractParser<LinuxNodeConfig>() {
        @java.lang.Override
        public LinuxNodeConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

  public static com.google.protobuf.Parser<LinuxNodeConfig> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<LinuxNodeConfig> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.container.v1beta1.LinuxNodeConfig getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
