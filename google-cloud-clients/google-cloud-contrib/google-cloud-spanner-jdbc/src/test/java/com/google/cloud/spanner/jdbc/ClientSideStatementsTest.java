/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.spanner.jdbc;

import com.google.cloud.NoCredentials;
import com.google.cloud.spanner.ErrorCode;
import com.google.cloud.spanner.jdbc.AbstractSqlScriptVerifier.GenericConnection;
import com.google.cloud.spanner.jdbc.AbstractSqlScriptVerifier.GenericConnectionProvider;
import com.google.cloud.spanner.jdbc.SqlScriptVerifier.SpannerGenericConnection;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.AfterClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * Test that runs a pre-generated sql script for {@link ClientSideStatement}s. The sql script can be
 * generated by running <code>mvn -P generate-test-sql-scripts compile</code> It is only necessary
 * to generate a new test script if a new {@link ClientSideStatement} has been added, or the
 * behavior of an existing {@link ClientSideStatement} has changed.
 *
 * <p>This class does not need to be implemented for the client libraries of other programming
 * languages. All test cases are covered by the sql file ClientSideStatementsTest.sql.
 */
@RunWith(JUnit4.class)
public class ClientSideStatementsTest {

  @Test
  public void testExecuteClientSideStatementsScript() throws Exception {
    SqlScriptVerifier verifier = new SqlScriptVerifier(new TestConnectionProvider());
    verifier.verifyStatementsInFile("ClientSideStatementsTest.sql", getClass());
  }

  private static final String SCRIPT_FILE =
      "src/test/resources/com/google/cloud/spanner/jdbc/ClientSideStatementsTest.sql";
  private static PrintWriter writer;

  /** Generates the test script file */
  static void generateTestScript() throws Exception {
    try {
      openLog();
      ClientSideStatements statements = ClientSideStatements.INSTANCE;
      for (ClientSideStatementImpl statement : statements.getCompiledStatements()) {
        generateTestStatements(statement);
      }
    } finally {
      closeLog();
    }
  }

  /** Writes the prerequisite statements + the given sql statement to a script file */
  private static void log(List<String> pre, String sql) {
    writeLog("NEW_CONNECTION");
    for (String prerequisite : pre) {
      writeLog(prerequisite);
    }
    writeLog(sql);
  }

  /**
   * Writes the prerequisite statements + the given sql statement to a script file preceded by
   * an @EXPECT EXCEPTION error statement
   */
  private static void log(List<String> pre, String statement, ErrorCode error) {
    log(pre, "@EXPECT EXCEPTION " + error.name() + "\n" + statement);
  }

  /** Writes the actual statement to the script file */
  private static void writeLog(String statement) {
    writer.println(statement + ";");
  }

  private static void openLog() {
    try {
      writer =
          new PrintWriter(
              new OutputStreamWriter(new FileOutputStream(SCRIPT_FILE, false), "UTF8"), true);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @AfterClass
  public static void closeLog() {
    if (writer != null) {
      writer.close();
    }
  }

  static class TestConnectionProvider implements GenericConnectionProvider {
    @Override
    public GenericConnection getConnection() {
      return SpannerGenericConnection.of(
          ConnectionImplTest.createConnection(
              ConnectionOptions.newBuilder()
                  .setCredentials(NoCredentials.getInstance())
                  .setUri(ConnectionImplTest.URI)
                  .build()));
    }
  }

  /** Generates test statements for all {@link ClientSideStatement}s */
  private static void generateTestStatements(ClientSideStatementImpl statement) {
    for (String sql : statement.getExampleStatements()) {
      log(statement.getExamplePrerequisiteStatements(), sql);
      log(statement.getExamplePrerequisiteStatements(), upper(sql));
      log(statement.getExamplePrerequisiteStatements(), lower(sql));
      log(statement.getExamplePrerequisiteStatements(), withLeadingSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withLeadingTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withLeadingLinefeeds(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingLinefeeds(sql));
      log(statement.getExamplePrerequisiteStatements(), withSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withLinefeeds(sql));

      log(
          statement.getExamplePrerequisiteStatements(),
          withInvalidPrefix(sql),
          ErrorCode.INVALID_ARGUMENT);
      log(
          statement.getExamplePrerequisiteStatements(),
          withInvalidSuffix(sql),
          ErrorCode.INVALID_ARGUMENT);

      final String[] replacements = {
        "%", "_", "&", "$", "@", "!", "*", "(", ")", "-", "+", "-#", "/", "\\", "?", "-/", "/#",
        "/-"
      };
      for (String replacement : replacements) {
        log(
            statement.getExamplePrerequisiteStatements(),
            withPrefix(replacement, sql),
            ErrorCode.INVALID_ARGUMENT);
        log(
            statement.getExamplePrerequisiteStatements(),
            withSuffix(replacement, sql),
            ErrorCode.INVALID_ARGUMENT);
        log(
            statement.getExamplePrerequisiteStatements(),
            replaceLastSpaceWith(replacement, sql),
            ErrorCode.INVALID_ARGUMENT);
      }
    }
  }

  private static String upper(String statement) {
    return statement.toUpperCase();
  }

  private static String lower(String statement) {
    return statement.toLowerCase();
  }

  private static String withLeadingSpaces(String statement) {
    return "   " + statement;
  }

  private static String withLeadingTabs(String statement) {
    return "\t\t\t" + statement;
  }

  private static String withLeadingLinefeeds(String statement) {
    return "\n\n\n" + statement;
  }

  private static String withTrailingSpaces(String statement) {
    return statement + "  ";
  }

  private static String withTrailingTabs(String statement) {
    return statement + "\t\t";
  }

  private static String withTrailingLinefeeds(String statement) {
    return statement + "\n\n";
  }

  private static String withSpaces(String statement) {
    return statement.replaceAll(" ", "   ");
  }

  private static String withTabs(String statement) {
    return statement.replaceAll(" ", "\t");
  }

  private static String withLinefeeds(String statement) {
    // Do not replace spaces inside quotes
    Matcher matcher = Pattern.compile("(.*)('.*')").matcher(statement);
    if (matcher.matches()) {
      return matcher.group(1).replaceAll(" ", "\n") + matcher.group(2);
    }
    return statement.replaceAll(" ", "\n");
  }

  private static String withInvalidPrefix(String statement) {
    return "foo " + statement;
  }

  private static String withInvalidSuffix(String statement) {
    return statement + " bar";
  }

  private static String withPrefix(String prefix, String statement) {
    return prefix + statement;
  }

  private static String withSuffix(String suffix, String statement) {
    return statement + suffix;
  }

  private static String replaceLastSpaceWith(String replacement, String statement) {
    if (statement.lastIndexOf(' ') > -1) {
      return statement.substring(0, statement.lastIndexOf(' '))
          + replacement
          + statement.substring(statement.lastIndexOf(' ') + 1);
    }
    return statement + replacement;
  }
}
