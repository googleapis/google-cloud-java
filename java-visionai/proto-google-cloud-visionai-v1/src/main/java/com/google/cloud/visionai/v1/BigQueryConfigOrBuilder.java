/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/visionai/v1/platform.proto

// Protobuf Java Version: 3.25.3
package com.google.cloud.visionai.v1;

public interface BigQueryConfigOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.cloud.visionai.v1.BigQueryConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * BigQuery table resource for Vision AI Platform to ingest annotations to.
   * </pre>
   *
   * <code>string table = 1;</code>
   *
   * @return The table.
   */
  java.lang.String getTable();
  /**
   *
   *
   * <pre>
   * BigQuery table resource for Vision AI Platform to ingest annotations to.
   * </pre>
   *
   * <code>string table = 1;</code>
   *
   * @return The bytes for table.
   */
  com.google.protobuf.ByteString getTableBytes();

  /**
   *
   *
   * <pre>
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   * </pre>
   *
   * <code>map&lt;string, string&gt; cloud_function_mapping = 2;</code>
   */
  int getCloudFunctionMappingCount();
  /**
   *
   *
   * <pre>
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   * </pre>
   *
   * <code>map&lt;string, string&gt; cloud_function_mapping = 2;</code>
   */
  boolean containsCloudFunctionMapping(java.lang.String key);
  /** Use {@link #getCloudFunctionMappingMap()} instead. */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, java.lang.String> getCloudFunctionMapping();
  /**
   *
   *
   * <pre>
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   * </pre>
   *
   * <code>map&lt;string, string&gt; cloud_function_mapping = 2;</code>
   */
  java.util.Map<java.lang.String, java.lang.String> getCloudFunctionMappingMap();
  /**
   *
   *
   * <pre>
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   * </pre>
   *
   * <code>map&lt;string, string&gt; cloud_function_mapping = 2;</code>
   */
  /* nullable */
  java.lang.String getCloudFunctionMappingOrDefault(
      java.lang.String key,
      /* nullable */
      java.lang.String defaultValue);
  /**
   *
   *
   * <pre>
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   * </pre>
   *
   * <code>map&lt;string, string&gt; cloud_function_mapping = 2;</code>
   */
  java.lang.String getCloudFunctionMappingOrThrow(java.lang.String key);

  /**
   *
   *
   * <pre>
   * If true, App Platform will create the BigQuery DataSet and the
   * BigQuery Table with default schema if the specified table doesn't exist.
   * This doesn't work if any cloud function customized schema is specified
   * since the system doesn't know your desired schema.
   * JSON column will be used in the default table created by App Platform.
   * </pre>
   *
   * <code>bool create_default_table_if_not_exists = 3;</code>
   *
   * @return The createDefaultTableIfNotExists.
   */
  boolean getCreateDefaultTableIfNotExists();
}
