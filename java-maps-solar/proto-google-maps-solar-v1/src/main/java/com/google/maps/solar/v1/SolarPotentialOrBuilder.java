/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/maps/solar/v1/solar_service.proto

// Protobuf Java Version: 3.25.3
package com.google.maps.solar.v1;

public interface SolarPotentialOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.maps.solar.v1.SolarPotential)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * Size of the maximum array - that is, the maximum number of panels that
   * can fit on the roof.
   * </pre>
   *
   * <code>int32 max_array_panels_count = 1;</code>
   *
   * @return The maxArrayPanelsCount.
   */
  int getMaxArrayPanelsCount();

  /**
   *
   *
   * <pre>
   * Capacity, in watts, of the panel used in the calculations.
   * </pre>
   *
   * <code>float panel_capacity_watts = 9;</code>
   *
   * @return The panelCapacityWatts.
   */
  float getPanelCapacityWatts();

  /**
   *
   *
   * <pre>
   * Height, in meters in portrait orientation, of the panel used in
   * the calculations.
   * </pre>
   *
   * <code>float panel_height_meters = 10;</code>
   *
   * @return The panelHeightMeters.
   */
  float getPanelHeightMeters();

  /**
   *
   *
   * <pre>
   * Width, in meters in portrait orientation, of the panel used in
   * the calculations.
   * </pre>
   *
   * <code>float panel_width_meters = 11;</code>
   *
   * @return The panelWidthMeters.
   */
  float getPanelWidthMeters();

  /**
   *
   *
   * <pre>
   * The expected lifetime, in years, of the solar panels. This is
   * used in the financial calculations.
   * </pre>
   *
   * <code>int32 panel_lifetime_years = 12;</code>
   *
   * @return The panelLifetimeYears.
   */
  int getPanelLifetimeYears();

  /**
   *
   *
   * <pre>
   * Size, in square meters, of the maximum array.
   * </pre>
   *
   * <code>float max_array_area_meters2 = 2;</code>
   *
   * @return The maxArrayAreaMeters2.
   */
  float getMaxArrayAreaMeters2();

  /**
   *
   *
   * <pre>
   * Maximum number of sunshine hours received per year, by any point
   * on the roof. Sunshine hours are a measure of the total amount of
   * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
   * (where kW refers to kW of capacity under Standard Testing Conditions).
   * </pre>
   *
   * <code>float max_sunshine_hours_per_year = 3;</code>
   *
   * @return The maxSunshineHoursPerYear.
   */
  float getMaxSunshineHoursPerYear();

  /**
   *
   *
   * <pre>
   * Equivalent amount of CO2 produced per MWh of grid electricity. This
   * is a measure of the carbon intensity of grid electricity displaced
   * by solar electricity.
   * </pre>
   *
   * <code>float carbon_offset_factor_kg_per_mwh = 4;</code>
   *
   * @return The carbonOffsetFactorKgPerMwh.
   */
  float getCarbonOffsetFactorKgPerMwh();

  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   *
   * @return Whether the wholeRoofStats field is set.
   */
  boolean hasWholeRoofStats();
  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   *
   * @return The wholeRoofStats.
   */
  com.google.maps.solar.v1.SizeAndSunshineStats getWholeRoofStats();
  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   */
  com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getWholeRoofStatsOrBuilder();

  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   *
   * @return Whether the buildingStats field is set.
   */
  boolean hasBuildingStats();
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   *
   * @return The buildingStats.
   */
  com.google.maps.solar.v1.SizeAndSunshineStats getBuildingStats();
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   */
  com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getBuildingStatsOrBuilder();

  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
      getRoofSegmentStatsList();
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats getRoofSegmentStats(int index);
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  int getRoofSegmentStatsCount();
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  java.util.List<? extends com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>
      getRoofSegmentStatsOrBuilderList();
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder getRoofSegmentStatsOrBuilder(
      int index);

  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  java.util.List<com.google.maps.solar.v1.SolarPanel> getSolarPanelsList();
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  com.google.maps.solar.v1.SolarPanel getSolarPanels(int index);
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  int getSolarPanelsCount();
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  java.util.List<? extends com.google.maps.solar.v1.SolarPanelOrBuilder>
      getSolarPanelsOrBuilderList();
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  com.google.maps.solar.v1.SolarPanelOrBuilder getSolarPanelsOrBuilder(int index);

  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  java.util.List<com.google.maps.solar.v1.SolarPanelConfig> getSolarPanelConfigsList();
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  com.google.maps.solar.v1.SolarPanelConfig getSolarPanelConfigs(int index);
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  int getSolarPanelConfigsCount();
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  java.util.List<? extends com.google.maps.solar.v1.SolarPanelConfigOrBuilder>
      getSolarPanelConfigsOrBuilderList();
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  com.google.maps.solar.v1.SolarPanelConfigOrBuilder getSolarPanelConfigsOrBuilder(int index);

  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  java.util.List<com.google.maps.solar.v1.FinancialAnalysis> getFinancialAnalysesList();
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  com.google.maps.solar.v1.FinancialAnalysis getFinancialAnalyses(int index);
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  int getFinancialAnalysesCount();
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  java.util.List<? extends com.google.maps.solar.v1.FinancialAnalysisOrBuilder>
      getFinancialAnalysesOrBuilderList();
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  com.google.maps.solar.v1.FinancialAnalysisOrBuilder getFinancialAnalysesOrBuilder(int index);
}
