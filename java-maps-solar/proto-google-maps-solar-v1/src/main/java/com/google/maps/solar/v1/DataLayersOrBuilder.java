/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/maps/solar/v1/solar_service.proto

// Protobuf Java Version: 3.25.3
package com.google.maps.solar.v1;

public interface DataLayersOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.maps.solar.v1.DataLayers)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * When the source imagery (from which all the other data are derived) in this
   * region was taken. It is necessarily somewhat approximate, as the images may
   * have been taken over more than one day.
   * </pre>
   *
   * <code>.google.type.Date imagery_date = 1;</code>
   *
   * @return Whether the imageryDate field is set.
   */
  boolean hasImageryDate();
  /**
   *
   *
   * <pre>
   * When the source imagery (from which all the other data are derived) in this
   * region was taken. It is necessarily somewhat approximate, as the images may
   * have been taken over more than one day.
   * </pre>
   *
   * <code>.google.type.Date imagery_date = 1;</code>
   *
   * @return The imageryDate.
   */
  com.google.type.Date getImageryDate();
  /**
   *
   *
   * <pre>
   * When the source imagery (from which all the other data are derived) in this
   * region was taken. It is necessarily somewhat approximate, as the images may
   * have been taken over more than one day.
   * </pre>
   *
   * <code>.google.type.Date imagery_date = 1;</code>
   */
  com.google.type.DateOrBuilder getImageryDateOrBuilder();

  /**
   *
   *
   * <pre>
   * When processing was completed on this imagery.
   * </pre>
   *
   * <code>.google.type.Date imagery_processed_date = 2;</code>
   *
   * @return Whether the imageryProcessedDate field is set.
   */
  boolean hasImageryProcessedDate();
  /**
   *
   *
   * <pre>
   * When processing was completed on this imagery.
   * </pre>
   *
   * <code>.google.type.Date imagery_processed_date = 2;</code>
   *
   * @return The imageryProcessedDate.
   */
  com.google.type.Date getImageryProcessedDate();
  /**
   *
   *
   * <pre>
   * When processing was completed on this imagery.
   * </pre>
   *
   * <code>.google.type.Date imagery_processed_date = 2;</code>
   */
  com.google.type.DateOrBuilder getImageryProcessedDateOrBuilder();

  /**
   *
   *
   * <pre>
   * The URL for an image of the DSM (Digital Surface Model) of the region.
   * Values are in meters above EGM96 geoid (i.e., sea level). Invalid locations
   * (where we don't have data) are stored as -9999.
   * </pre>
   *
   * <code>string dsm_url = 3;</code>
   *
   * @return The dsmUrl.
   */
  java.lang.String getDsmUrl();
  /**
   *
   *
   * <pre>
   * The URL for an image of the DSM (Digital Surface Model) of the region.
   * Values are in meters above EGM96 geoid (i.e., sea level). Invalid locations
   * (where we don't have data) are stored as -9999.
   * </pre>
   *
   * <code>string dsm_url = 3;</code>
   *
   * @return The bytes for dsmUrl.
   */
  com.google.protobuf.ByteString getDsmUrlBytes();

  /**
   *
   *
   * <pre>
   * The URL for an image of RGB data (aerial photo) of the region.
   * </pre>
   *
   * <code>string rgb_url = 4;</code>
   *
   * @return The rgbUrl.
   */
  java.lang.String getRgbUrl();
  /**
   *
   *
   * <pre>
   * The URL for an image of RGB data (aerial photo) of the region.
   * </pre>
   *
   * <code>string rgb_url = 4;</code>
   *
   * @return The bytes for rgbUrl.
   */
  com.google.protobuf.ByteString getRgbUrlBytes();

  /**
   *
   *
   * <pre>
   * The URL for the building mask image: one bit per pixel saying whether that
   * pixel is considered to be part of a rooftop or not.
   * </pre>
   *
   * <code>string mask_url = 5;</code>
   *
   * @return The maskUrl.
   */
  java.lang.String getMaskUrl();
  /**
   *
   *
   * <pre>
   * The URL for the building mask image: one bit per pixel saying whether that
   * pixel is considered to be part of a rooftop or not.
   * </pre>
   *
   * <code>string mask_url = 5;</code>
   *
   * @return The bytes for maskUrl.
   */
  com.google.protobuf.ByteString getMaskUrlBytes();

  /**
   *
   *
   * <pre>
   * The URL for the annual flux map (annual sunlight on roofs) of the region.
   * Values are kWh/kW/year. This is *unmasked flux*: flux is computed for every
   * location, not just building rooftops. Invalid locations are stored as
   * -9999: locations outside our coverage area will be invalid, and a few
   * locations inside the coverage area, where we were unable to calculate flux,
   * will also be invalid.
   * </pre>
   *
   * <code>string annual_flux_url = 6;</code>
   *
   * @return The annualFluxUrl.
   */
  java.lang.String getAnnualFluxUrl();
  /**
   *
   *
   * <pre>
   * The URL for the annual flux map (annual sunlight on roofs) of the region.
   * Values are kWh/kW/year. This is *unmasked flux*: flux is computed for every
   * location, not just building rooftops. Invalid locations are stored as
   * -9999: locations outside our coverage area will be invalid, and a few
   * locations inside the coverage area, where we were unable to calculate flux,
   * will also be invalid.
   * </pre>
   *
   * <code>string annual_flux_url = 6;</code>
   *
   * @return The bytes for annualFluxUrl.
   */
  com.google.protobuf.ByteString getAnnualFluxUrlBytes();

  /**
   *
   *
   * <pre>
   * The URL for the monthly flux map (sunlight on roofs, broken down by month)
   * of the region. Values are kWh/kW/year. The GeoTIFF pointed to by this URL
   * will contain twelve bands, corresponding to January...December, in order.
   * </pre>
   *
   * <code>string monthly_flux_url = 7;</code>
   *
   * @return The monthlyFluxUrl.
   */
  java.lang.String getMonthlyFluxUrl();
  /**
   *
   *
   * <pre>
   * The URL for the monthly flux map (sunlight on roofs, broken down by month)
   * of the region. Values are kWh/kW/year. The GeoTIFF pointed to by this URL
   * will contain twelve bands, corresponding to January...December, in order.
   * </pre>
   *
   * <code>string monthly_flux_url = 7;</code>
   *
   * @return The bytes for monthlyFluxUrl.
   */
  com.google.protobuf.ByteString getMonthlyFluxUrlBytes();

  /**
   *
   *
   * <pre>
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] &amp; (1 &lt;&lt; (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   * </pre>
   *
   * <code>repeated string hourly_shade_urls = 8;</code>
   *
   * @return A list containing the hourlyShadeUrls.
   */
  java.util.List<java.lang.String> getHourlyShadeUrlsList();
  /**
   *
   *
   * <pre>
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] &amp; (1 &lt;&lt; (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   * </pre>
   *
   * <code>repeated string hourly_shade_urls = 8;</code>
   *
   * @return The count of hourlyShadeUrls.
   */
  int getHourlyShadeUrlsCount();
  /**
   *
   *
   * <pre>
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] &amp; (1 &lt;&lt; (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   * </pre>
   *
   * <code>repeated string hourly_shade_urls = 8;</code>
   *
   * @param index The index of the element to return.
   * @return The hourlyShadeUrls at the given index.
   */
  java.lang.String getHourlyShadeUrls(int index);
  /**
   *
   *
   * <pre>
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] &amp; (1 &lt;&lt; (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   * </pre>
   *
   * <code>repeated string hourly_shade_urls = 8;</code>
   *
   * @param index The index of the value to return.
   * @return The bytes of the hourlyShadeUrls at the given index.
   */
  com.google.protobuf.ByteString getHourlyShadeUrlsBytes(int index);

  /**
   *
   *
   * <pre>
   * The quality of the result's imagery.
   * </pre>
   *
   * <code>.google.maps.solar.v1.ImageryQuality imagery_quality = 9;</code>
   *
   * @return The enum numeric value on the wire for imageryQuality.
   */
  int getImageryQualityValue();
  /**
   *
   *
   * <pre>
   * The quality of the result's imagery.
   * </pre>
   *
   * <code>.google.maps.solar.v1.ImageryQuality imagery_quality = 9;</code>
   *
   * @return The imageryQuality.
   */
  com.google.maps.solar.v1.ImageryQuality getImageryQuality();
}
