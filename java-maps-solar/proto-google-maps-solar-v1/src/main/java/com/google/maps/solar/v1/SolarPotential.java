/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/maps/solar/v1/solar_service.proto

// Protobuf Java Version: 3.25.3
package com.google.maps.solar.v1;

/**
 *
 *
 * <pre>
 * Information about the solar potential of a building. A number of
 * fields in this are defined in terms of "panels". The fields
 * [panel_capacity_watts]
 * [google.maps.solar.v1.SolarPotential.panel_capacity_watts],
 * [panel_height_meters]
 * [google.maps.solar.v1.SolarPotential.panel_height_meters],
 * and [panel_width_meters]
 * [google.maps.solar.v1.SolarPotential.panel_width_meters]
 * describe the parameters of the model of panel used in these
 * calculations.
 * </pre>
 *
 * Protobuf type {@code google.maps.solar.v1.SolarPotential}
 */
public final class SolarPotential extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.maps.solar.v1.SolarPotential)
    SolarPotentialOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use SolarPotential.newBuilder() to construct.
  private SolarPotential(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private SolarPotential() {
    roofSegmentStats_ = java.util.Collections.emptyList();
    solarPanels_ = java.util.Collections.emptyList();
    solarPanelConfigs_ = java.util.Collections.emptyList();
    financialAnalyses_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new SolarPotential();
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.maps.solar.v1.SolarServiceProto
        .internal_static_google_maps_solar_v1_SolarPotential_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.maps.solar.v1.SolarServiceProto
        .internal_static_google_maps_solar_v1_SolarPotential_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.maps.solar.v1.SolarPotential.class,
            com.google.maps.solar.v1.SolarPotential.Builder.class);
  }

  private int bitField0_;
  public static final int MAX_ARRAY_PANELS_COUNT_FIELD_NUMBER = 1;
  private int maxArrayPanelsCount_ = 0;
  /**
   *
   *
   * <pre>
   * Size of the maximum array - that is, the maximum number of panels that
   * can fit on the roof.
   * </pre>
   *
   * <code>int32 max_array_panels_count = 1;</code>
   *
   * @return The maxArrayPanelsCount.
   */
  @java.lang.Override
  public int getMaxArrayPanelsCount() {
    return maxArrayPanelsCount_;
  }

  public static final int PANEL_CAPACITY_WATTS_FIELD_NUMBER = 9;
  private float panelCapacityWatts_ = 0F;
  /**
   *
   *
   * <pre>
   * Capacity, in watts, of the panel used in the calculations.
   * </pre>
   *
   * <code>float panel_capacity_watts = 9;</code>
   *
   * @return The panelCapacityWatts.
   */
  @java.lang.Override
  public float getPanelCapacityWatts() {
    return panelCapacityWatts_;
  }

  public static final int PANEL_HEIGHT_METERS_FIELD_NUMBER = 10;
  private float panelHeightMeters_ = 0F;
  /**
   *
   *
   * <pre>
   * Height, in meters in portrait orientation, of the panel used in
   * the calculations.
   * </pre>
   *
   * <code>float panel_height_meters = 10;</code>
   *
   * @return The panelHeightMeters.
   */
  @java.lang.Override
  public float getPanelHeightMeters() {
    return panelHeightMeters_;
  }

  public static final int PANEL_WIDTH_METERS_FIELD_NUMBER = 11;
  private float panelWidthMeters_ = 0F;
  /**
   *
   *
   * <pre>
   * Width, in meters in portrait orientation, of the panel used in
   * the calculations.
   * </pre>
   *
   * <code>float panel_width_meters = 11;</code>
   *
   * @return The panelWidthMeters.
   */
  @java.lang.Override
  public float getPanelWidthMeters() {
    return panelWidthMeters_;
  }

  public static final int PANEL_LIFETIME_YEARS_FIELD_NUMBER = 12;
  private int panelLifetimeYears_ = 0;
  /**
   *
   *
   * <pre>
   * The expected lifetime, in years, of the solar panels. This is
   * used in the financial calculations.
   * </pre>
   *
   * <code>int32 panel_lifetime_years = 12;</code>
   *
   * @return The panelLifetimeYears.
   */
  @java.lang.Override
  public int getPanelLifetimeYears() {
    return panelLifetimeYears_;
  }

  public static final int MAX_ARRAY_AREA_METERS2_FIELD_NUMBER = 2;
  private float maxArrayAreaMeters2_ = 0F;
  /**
   *
   *
   * <pre>
   * Size, in square meters, of the maximum array.
   * </pre>
   *
   * <code>float max_array_area_meters2 = 2;</code>
   *
   * @return The maxArrayAreaMeters2.
   */
  @java.lang.Override
  public float getMaxArrayAreaMeters2() {
    return maxArrayAreaMeters2_;
  }

  public static final int MAX_SUNSHINE_HOURS_PER_YEAR_FIELD_NUMBER = 3;
  private float maxSunshineHoursPerYear_ = 0F;
  /**
   *
   *
   * <pre>
   * Maximum number of sunshine hours received per year, by any point
   * on the roof. Sunshine hours are a measure of the total amount of
   * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
   * (where kW refers to kW of capacity under Standard Testing Conditions).
   * </pre>
   *
   * <code>float max_sunshine_hours_per_year = 3;</code>
   *
   * @return The maxSunshineHoursPerYear.
   */
  @java.lang.Override
  public float getMaxSunshineHoursPerYear() {
    return maxSunshineHoursPerYear_;
  }

  public static final int CARBON_OFFSET_FACTOR_KG_PER_MWH_FIELD_NUMBER = 4;
  private float carbonOffsetFactorKgPerMwh_ = 0F;
  /**
   *
   *
   * <pre>
   * Equivalent amount of CO2 produced per MWh of grid electricity. This
   * is a measure of the carbon intensity of grid electricity displaced
   * by solar electricity.
   * </pre>
   *
   * <code>float carbon_offset_factor_kg_per_mwh = 4;</code>
   *
   * @return The carbonOffsetFactorKgPerMwh.
   */
  @java.lang.Override
  public float getCarbonOffsetFactorKgPerMwh() {
    return carbonOffsetFactorKgPerMwh_;
  }

  public static final int WHOLE_ROOF_STATS_FIELD_NUMBER = 5;
  private com.google.maps.solar.v1.SizeAndSunshineStats wholeRoofStats_;
  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   *
   * @return Whether the wholeRoofStats field is set.
   */
  @java.lang.Override
  public boolean hasWholeRoofStats() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   *
   * @return The wholeRoofStats.
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SizeAndSunshineStats getWholeRoofStats() {
    return wholeRoofStats_ == null
        ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
        : wholeRoofStats_;
  }
  /**
   *
   *
   * <pre>
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getWholeRoofStatsOrBuilder() {
    return wholeRoofStats_ == null
        ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
        : wholeRoofStats_;
  }

  public static final int BUILDING_STATS_FIELD_NUMBER = 13;
  private com.google.maps.solar.v1.SizeAndSunshineStats buildingStats_;
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   *
   * @return Whether the buildingStats field is set.
   */
  @java.lang.Override
  public boolean hasBuildingStats() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   *
   * @return The buildingStats.
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SizeAndSunshineStats getBuildingStats() {
    return buildingStats_ == null
        ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
        : buildingStats_;
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   * </pre>
   *
   * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getBuildingStatsOrBuilder() {
    return buildingStats_ == null
        ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
        : buildingStats_;
  }

  public static final int ROOF_SEGMENT_STATS_FIELD_NUMBER = 6;

  @SuppressWarnings("serial")
  private java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
      roofSegmentStats_;
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  @java.lang.Override
  public java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
      getRoofSegmentStatsList() {
    return roofSegmentStats_;
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>
      getRoofSegmentStatsOrBuilderList() {
    return roofSegmentStats_;
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  @java.lang.Override
  public int getRoofSegmentStatsCount() {
    return roofSegmentStats_.size();
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats getRoofSegmentStats(int index) {
    return roofSegmentStats_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Size and sunlight quantiles for each roof segment.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   * </code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder
      getRoofSegmentStatsOrBuilder(int index) {
    return roofSegmentStats_.get(index);
  }

  public static final int SOLAR_PANELS_FIELD_NUMBER = 14;

  @SuppressWarnings("serial")
  private java.util.List<com.google.maps.solar.v1.SolarPanel> solarPanels_;
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.maps.solar.v1.SolarPanel> getSolarPanelsList() {
    return solarPanels_;
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.maps.solar.v1.SolarPanelOrBuilder>
      getSolarPanelsOrBuilderList() {
    return solarPanels_;
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  @java.lang.Override
  public int getSolarPanelsCount() {
    return solarPanels_.size();
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SolarPanel getSolarPanels(int index) {
    return solarPanels_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SolarPanelOrBuilder getSolarPanelsOrBuilder(int index) {
    return solarPanels_.get(index);
  }

  public static final int SOLAR_PANEL_CONFIGS_FIELD_NUMBER = 7;

  @SuppressWarnings("serial")
  private java.util.List<com.google.maps.solar.v1.SolarPanelConfig> solarPanelConfigs_;
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.maps.solar.v1.SolarPanelConfig> getSolarPanelConfigsList() {
    return solarPanelConfigs_;
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.maps.solar.v1.SolarPanelConfigOrBuilder>
      getSolarPanelConfigsOrBuilderList() {
    return solarPanelConfigs_;
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  @java.lang.Override
  public int getSolarPanelConfigsCount() {
    return solarPanelConfigs_.size();
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SolarPanelConfig getSolarPanelConfigs(int index) {
    return solarPanelConfigs_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.SolarPanelConfigOrBuilder getSolarPanelConfigsOrBuilder(
      int index) {
    return solarPanelConfigs_.get(index);
  }

  public static final int FINANCIAL_ANALYSES_FIELD_NUMBER = 8;

  @SuppressWarnings("serial")
  private java.util.List<com.google.maps.solar.v1.FinancialAnalysis> financialAnalyses_;
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.maps.solar.v1.FinancialAnalysis> getFinancialAnalysesList() {
    return financialAnalyses_;
  }
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  @java.lang.Override
  public java.util.List<? extends com.google.maps.solar.v1.FinancialAnalysisOrBuilder>
      getFinancialAnalysesOrBuilderList() {
    return financialAnalyses_;
  }
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  @java.lang.Override
  public int getFinancialAnalysesCount() {
    return financialAnalyses_.size();
  }
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.FinancialAnalysis getFinancialAnalyses(int index) {
    return financialAnalyses_.get(index);
  }
  /**
   *
   *
   * <pre>
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   * </pre>
   *
   * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
   */
  @java.lang.Override
  public com.google.maps.solar.v1.FinancialAnalysisOrBuilder getFinancialAnalysesOrBuilder(
      int index) {
    return financialAnalyses_.get(index);
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (maxArrayPanelsCount_ != 0) {
      output.writeInt32(1, maxArrayPanelsCount_);
    }
    if (java.lang.Float.floatToRawIntBits(maxArrayAreaMeters2_) != 0) {
      output.writeFloat(2, maxArrayAreaMeters2_);
    }
    if (java.lang.Float.floatToRawIntBits(maxSunshineHoursPerYear_) != 0) {
      output.writeFloat(3, maxSunshineHoursPerYear_);
    }
    if (java.lang.Float.floatToRawIntBits(carbonOffsetFactorKgPerMwh_) != 0) {
      output.writeFloat(4, carbonOffsetFactorKgPerMwh_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeMessage(5, getWholeRoofStats());
    }
    for (int i = 0; i < roofSegmentStats_.size(); i++) {
      output.writeMessage(6, roofSegmentStats_.get(i));
    }
    for (int i = 0; i < solarPanelConfigs_.size(); i++) {
      output.writeMessage(7, solarPanelConfigs_.get(i));
    }
    for (int i = 0; i < financialAnalyses_.size(); i++) {
      output.writeMessage(8, financialAnalyses_.get(i));
    }
    if (java.lang.Float.floatToRawIntBits(panelCapacityWatts_) != 0) {
      output.writeFloat(9, panelCapacityWatts_);
    }
    if (java.lang.Float.floatToRawIntBits(panelHeightMeters_) != 0) {
      output.writeFloat(10, panelHeightMeters_);
    }
    if (java.lang.Float.floatToRawIntBits(panelWidthMeters_) != 0) {
      output.writeFloat(11, panelWidthMeters_);
    }
    if (panelLifetimeYears_ != 0) {
      output.writeInt32(12, panelLifetimeYears_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeMessage(13, getBuildingStats());
    }
    for (int i = 0; i < solarPanels_.size(); i++) {
      output.writeMessage(14, solarPanels_.get(i));
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (maxArrayPanelsCount_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, maxArrayPanelsCount_);
    }
    if (java.lang.Float.floatToRawIntBits(maxArrayAreaMeters2_) != 0) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(2, maxArrayAreaMeters2_);
    }
    if (java.lang.Float.floatToRawIntBits(maxSunshineHoursPerYear_) != 0) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(3, maxSunshineHoursPerYear_);
    }
    if (java.lang.Float.floatToRawIntBits(carbonOffsetFactorKgPerMwh_) != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeFloatSize(4, carbonOffsetFactorKgPerMwh_);
    }
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getWholeRoofStats());
    }
    for (int i = 0; i < roofSegmentStats_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, roofSegmentStats_.get(i));
    }
    for (int i = 0; i < solarPanelConfigs_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(7, solarPanelConfigs_.get(i));
    }
    for (int i = 0; i < financialAnalyses_.size(); i++) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(8, financialAnalyses_.get(i));
    }
    if (java.lang.Float.floatToRawIntBits(panelCapacityWatts_) != 0) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(9, panelCapacityWatts_);
    }
    if (java.lang.Float.floatToRawIntBits(panelHeightMeters_) != 0) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(10, panelHeightMeters_);
    }
    if (java.lang.Float.floatToRawIntBits(panelWidthMeters_) != 0) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(11, panelWidthMeters_);
    }
    if (panelLifetimeYears_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(12, panelLifetimeYears_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(13, getBuildingStats());
    }
    for (int i = 0; i < solarPanels_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(14, solarPanels_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.maps.solar.v1.SolarPotential)) {
      return super.equals(obj);
    }
    com.google.maps.solar.v1.SolarPotential other = (com.google.maps.solar.v1.SolarPotential) obj;

    if (getMaxArrayPanelsCount() != other.getMaxArrayPanelsCount()) return false;
    if (java.lang.Float.floatToIntBits(getPanelCapacityWatts())
        != java.lang.Float.floatToIntBits(other.getPanelCapacityWatts())) return false;
    if (java.lang.Float.floatToIntBits(getPanelHeightMeters())
        != java.lang.Float.floatToIntBits(other.getPanelHeightMeters())) return false;
    if (java.lang.Float.floatToIntBits(getPanelWidthMeters())
        != java.lang.Float.floatToIntBits(other.getPanelWidthMeters())) return false;
    if (getPanelLifetimeYears() != other.getPanelLifetimeYears()) return false;
    if (java.lang.Float.floatToIntBits(getMaxArrayAreaMeters2())
        != java.lang.Float.floatToIntBits(other.getMaxArrayAreaMeters2())) return false;
    if (java.lang.Float.floatToIntBits(getMaxSunshineHoursPerYear())
        != java.lang.Float.floatToIntBits(other.getMaxSunshineHoursPerYear())) return false;
    if (java.lang.Float.floatToIntBits(getCarbonOffsetFactorKgPerMwh())
        != java.lang.Float.floatToIntBits(other.getCarbonOffsetFactorKgPerMwh())) return false;
    if (hasWholeRoofStats() != other.hasWholeRoofStats()) return false;
    if (hasWholeRoofStats()) {
      if (!getWholeRoofStats().equals(other.getWholeRoofStats())) return false;
    }
    if (hasBuildingStats() != other.hasBuildingStats()) return false;
    if (hasBuildingStats()) {
      if (!getBuildingStats().equals(other.getBuildingStats())) return false;
    }
    if (!getRoofSegmentStatsList().equals(other.getRoofSegmentStatsList())) return false;
    if (!getSolarPanelsList().equals(other.getSolarPanelsList())) return false;
    if (!getSolarPanelConfigsList().equals(other.getSolarPanelConfigsList())) return false;
    if (!getFinancialAnalysesList().equals(other.getFinancialAnalysesList())) return false;
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + MAX_ARRAY_PANELS_COUNT_FIELD_NUMBER;
    hash = (53 * hash) + getMaxArrayPanelsCount();
    hash = (37 * hash) + PANEL_CAPACITY_WATTS_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getPanelCapacityWatts());
    hash = (37 * hash) + PANEL_HEIGHT_METERS_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getPanelHeightMeters());
    hash = (37 * hash) + PANEL_WIDTH_METERS_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getPanelWidthMeters());
    hash = (37 * hash) + PANEL_LIFETIME_YEARS_FIELD_NUMBER;
    hash = (53 * hash) + getPanelLifetimeYears();
    hash = (37 * hash) + MAX_ARRAY_AREA_METERS2_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getMaxArrayAreaMeters2());
    hash = (37 * hash) + MAX_SUNSHINE_HOURS_PER_YEAR_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getMaxSunshineHoursPerYear());
    hash = (37 * hash) + CARBON_OFFSET_FACTOR_KG_PER_MWH_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getCarbonOffsetFactorKgPerMwh());
    if (hasWholeRoofStats()) {
      hash = (37 * hash) + WHOLE_ROOF_STATS_FIELD_NUMBER;
      hash = (53 * hash) + getWholeRoofStats().hashCode();
    }
    if (hasBuildingStats()) {
      hash = (37 * hash) + BUILDING_STATS_FIELD_NUMBER;
      hash = (53 * hash) + getBuildingStats().hashCode();
    }
    if (getRoofSegmentStatsCount() > 0) {
      hash = (37 * hash) + ROOF_SEGMENT_STATS_FIELD_NUMBER;
      hash = (53 * hash) + getRoofSegmentStatsList().hashCode();
    }
    if (getSolarPanelsCount() > 0) {
      hash = (37 * hash) + SOLAR_PANELS_FIELD_NUMBER;
      hash = (53 * hash) + getSolarPanelsList().hashCode();
    }
    if (getSolarPanelConfigsCount() > 0) {
      hash = (37 * hash) + SOLAR_PANEL_CONFIGS_FIELD_NUMBER;
      hash = (53 * hash) + getSolarPanelConfigsList().hashCode();
    }
    if (getFinancialAnalysesCount() > 0) {
      hash = (37 * hash) + FINANCIAL_ANALYSES_FIELD_NUMBER;
      hash = (53 * hash) + getFinancialAnalysesList().hashCode();
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.maps.solar.v1.SolarPotential parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.maps.solar.v1.SolarPotential parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.maps.solar.v1.SolarPotential parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.maps.solar.v1.SolarPotential prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Information about the solar potential of a building. A number of
   * fields in this are defined in terms of "panels". The fields
   * [panel_capacity_watts]
   * [google.maps.solar.v1.SolarPotential.panel_capacity_watts],
   * [panel_height_meters]
   * [google.maps.solar.v1.SolarPotential.panel_height_meters],
   * and [panel_width_meters]
   * [google.maps.solar.v1.SolarPotential.panel_width_meters]
   * describe the parameters of the model of panel used in these
   * calculations.
   * </pre>
   *
   * Protobuf type {@code google.maps.solar.v1.SolarPotential}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.maps.solar.v1.SolarPotential)
      com.google.maps.solar.v1.SolarPotentialOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.maps.solar.v1.SolarServiceProto
          .internal_static_google_maps_solar_v1_SolarPotential_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.maps.solar.v1.SolarServiceProto
          .internal_static_google_maps_solar_v1_SolarPotential_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.maps.solar.v1.SolarPotential.class,
              com.google.maps.solar.v1.SolarPotential.Builder.class);
    }

    // Construct using com.google.maps.solar.v1.SolarPotential.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
        getWholeRoofStatsFieldBuilder();
        getBuildingStatsFieldBuilder();
        getRoofSegmentStatsFieldBuilder();
        getSolarPanelsFieldBuilder();
        getSolarPanelConfigsFieldBuilder();
        getFinancialAnalysesFieldBuilder();
      }
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      maxArrayPanelsCount_ = 0;
      panelCapacityWatts_ = 0F;
      panelHeightMeters_ = 0F;
      panelWidthMeters_ = 0F;
      panelLifetimeYears_ = 0;
      maxArrayAreaMeters2_ = 0F;
      maxSunshineHoursPerYear_ = 0F;
      carbonOffsetFactorKgPerMwh_ = 0F;
      wholeRoofStats_ = null;
      if (wholeRoofStatsBuilder_ != null) {
        wholeRoofStatsBuilder_.dispose();
        wholeRoofStatsBuilder_ = null;
      }
      buildingStats_ = null;
      if (buildingStatsBuilder_ != null) {
        buildingStatsBuilder_.dispose();
        buildingStatsBuilder_ = null;
      }
      if (roofSegmentStatsBuilder_ == null) {
        roofSegmentStats_ = java.util.Collections.emptyList();
      } else {
        roofSegmentStats_ = null;
        roofSegmentStatsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000400);
      if (solarPanelsBuilder_ == null) {
        solarPanels_ = java.util.Collections.emptyList();
      } else {
        solarPanels_ = null;
        solarPanelsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000800);
      if (solarPanelConfigsBuilder_ == null) {
        solarPanelConfigs_ = java.util.Collections.emptyList();
      } else {
        solarPanelConfigs_ = null;
        solarPanelConfigsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00001000);
      if (financialAnalysesBuilder_ == null) {
        financialAnalyses_ = java.util.Collections.emptyList();
      } else {
        financialAnalyses_ = null;
        financialAnalysesBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00002000);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.maps.solar.v1.SolarServiceProto
          .internal_static_google_maps_solar_v1_SolarPotential_descriptor;
    }

    @java.lang.Override
    public com.google.maps.solar.v1.SolarPotential getDefaultInstanceForType() {
      return com.google.maps.solar.v1.SolarPotential.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.maps.solar.v1.SolarPotential build() {
      com.google.maps.solar.v1.SolarPotential result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.maps.solar.v1.SolarPotential buildPartial() {
      com.google.maps.solar.v1.SolarPotential result =
          new com.google.maps.solar.v1.SolarPotential(this);
      buildPartialRepeatedFields(result);
      if (bitField0_ != 0) {
        buildPartial0(result);
      }
      onBuilt();
      return result;
    }

    private void buildPartialRepeatedFields(com.google.maps.solar.v1.SolarPotential result) {
      if (roofSegmentStatsBuilder_ == null) {
        if (((bitField0_ & 0x00000400) != 0)) {
          roofSegmentStats_ = java.util.Collections.unmodifiableList(roofSegmentStats_);
          bitField0_ = (bitField0_ & ~0x00000400);
        }
        result.roofSegmentStats_ = roofSegmentStats_;
      } else {
        result.roofSegmentStats_ = roofSegmentStatsBuilder_.build();
      }
      if (solarPanelsBuilder_ == null) {
        if (((bitField0_ & 0x00000800) != 0)) {
          solarPanels_ = java.util.Collections.unmodifiableList(solarPanels_);
          bitField0_ = (bitField0_ & ~0x00000800);
        }
        result.solarPanels_ = solarPanels_;
      } else {
        result.solarPanels_ = solarPanelsBuilder_.build();
      }
      if (solarPanelConfigsBuilder_ == null) {
        if (((bitField0_ & 0x00001000) != 0)) {
          solarPanelConfigs_ = java.util.Collections.unmodifiableList(solarPanelConfigs_);
          bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.solarPanelConfigs_ = solarPanelConfigs_;
      } else {
        result.solarPanelConfigs_ = solarPanelConfigsBuilder_.build();
      }
      if (financialAnalysesBuilder_ == null) {
        if (((bitField0_ & 0x00002000) != 0)) {
          financialAnalyses_ = java.util.Collections.unmodifiableList(financialAnalyses_);
          bitField0_ = (bitField0_ & ~0x00002000);
        }
        result.financialAnalyses_ = financialAnalyses_;
      } else {
        result.financialAnalyses_ = financialAnalysesBuilder_.build();
      }
    }

    private void buildPartial0(com.google.maps.solar.v1.SolarPotential result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.maxArrayPanelsCount_ = maxArrayPanelsCount_;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.panelCapacityWatts_ = panelCapacityWatts_;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.panelHeightMeters_ = panelHeightMeters_;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.panelWidthMeters_ = panelWidthMeters_;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.panelLifetimeYears_ = panelLifetimeYears_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.maxArrayAreaMeters2_ = maxArrayAreaMeters2_;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.maxSunshineHoursPerYear_ = maxSunshineHoursPerYear_;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.carbonOffsetFactorKgPerMwh_ = carbonOffsetFactorKgPerMwh_;
      }
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.wholeRoofStats_ =
            wholeRoofStatsBuilder_ == null ? wholeRoofStats_ : wholeRoofStatsBuilder_.build();
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.buildingStats_ =
            buildingStatsBuilder_ == null ? buildingStats_ : buildingStatsBuilder_.build();
        to_bitField0_ |= 0x00000002;
      }
      result.bitField0_ |= to_bitField0_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.maps.solar.v1.SolarPotential) {
        return mergeFrom((com.google.maps.solar.v1.SolarPotential) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.maps.solar.v1.SolarPotential other) {
      if (other == com.google.maps.solar.v1.SolarPotential.getDefaultInstance()) return this;
      if (other.getMaxArrayPanelsCount() != 0) {
        setMaxArrayPanelsCount(other.getMaxArrayPanelsCount());
      }
      if (other.getPanelCapacityWatts() != 0F) {
        setPanelCapacityWatts(other.getPanelCapacityWatts());
      }
      if (other.getPanelHeightMeters() != 0F) {
        setPanelHeightMeters(other.getPanelHeightMeters());
      }
      if (other.getPanelWidthMeters() != 0F) {
        setPanelWidthMeters(other.getPanelWidthMeters());
      }
      if (other.getPanelLifetimeYears() != 0) {
        setPanelLifetimeYears(other.getPanelLifetimeYears());
      }
      if (other.getMaxArrayAreaMeters2() != 0F) {
        setMaxArrayAreaMeters2(other.getMaxArrayAreaMeters2());
      }
      if (other.getMaxSunshineHoursPerYear() != 0F) {
        setMaxSunshineHoursPerYear(other.getMaxSunshineHoursPerYear());
      }
      if (other.getCarbonOffsetFactorKgPerMwh() != 0F) {
        setCarbonOffsetFactorKgPerMwh(other.getCarbonOffsetFactorKgPerMwh());
      }
      if (other.hasWholeRoofStats()) {
        mergeWholeRoofStats(other.getWholeRoofStats());
      }
      if (other.hasBuildingStats()) {
        mergeBuildingStats(other.getBuildingStats());
      }
      if (roofSegmentStatsBuilder_ == null) {
        if (!other.roofSegmentStats_.isEmpty()) {
          if (roofSegmentStats_.isEmpty()) {
            roofSegmentStats_ = other.roofSegmentStats_;
            bitField0_ = (bitField0_ & ~0x00000400);
          } else {
            ensureRoofSegmentStatsIsMutable();
            roofSegmentStats_.addAll(other.roofSegmentStats_);
          }
          onChanged();
        }
      } else {
        if (!other.roofSegmentStats_.isEmpty()) {
          if (roofSegmentStatsBuilder_.isEmpty()) {
            roofSegmentStatsBuilder_.dispose();
            roofSegmentStatsBuilder_ = null;
            roofSegmentStats_ = other.roofSegmentStats_;
            bitField0_ = (bitField0_ & ~0x00000400);
            roofSegmentStatsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getRoofSegmentStatsFieldBuilder()
                    : null;
          } else {
            roofSegmentStatsBuilder_.addAllMessages(other.roofSegmentStats_);
          }
        }
      }
      if (solarPanelsBuilder_ == null) {
        if (!other.solarPanels_.isEmpty()) {
          if (solarPanels_.isEmpty()) {
            solarPanels_ = other.solarPanels_;
            bitField0_ = (bitField0_ & ~0x00000800);
          } else {
            ensureSolarPanelsIsMutable();
            solarPanels_.addAll(other.solarPanels_);
          }
          onChanged();
        }
      } else {
        if (!other.solarPanels_.isEmpty()) {
          if (solarPanelsBuilder_.isEmpty()) {
            solarPanelsBuilder_.dispose();
            solarPanelsBuilder_ = null;
            solarPanels_ = other.solarPanels_;
            bitField0_ = (bitField0_ & ~0x00000800);
            solarPanelsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getSolarPanelsFieldBuilder()
                    : null;
          } else {
            solarPanelsBuilder_.addAllMessages(other.solarPanels_);
          }
        }
      }
      if (solarPanelConfigsBuilder_ == null) {
        if (!other.solarPanelConfigs_.isEmpty()) {
          if (solarPanelConfigs_.isEmpty()) {
            solarPanelConfigs_ = other.solarPanelConfigs_;
            bitField0_ = (bitField0_ & ~0x00001000);
          } else {
            ensureSolarPanelConfigsIsMutable();
            solarPanelConfigs_.addAll(other.solarPanelConfigs_);
          }
          onChanged();
        }
      } else {
        if (!other.solarPanelConfigs_.isEmpty()) {
          if (solarPanelConfigsBuilder_.isEmpty()) {
            solarPanelConfigsBuilder_.dispose();
            solarPanelConfigsBuilder_ = null;
            solarPanelConfigs_ = other.solarPanelConfigs_;
            bitField0_ = (bitField0_ & ~0x00001000);
            solarPanelConfigsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getSolarPanelConfigsFieldBuilder()
                    : null;
          } else {
            solarPanelConfigsBuilder_.addAllMessages(other.solarPanelConfigs_);
          }
        }
      }
      if (financialAnalysesBuilder_ == null) {
        if (!other.financialAnalyses_.isEmpty()) {
          if (financialAnalyses_.isEmpty()) {
            financialAnalyses_ = other.financialAnalyses_;
            bitField0_ = (bitField0_ & ~0x00002000);
          } else {
            ensureFinancialAnalysesIsMutable();
            financialAnalyses_.addAll(other.financialAnalyses_);
          }
          onChanged();
        }
      } else {
        if (!other.financialAnalyses_.isEmpty()) {
          if (financialAnalysesBuilder_.isEmpty()) {
            financialAnalysesBuilder_.dispose();
            financialAnalysesBuilder_ = null;
            financialAnalyses_ = other.financialAnalyses_;
            bitField0_ = (bitField0_ & ~0x00002000);
            financialAnalysesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                    ? getFinancialAnalysesFieldBuilder()
                    : null;
          } else {
            financialAnalysesBuilder_.addAllMessages(other.financialAnalyses_);
          }
        }
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                maxArrayPanelsCount_ = input.readInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
            case 21:
              {
                maxArrayAreaMeters2_ = input.readFloat();
                bitField0_ |= 0x00000020;
                break;
              } // case 21
            case 29:
              {
                maxSunshineHoursPerYear_ = input.readFloat();
                bitField0_ |= 0x00000040;
                break;
              } // case 29
            case 37:
              {
                carbonOffsetFactorKgPerMwh_ = input.readFloat();
                bitField0_ |= 0x00000080;
                break;
              } // case 37
            case 42:
              {
                input.readMessage(getWholeRoofStatsFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 42
            case 50:
              {
                com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats m =
                    input.readMessage(
                        com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.parser(),
                        extensionRegistry);
                if (roofSegmentStatsBuilder_ == null) {
                  ensureRoofSegmentStatsIsMutable();
                  roofSegmentStats_.add(m);
                } else {
                  roofSegmentStatsBuilder_.addMessage(m);
                }
                break;
              } // case 50
            case 58:
              {
                com.google.maps.solar.v1.SolarPanelConfig m =
                    input.readMessage(
                        com.google.maps.solar.v1.SolarPanelConfig.parser(), extensionRegistry);
                if (solarPanelConfigsBuilder_ == null) {
                  ensureSolarPanelConfigsIsMutable();
                  solarPanelConfigs_.add(m);
                } else {
                  solarPanelConfigsBuilder_.addMessage(m);
                }
                break;
              } // case 58
            case 66:
              {
                com.google.maps.solar.v1.FinancialAnalysis m =
                    input.readMessage(
                        com.google.maps.solar.v1.FinancialAnalysis.parser(), extensionRegistry);
                if (financialAnalysesBuilder_ == null) {
                  ensureFinancialAnalysesIsMutable();
                  financialAnalyses_.add(m);
                } else {
                  financialAnalysesBuilder_.addMessage(m);
                }
                break;
              } // case 66
            case 77:
              {
                panelCapacityWatts_ = input.readFloat();
                bitField0_ |= 0x00000002;
                break;
              } // case 77
            case 85:
              {
                panelHeightMeters_ = input.readFloat();
                bitField0_ |= 0x00000004;
                break;
              } // case 85
            case 93:
              {
                panelWidthMeters_ = input.readFloat();
                bitField0_ |= 0x00000008;
                break;
              } // case 93
            case 96:
              {
                panelLifetimeYears_ = input.readInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 96
            case 106:
              {
                input.readMessage(getBuildingStatsFieldBuilder().getBuilder(), extensionRegistry);
                bitField0_ |= 0x00000200;
                break;
              } // case 106
            case 114:
              {
                com.google.maps.solar.v1.SolarPanel m =
                    input.readMessage(
                        com.google.maps.solar.v1.SolarPanel.parser(), extensionRegistry);
                if (solarPanelsBuilder_ == null) {
                  ensureSolarPanelsIsMutable();
                  solarPanels_.add(m);
                } else {
                  solarPanelsBuilder_.addMessage(m);
                }
                break;
              } // case 114
            default:
              {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }

    private int bitField0_;

    private int maxArrayPanelsCount_;
    /**
     *
     *
     * <pre>
     * Size of the maximum array - that is, the maximum number of panels that
     * can fit on the roof.
     * </pre>
     *
     * <code>int32 max_array_panels_count = 1;</code>
     *
     * @return The maxArrayPanelsCount.
     */
    @java.lang.Override
    public int getMaxArrayPanelsCount() {
      return maxArrayPanelsCount_;
    }
    /**
     *
     *
     * <pre>
     * Size of the maximum array - that is, the maximum number of panels that
     * can fit on the roof.
     * </pre>
     *
     * <code>int32 max_array_panels_count = 1;</code>
     *
     * @param value The maxArrayPanelsCount to set.
     * @return This builder for chaining.
     */
    public Builder setMaxArrayPanelsCount(int value) {

      maxArrayPanelsCount_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size of the maximum array - that is, the maximum number of panels that
     * can fit on the roof.
     * </pre>
     *
     * <code>int32 max_array_panels_count = 1;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxArrayPanelsCount() {
      bitField0_ = (bitField0_ & ~0x00000001);
      maxArrayPanelsCount_ = 0;
      onChanged();
      return this;
    }

    private float panelCapacityWatts_;
    /**
     *
     *
     * <pre>
     * Capacity, in watts, of the panel used in the calculations.
     * </pre>
     *
     * <code>float panel_capacity_watts = 9;</code>
     *
     * @return The panelCapacityWatts.
     */
    @java.lang.Override
    public float getPanelCapacityWatts() {
      return panelCapacityWatts_;
    }
    /**
     *
     *
     * <pre>
     * Capacity, in watts, of the panel used in the calculations.
     * </pre>
     *
     * <code>float panel_capacity_watts = 9;</code>
     *
     * @param value The panelCapacityWatts to set.
     * @return This builder for chaining.
     */
    public Builder setPanelCapacityWatts(float value) {

      panelCapacityWatts_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Capacity, in watts, of the panel used in the calculations.
     * </pre>
     *
     * <code>float panel_capacity_watts = 9;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPanelCapacityWatts() {
      bitField0_ = (bitField0_ & ~0x00000002);
      panelCapacityWatts_ = 0F;
      onChanged();
      return this;
    }

    private float panelHeightMeters_;
    /**
     *
     *
     * <pre>
     * Height, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_height_meters = 10;</code>
     *
     * @return The panelHeightMeters.
     */
    @java.lang.Override
    public float getPanelHeightMeters() {
      return panelHeightMeters_;
    }
    /**
     *
     *
     * <pre>
     * Height, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_height_meters = 10;</code>
     *
     * @param value The panelHeightMeters to set.
     * @return This builder for chaining.
     */
    public Builder setPanelHeightMeters(float value) {

      panelHeightMeters_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Height, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_height_meters = 10;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPanelHeightMeters() {
      bitField0_ = (bitField0_ & ~0x00000004);
      panelHeightMeters_ = 0F;
      onChanged();
      return this;
    }

    private float panelWidthMeters_;
    /**
     *
     *
     * <pre>
     * Width, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_width_meters = 11;</code>
     *
     * @return The panelWidthMeters.
     */
    @java.lang.Override
    public float getPanelWidthMeters() {
      return panelWidthMeters_;
    }
    /**
     *
     *
     * <pre>
     * Width, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_width_meters = 11;</code>
     *
     * @param value The panelWidthMeters to set.
     * @return This builder for chaining.
     */
    public Builder setPanelWidthMeters(float value) {

      panelWidthMeters_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Width, in meters in portrait orientation, of the panel used in
     * the calculations.
     * </pre>
     *
     * <code>float panel_width_meters = 11;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPanelWidthMeters() {
      bitField0_ = (bitField0_ & ~0x00000008);
      panelWidthMeters_ = 0F;
      onChanged();
      return this;
    }

    private int panelLifetimeYears_;
    /**
     *
     *
     * <pre>
     * The expected lifetime, in years, of the solar panels. This is
     * used in the financial calculations.
     * </pre>
     *
     * <code>int32 panel_lifetime_years = 12;</code>
     *
     * @return The panelLifetimeYears.
     */
    @java.lang.Override
    public int getPanelLifetimeYears() {
      return panelLifetimeYears_;
    }
    /**
     *
     *
     * <pre>
     * The expected lifetime, in years, of the solar panels. This is
     * used in the financial calculations.
     * </pre>
     *
     * <code>int32 panel_lifetime_years = 12;</code>
     *
     * @param value The panelLifetimeYears to set.
     * @return This builder for chaining.
     */
    public Builder setPanelLifetimeYears(int value) {

      panelLifetimeYears_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The expected lifetime, in years, of the solar panels. This is
     * used in the financial calculations.
     * </pre>
     *
     * <code>int32 panel_lifetime_years = 12;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPanelLifetimeYears() {
      bitField0_ = (bitField0_ & ~0x00000010);
      panelLifetimeYears_ = 0;
      onChanged();
      return this;
    }

    private float maxArrayAreaMeters2_;
    /**
     *
     *
     * <pre>
     * Size, in square meters, of the maximum array.
     * </pre>
     *
     * <code>float max_array_area_meters2 = 2;</code>
     *
     * @return The maxArrayAreaMeters2.
     */
    @java.lang.Override
    public float getMaxArrayAreaMeters2() {
      return maxArrayAreaMeters2_;
    }
    /**
     *
     *
     * <pre>
     * Size, in square meters, of the maximum array.
     * </pre>
     *
     * <code>float max_array_area_meters2 = 2;</code>
     *
     * @param value The maxArrayAreaMeters2 to set.
     * @return This builder for chaining.
     */
    public Builder setMaxArrayAreaMeters2(float value) {

      maxArrayAreaMeters2_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size, in square meters, of the maximum array.
     * </pre>
     *
     * <code>float max_array_area_meters2 = 2;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxArrayAreaMeters2() {
      bitField0_ = (bitField0_ & ~0x00000020);
      maxArrayAreaMeters2_ = 0F;
      onChanged();
      return this;
    }

    private float maxSunshineHoursPerYear_;
    /**
     *
     *
     * <pre>
     * Maximum number of sunshine hours received per year, by any point
     * on the roof. Sunshine hours are a measure of the total amount of
     * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
     * (where kW refers to kW of capacity under Standard Testing Conditions).
     * </pre>
     *
     * <code>float max_sunshine_hours_per_year = 3;</code>
     *
     * @return The maxSunshineHoursPerYear.
     */
    @java.lang.Override
    public float getMaxSunshineHoursPerYear() {
      return maxSunshineHoursPerYear_;
    }
    /**
     *
     *
     * <pre>
     * Maximum number of sunshine hours received per year, by any point
     * on the roof. Sunshine hours are a measure of the total amount of
     * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
     * (where kW refers to kW of capacity under Standard Testing Conditions).
     * </pre>
     *
     * <code>float max_sunshine_hours_per_year = 3;</code>
     *
     * @param value The maxSunshineHoursPerYear to set.
     * @return This builder for chaining.
     */
    public Builder setMaxSunshineHoursPerYear(float value) {

      maxSunshineHoursPerYear_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Maximum number of sunshine hours received per year, by any point
     * on the roof. Sunshine hours are a measure of the total amount of
     * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
     * (where kW refers to kW of capacity under Standard Testing Conditions).
     * </pre>
     *
     * <code>float max_sunshine_hours_per_year = 3;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxSunshineHoursPerYear() {
      bitField0_ = (bitField0_ & ~0x00000040);
      maxSunshineHoursPerYear_ = 0F;
      onChanged();
      return this;
    }

    private float carbonOffsetFactorKgPerMwh_;
    /**
     *
     *
     * <pre>
     * Equivalent amount of CO2 produced per MWh of grid electricity. This
     * is a measure of the carbon intensity of grid electricity displaced
     * by solar electricity.
     * </pre>
     *
     * <code>float carbon_offset_factor_kg_per_mwh = 4;</code>
     *
     * @return The carbonOffsetFactorKgPerMwh.
     */
    @java.lang.Override
    public float getCarbonOffsetFactorKgPerMwh() {
      return carbonOffsetFactorKgPerMwh_;
    }
    /**
     *
     *
     * <pre>
     * Equivalent amount of CO2 produced per MWh of grid electricity. This
     * is a measure of the carbon intensity of grid electricity displaced
     * by solar electricity.
     * </pre>
     *
     * <code>float carbon_offset_factor_kg_per_mwh = 4;</code>
     *
     * @param value The carbonOffsetFactorKgPerMwh to set.
     * @return This builder for chaining.
     */
    public Builder setCarbonOffsetFactorKgPerMwh(float value) {

      carbonOffsetFactorKgPerMwh_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Equivalent amount of CO2 produced per MWh of grid electricity. This
     * is a measure of the carbon intensity of grid electricity displaced
     * by solar electricity.
     * </pre>
     *
     * <code>float carbon_offset_factor_kg_per_mwh = 4;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCarbonOffsetFactorKgPerMwh() {
      bitField0_ = (bitField0_ & ~0x00000080);
      carbonOffsetFactorKgPerMwh_ = 0F;
      onChanged();
      return this;
    }

    private com.google.maps.solar.v1.SizeAndSunshineStats wholeRoofStats_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.maps.solar.v1.SizeAndSunshineStats,
            com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>
        wholeRoofStatsBuilder_;
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     *
     * @return Whether the wholeRoofStats field is set.
     */
    public boolean hasWholeRoofStats() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     *
     * @return The wholeRoofStats.
     */
    public com.google.maps.solar.v1.SizeAndSunshineStats getWholeRoofStats() {
      if (wholeRoofStatsBuilder_ == null) {
        return wholeRoofStats_ == null
            ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
            : wholeRoofStats_;
      } else {
        return wholeRoofStatsBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public Builder setWholeRoofStats(com.google.maps.solar.v1.SizeAndSunshineStats value) {
      if (wholeRoofStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        wholeRoofStats_ = value;
      } else {
        wholeRoofStatsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public Builder setWholeRoofStats(
        com.google.maps.solar.v1.SizeAndSunshineStats.Builder builderForValue) {
      if (wholeRoofStatsBuilder_ == null) {
        wholeRoofStats_ = builderForValue.build();
      } else {
        wholeRoofStatsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public Builder mergeWholeRoofStats(com.google.maps.solar.v1.SizeAndSunshineStats value) {
      if (wholeRoofStatsBuilder_ == null) {
        if (((bitField0_ & 0x00000100) != 0)
            && wholeRoofStats_ != null
            && wholeRoofStats_
                != com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()) {
          getWholeRoofStatsBuilder().mergeFrom(value);
        } else {
          wholeRoofStats_ = value;
        }
      } else {
        wholeRoofStatsBuilder_.mergeFrom(value);
      }
      if (wholeRoofStats_ != null) {
        bitField0_ |= 0x00000100;
        onChanged();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public Builder clearWholeRoofStats() {
      bitField0_ = (bitField0_ & ~0x00000100);
      wholeRoofStats_ = null;
      if (wholeRoofStatsBuilder_ != null) {
        wholeRoofStatsBuilder_.dispose();
        wholeRoofStatsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public com.google.maps.solar.v1.SizeAndSunshineStats.Builder getWholeRoofStatsBuilder() {
      bitField0_ |= 0x00000100;
      onChanged();
      return getWholeRoofStatsFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    public com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getWholeRoofStatsOrBuilder() {
      if (wholeRoofStatsBuilder_ != null) {
        return wholeRoofStatsBuilder_.getMessageOrBuilder();
      } else {
        return wholeRoofStats_ == null
            ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
            : wholeRoofStats_;
      }
    }
    /**
     *
     *
     * <pre>
     * Total size and sunlight quantiles for the part of the roof that
     * was assigned to some roof segment. Despite the name, this may not
     * include the entire building. See [building_stats]
     * [google.maps.solar.v1.SolarPotential.building_stats].
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.maps.solar.v1.SizeAndSunshineStats,
            com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>
        getWholeRoofStatsFieldBuilder() {
      if (wholeRoofStatsBuilder_ == null) {
        wholeRoofStatsBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.maps.solar.v1.SizeAndSunshineStats,
                com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
                com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>(
                getWholeRoofStats(), getParentForChildren(), isClean());
        wholeRoofStats_ = null;
      }
      return wholeRoofStatsBuilder_;
    }

    private com.google.maps.solar.v1.SizeAndSunshineStats buildingStats_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.maps.solar.v1.SizeAndSunshineStats,
            com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>
        buildingStatsBuilder_;
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     *
     * @return Whether the buildingStats field is set.
     */
    public boolean hasBuildingStats() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     *
     * @return The buildingStats.
     */
    public com.google.maps.solar.v1.SizeAndSunshineStats getBuildingStats() {
      if (buildingStatsBuilder_ == null) {
        return buildingStats_ == null
            ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
            : buildingStats_;
      } else {
        return buildingStatsBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public Builder setBuildingStats(com.google.maps.solar.v1.SizeAndSunshineStats value) {
      if (buildingStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        buildingStats_ = value;
      } else {
        buildingStatsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public Builder setBuildingStats(
        com.google.maps.solar.v1.SizeAndSunshineStats.Builder builderForValue) {
      if (buildingStatsBuilder_ == null) {
        buildingStats_ = builderForValue.build();
      } else {
        buildingStatsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public Builder mergeBuildingStats(com.google.maps.solar.v1.SizeAndSunshineStats value) {
      if (buildingStatsBuilder_ == null) {
        if (((bitField0_ & 0x00000200) != 0)
            && buildingStats_ != null
            && buildingStats_
                != com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()) {
          getBuildingStatsBuilder().mergeFrom(value);
        } else {
          buildingStats_ = value;
        }
      } else {
        buildingStatsBuilder_.mergeFrom(value);
      }
      if (buildingStats_ != null) {
        bitField0_ |= 0x00000200;
        onChanged();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public Builder clearBuildingStats() {
      bitField0_ = (bitField0_ & ~0x00000200);
      buildingStats_ = null;
      if (buildingStatsBuilder_ != null) {
        buildingStatsBuilder_.dispose();
        buildingStatsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public com.google.maps.solar.v1.SizeAndSunshineStats.Builder getBuildingStatsBuilder() {
      bitField0_ |= 0x00000200;
      onChanged();
      return getBuildingStatsFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    public com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder getBuildingStatsOrBuilder() {
      if (buildingStatsBuilder_ != null) {
        return buildingStatsBuilder_.getMessageOrBuilder();
      } else {
        return buildingStats_ == null
            ? com.google.maps.solar.v1.SizeAndSunshineStats.getDefaultInstance()
            : buildingStats_;
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for the entire building, including
     * parts of the roof that were not assigned to some roof segment.
     * Because the orientations of these parts are not well
     * characterised, the roof area estimate is unreliable, but the
     * ground area estimate is reliable. It may be that a more reliable
     * whole building roof area can be obtained by scaling the roof area
     * from [whole_roof_stats]
     * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
     * the ratio of the ground areas of `building_stats` and
     * `whole_roof_stats`.
     * </pre>
     *
     * <code>.google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.maps.solar.v1.SizeAndSunshineStats,
            com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>
        getBuildingStatsFieldBuilder() {
      if (buildingStatsBuilder_ == null) {
        buildingStatsBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.maps.solar.v1.SizeAndSunshineStats,
                com.google.maps.solar.v1.SizeAndSunshineStats.Builder,
                com.google.maps.solar.v1.SizeAndSunshineStatsOrBuilder>(
                getBuildingStats(), getParentForChildren(), isClean());
        buildingStats_ = null;
      }
      return buildingStatsBuilder_;
    }

    private java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
        roofSegmentStats_ = java.util.Collections.emptyList();

    private void ensureRoofSegmentStatsIsMutable() {
      if (!((bitField0_ & 0x00000400) != 0)) {
        roofSegmentStats_ =
            new java.util.ArrayList<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>(
                roofSegmentStats_);
        bitField0_ |= 0x00000400;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats,
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>
        roofSegmentStatsBuilder_;

    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
        getRoofSegmentStatsList() {
      if (roofSegmentStatsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(roofSegmentStats_);
      } else {
        return roofSegmentStatsBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public int getRoofSegmentStatsCount() {
      if (roofSegmentStatsBuilder_ == null) {
        return roofSegmentStats_.size();
      } else {
        return roofSegmentStatsBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats getRoofSegmentStats(int index) {
      if (roofSegmentStatsBuilder_ == null) {
        return roofSegmentStats_.get(index);
      } else {
        return roofSegmentStatsBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder setRoofSegmentStats(
        int index, com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats value) {
      if (roofSegmentStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.set(index, value);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder setRoofSegmentStats(
        int index,
        com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder builderForValue) {
      if (roofSegmentStatsBuilder_ == null) {
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.set(index, builderForValue.build());
        onChanged();
      } else {
        roofSegmentStatsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder addRoofSegmentStats(
        com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats value) {
      if (roofSegmentStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.add(value);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder addRoofSegmentStats(
        int index, com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats value) {
      if (roofSegmentStatsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.add(index, value);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder addRoofSegmentStats(
        com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder builderForValue) {
      if (roofSegmentStatsBuilder_ == null) {
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.add(builderForValue.build());
        onChanged();
      } else {
        roofSegmentStatsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder addRoofSegmentStats(
        int index,
        com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder builderForValue) {
      if (roofSegmentStatsBuilder_ == null) {
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.add(index, builderForValue.build());
        onChanged();
      } else {
        roofSegmentStatsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder addAllRoofSegmentStats(
        java.lang.Iterable<? extends com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats>
            values) {
      if (roofSegmentStatsBuilder_ == null) {
        ensureRoofSegmentStatsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, roofSegmentStats_);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder clearRoofSegmentStats() {
      if (roofSegmentStatsBuilder_ == null) {
        roofSegmentStats_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000400);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public Builder removeRoofSegmentStats(int index) {
      if (roofSegmentStatsBuilder_ == null) {
        ensureRoofSegmentStatsIsMutable();
        roofSegmentStats_.remove(index);
        onChanged();
      } else {
        roofSegmentStatsBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder
        getRoofSegmentStatsBuilder(int index) {
      return getRoofSegmentStatsFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder
        getRoofSegmentStatsOrBuilder(int index) {
      if (roofSegmentStatsBuilder_ == null) {
        return roofSegmentStats_.get(index);
      } else {
        return roofSegmentStatsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public java.util.List<
            ? extends com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>
        getRoofSegmentStatsOrBuilderList() {
      if (roofSegmentStatsBuilder_ != null) {
        return roofSegmentStatsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(roofSegmentStats_);
      }
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder
        addRoofSegmentStatsBuilder() {
      return getRoofSegmentStatsFieldBuilder()
          .addBuilder(
              com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder
        addRoofSegmentStatsBuilder(int index) {
      return getRoofSegmentStatsFieldBuilder()
          .addBuilder(
              index, com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Size and sunlight quantiles for each roof segment.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
     * </code>
     */
    public java.util.List<com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder>
        getRoofSegmentStatsBuilderList() {
      return getRoofSegmentStatsFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats,
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder,
            com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>
        getRoofSegmentStatsFieldBuilder() {
      if (roofSegmentStatsBuilder_ == null) {
        roofSegmentStatsBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats,
                com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.Builder,
                com.google.maps.solar.v1.RoofSegmentSizeAndSunshineStatsOrBuilder>(
                roofSegmentStats_,
                ((bitField0_ & 0x00000400) != 0),
                getParentForChildren(),
                isClean());
        roofSegmentStats_ = null;
      }
      return roofSegmentStatsBuilder_;
    }

    private java.util.List<com.google.maps.solar.v1.SolarPanel> solarPanels_ =
        java.util.Collections.emptyList();

    private void ensureSolarPanelsIsMutable() {
      if (!((bitField0_ & 0x00000800) != 0)) {
        solarPanels_ = new java.util.ArrayList<com.google.maps.solar.v1.SolarPanel>(solarPanels_);
        bitField0_ |= 0x00000800;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.SolarPanel,
            com.google.maps.solar.v1.SolarPanel.Builder,
            com.google.maps.solar.v1.SolarPanelOrBuilder>
        solarPanelsBuilder_;

    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public java.util.List<com.google.maps.solar.v1.SolarPanel> getSolarPanelsList() {
      if (solarPanelsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(solarPanels_);
      } else {
        return solarPanelsBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public int getSolarPanelsCount() {
      if (solarPanelsBuilder_ == null) {
        return solarPanels_.size();
      } else {
        return solarPanelsBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public com.google.maps.solar.v1.SolarPanel getSolarPanels(int index) {
      if (solarPanelsBuilder_ == null) {
        return solarPanels_.get(index);
      } else {
        return solarPanelsBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder setSolarPanels(int index, com.google.maps.solar.v1.SolarPanel value) {
      if (solarPanelsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelsIsMutable();
        solarPanels_.set(index, value);
        onChanged();
      } else {
        solarPanelsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder setSolarPanels(
        int index, com.google.maps.solar.v1.SolarPanel.Builder builderForValue) {
      if (solarPanelsBuilder_ == null) {
        ensureSolarPanelsIsMutable();
        solarPanels_.set(index, builderForValue.build());
        onChanged();
      } else {
        solarPanelsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder addSolarPanels(com.google.maps.solar.v1.SolarPanel value) {
      if (solarPanelsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelsIsMutable();
        solarPanels_.add(value);
        onChanged();
      } else {
        solarPanelsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder addSolarPanels(int index, com.google.maps.solar.v1.SolarPanel value) {
      if (solarPanelsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelsIsMutable();
        solarPanels_.add(index, value);
        onChanged();
      } else {
        solarPanelsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder addSolarPanels(com.google.maps.solar.v1.SolarPanel.Builder builderForValue) {
      if (solarPanelsBuilder_ == null) {
        ensureSolarPanelsIsMutable();
        solarPanels_.add(builderForValue.build());
        onChanged();
      } else {
        solarPanelsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder addSolarPanels(
        int index, com.google.maps.solar.v1.SolarPanel.Builder builderForValue) {
      if (solarPanelsBuilder_ == null) {
        ensureSolarPanelsIsMutable();
        solarPanels_.add(index, builderForValue.build());
        onChanged();
      } else {
        solarPanelsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder addAllSolarPanels(
        java.lang.Iterable<? extends com.google.maps.solar.v1.SolarPanel> values) {
      if (solarPanelsBuilder_ == null) {
        ensureSolarPanelsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, solarPanels_);
        onChanged();
      } else {
        solarPanelsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder clearSolarPanels() {
      if (solarPanelsBuilder_ == null) {
        solarPanels_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
      } else {
        solarPanelsBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public Builder removeSolarPanels(int index) {
      if (solarPanelsBuilder_ == null) {
        ensureSolarPanelsIsMutable();
        solarPanels_.remove(index);
        onChanged();
      } else {
        solarPanelsBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public com.google.maps.solar.v1.SolarPanel.Builder getSolarPanelsBuilder(int index) {
      return getSolarPanelsFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public com.google.maps.solar.v1.SolarPanelOrBuilder getSolarPanelsOrBuilder(int index) {
      if (solarPanelsBuilder_ == null) {
        return solarPanels_.get(index);
      } else {
        return solarPanelsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public java.util.List<? extends com.google.maps.solar.v1.SolarPanelOrBuilder>
        getSolarPanelsOrBuilderList() {
      if (solarPanelsBuilder_ != null) {
        return solarPanelsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(solarPanels_);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public com.google.maps.solar.v1.SolarPanel.Builder addSolarPanelsBuilder() {
      return getSolarPanelsFieldBuilder()
          .addBuilder(com.google.maps.solar.v1.SolarPanel.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public com.google.maps.solar.v1.SolarPanel.Builder addSolarPanelsBuilder(int index) {
      return getSolarPanelsFieldBuilder()
          .addBuilder(index, com.google.maps.solar.v1.SolarPanel.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
     * describes a single solar panel. They are listed in the order that
     * the panel layout algorithm placed this. This is usually, though
     * not always, in decreasing order of annual energy production.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanel solar_panels = 14;</code>
     */
    public java.util.List<com.google.maps.solar.v1.SolarPanel.Builder> getSolarPanelsBuilderList() {
      return getSolarPanelsFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.SolarPanel,
            com.google.maps.solar.v1.SolarPanel.Builder,
            com.google.maps.solar.v1.SolarPanelOrBuilder>
        getSolarPanelsFieldBuilder() {
      if (solarPanelsBuilder_ == null) {
        solarPanelsBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.maps.solar.v1.SolarPanel,
                com.google.maps.solar.v1.SolarPanel.Builder,
                com.google.maps.solar.v1.SolarPanelOrBuilder>(
                solarPanels_, ((bitField0_ & 0x00000800) != 0), getParentForChildren(), isClean());
        solarPanels_ = null;
      }
      return solarPanelsBuilder_;
    }

    private java.util.List<com.google.maps.solar.v1.SolarPanelConfig> solarPanelConfigs_ =
        java.util.Collections.emptyList();

    private void ensureSolarPanelConfigsIsMutable() {
      if (!((bitField0_ & 0x00001000) != 0)) {
        solarPanelConfigs_ =
            new java.util.ArrayList<com.google.maps.solar.v1.SolarPanelConfig>(solarPanelConfigs_);
        bitField0_ |= 0x00001000;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.SolarPanelConfig,
            com.google.maps.solar.v1.SolarPanelConfig.Builder,
            com.google.maps.solar.v1.SolarPanelConfigOrBuilder>
        solarPanelConfigsBuilder_;

    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public java.util.List<com.google.maps.solar.v1.SolarPanelConfig> getSolarPanelConfigsList() {
      if (solarPanelConfigsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(solarPanelConfigs_);
      } else {
        return solarPanelConfigsBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public int getSolarPanelConfigsCount() {
      if (solarPanelConfigsBuilder_ == null) {
        return solarPanelConfigs_.size();
      } else {
        return solarPanelConfigsBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public com.google.maps.solar.v1.SolarPanelConfig getSolarPanelConfigs(int index) {
      if (solarPanelConfigsBuilder_ == null) {
        return solarPanelConfigs_.get(index);
      } else {
        return solarPanelConfigsBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder setSolarPanelConfigs(
        int index, com.google.maps.solar.v1.SolarPanelConfig value) {
      if (solarPanelConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.set(index, value);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder setSolarPanelConfigs(
        int index, com.google.maps.solar.v1.SolarPanelConfig.Builder builderForValue) {
      if (solarPanelConfigsBuilder_ == null) {
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.set(index, builderForValue.build());
        onChanged();
      } else {
        solarPanelConfigsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder addSolarPanelConfigs(com.google.maps.solar.v1.SolarPanelConfig value) {
      if (solarPanelConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.add(value);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder addSolarPanelConfigs(
        int index, com.google.maps.solar.v1.SolarPanelConfig value) {
      if (solarPanelConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.add(index, value);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder addSolarPanelConfigs(
        com.google.maps.solar.v1.SolarPanelConfig.Builder builderForValue) {
      if (solarPanelConfigsBuilder_ == null) {
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.add(builderForValue.build());
        onChanged();
      } else {
        solarPanelConfigsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder addSolarPanelConfigs(
        int index, com.google.maps.solar.v1.SolarPanelConfig.Builder builderForValue) {
      if (solarPanelConfigsBuilder_ == null) {
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.add(index, builderForValue.build());
        onChanged();
      } else {
        solarPanelConfigsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder addAllSolarPanelConfigs(
        java.lang.Iterable<? extends com.google.maps.solar.v1.SolarPanelConfig> values) {
      if (solarPanelConfigsBuilder_ == null) {
        ensureSolarPanelConfigsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, solarPanelConfigs_);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder clearSolarPanelConfigs() {
      if (solarPanelConfigsBuilder_ == null) {
        solarPanelConfigs_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public Builder removeSolarPanelConfigs(int index) {
      if (solarPanelConfigsBuilder_ == null) {
        ensureSolarPanelConfigsIsMutable();
        solarPanelConfigs_.remove(index);
        onChanged();
      } else {
        solarPanelConfigsBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public com.google.maps.solar.v1.SolarPanelConfig.Builder getSolarPanelConfigsBuilder(
        int index) {
      return getSolarPanelConfigsFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public com.google.maps.solar.v1.SolarPanelConfigOrBuilder getSolarPanelConfigsOrBuilder(
        int index) {
      if (solarPanelConfigsBuilder_ == null) {
        return solarPanelConfigs_.get(index);
      } else {
        return solarPanelConfigsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public java.util.List<? extends com.google.maps.solar.v1.SolarPanelConfigOrBuilder>
        getSolarPanelConfigsOrBuilderList() {
      if (solarPanelConfigsBuilder_ != null) {
        return solarPanelConfigsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(solarPanelConfigs_);
      }
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public com.google.maps.solar.v1.SolarPanelConfig.Builder addSolarPanelConfigsBuilder() {
      return getSolarPanelConfigsFieldBuilder()
          .addBuilder(com.google.maps.solar.v1.SolarPanelConfig.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public com.google.maps.solar.v1.SolarPanelConfig.Builder addSolarPanelConfigsBuilder(
        int index) {
      return getSolarPanelConfigsFieldBuilder()
          .addBuilder(index, com.google.maps.solar.v1.SolarPanelConfig.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * Each [SolarPanelConfig]
     * [google.maps.solar.v1.SolarPanelConfig] describes a
     * different arrangement of solar panels on the roof. They are in
     * order of increasing number of panels. The `SolarPanelConfig` with
     * [panels_count]
     * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
     * based on the first N panels in the `solar_panels` list. This field is only
     * populated if at least 4 panels can fit on a roof.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;</code>
     */
    public java.util.List<com.google.maps.solar.v1.SolarPanelConfig.Builder>
        getSolarPanelConfigsBuilderList() {
      return getSolarPanelConfigsFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.SolarPanelConfig,
            com.google.maps.solar.v1.SolarPanelConfig.Builder,
            com.google.maps.solar.v1.SolarPanelConfigOrBuilder>
        getSolarPanelConfigsFieldBuilder() {
      if (solarPanelConfigsBuilder_ == null) {
        solarPanelConfigsBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.maps.solar.v1.SolarPanelConfig,
                com.google.maps.solar.v1.SolarPanelConfig.Builder,
                com.google.maps.solar.v1.SolarPanelConfigOrBuilder>(
                solarPanelConfigs_,
                ((bitField0_ & 0x00001000) != 0),
                getParentForChildren(),
                isClean());
        solarPanelConfigs_ = null;
      }
      return solarPanelConfigsBuilder_;
    }

    private java.util.List<com.google.maps.solar.v1.FinancialAnalysis> financialAnalyses_ =
        java.util.Collections.emptyList();

    private void ensureFinancialAnalysesIsMutable() {
      if (!((bitField0_ & 0x00002000) != 0)) {
        financialAnalyses_ =
            new java.util.ArrayList<com.google.maps.solar.v1.FinancialAnalysis>(financialAnalyses_);
        bitField0_ |= 0x00002000;
      }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.FinancialAnalysis,
            com.google.maps.solar.v1.FinancialAnalysis.Builder,
            com.google.maps.solar.v1.FinancialAnalysisOrBuilder>
        financialAnalysesBuilder_;

    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public java.util.List<com.google.maps.solar.v1.FinancialAnalysis> getFinancialAnalysesList() {
      if (financialAnalysesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(financialAnalyses_);
      } else {
        return financialAnalysesBuilder_.getMessageList();
      }
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public int getFinancialAnalysesCount() {
      if (financialAnalysesBuilder_ == null) {
        return financialAnalyses_.size();
      } else {
        return financialAnalysesBuilder_.getCount();
      }
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public com.google.maps.solar.v1.FinancialAnalysis getFinancialAnalyses(int index) {
      if (financialAnalysesBuilder_ == null) {
        return financialAnalyses_.get(index);
      } else {
        return financialAnalysesBuilder_.getMessage(index);
      }
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder setFinancialAnalyses(
        int index, com.google.maps.solar.v1.FinancialAnalysis value) {
      if (financialAnalysesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.set(index, value);
        onChanged();
      } else {
        financialAnalysesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder setFinancialAnalyses(
        int index, com.google.maps.solar.v1.FinancialAnalysis.Builder builderForValue) {
      if (financialAnalysesBuilder_ == null) {
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.set(index, builderForValue.build());
        onChanged();
      } else {
        financialAnalysesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder addFinancialAnalyses(com.google.maps.solar.v1.FinancialAnalysis value) {
      if (financialAnalysesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.add(value);
        onChanged();
      } else {
        financialAnalysesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder addFinancialAnalyses(
        int index, com.google.maps.solar.v1.FinancialAnalysis value) {
      if (financialAnalysesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.add(index, value);
        onChanged();
      } else {
        financialAnalysesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder addFinancialAnalyses(
        com.google.maps.solar.v1.FinancialAnalysis.Builder builderForValue) {
      if (financialAnalysesBuilder_ == null) {
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.add(builderForValue.build());
        onChanged();
      } else {
        financialAnalysesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder addFinancialAnalyses(
        int index, com.google.maps.solar.v1.FinancialAnalysis.Builder builderForValue) {
      if (financialAnalysesBuilder_ == null) {
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.add(index, builderForValue.build());
        onChanged();
      } else {
        financialAnalysesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder addAllFinancialAnalyses(
        java.lang.Iterable<? extends com.google.maps.solar.v1.FinancialAnalysis> values) {
      if (financialAnalysesBuilder_ == null) {
        ensureFinancialAnalysesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, financialAnalyses_);
        onChanged();
      } else {
        financialAnalysesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder clearFinancialAnalyses() {
      if (financialAnalysesBuilder_ == null) {
        financialAnalyses_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
      } else {
        financialAnalysesBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public Builder removeFinancialAnalyses(int index) {
      if (financialAnalysesBuilder_ == null) {
        ensureFinancialAnalysesIsMutable();
        financialAnalyses_.remove(index);
        onChanged();
      } else {
        financialAnalysesBuilder_.remove(index);
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public com.google.maps.solar.v1.FinancialAnalysis.Builder getFinancialAnalysesBuilder(
        int index) {
      return getFinancialAnalysesFieldBuilder().getBuilder(index);
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public com.google.maps.solar.v1.FinancialAnalysisOrBuilder getFinancialAnalysesOrBuilder(
        int index) {
      if (financialAnalysesBuilder_ == null) {
        return financialAnalyses_.get(index);
      } else {
        return financialAnalysesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public java.util.List<? extends com.google.maps.solar.v1.FinancialAnalysisOrBuilder>
        getFinancialAnalysesOrBuilderList() {
      if (financialAnalysesBuilder_ != null) {
        return financialAnalysesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(financialAnalyses_);
      }
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public com.google.maps.solar.v1.FinancialAnalysis.Builder addFinancialAnalysesBuilder() {
      return getFinancialAnalysesFieldBuilder()
          .addBuilder(com.google.maps.solar.v1.FinancialAnalysis.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public com.google.maps.solar.v1.FinancialAnalysis.Builder addFinancialAnalysesBuilder(
        int index) {
      return getFinancialAnalysesFieldBuilder()
          .addBuilder(index, com.google.maps.solar.v1.FinancialAnalysis.getDefaultInstance());
    }
    /**
     *
     *
     * <pre>
     * A [FinancialAnalysis]
     * [google.maps.solar.v1.FinancialAnalysis] gives the savings
     * from going solar assuming a given monthly bill and a given
     * electricity provider. They are in order of increasing order of
     * monthly bill amount. This field will be empty for buildings in
     * areas for which the Solar API does not have enough information to
     * perform financial computations.
     * </pre>
     *
     * <code>repeated .google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;</code>
     */
    public java.util.List<com.google.maps.solar.v1.FinancialAnalysis.Builder>
        getFinancialAnalysesBuilderList() {
      return getFinancialAnalysesFieldBuilder().getBuilderList();
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
            com.google.maps.solar.v1.FinancialAnalysis,
            com.google.maps.solar.v1.FinancialAnalysis.Builder,
            com.google.maps.solar.v1.FinancialAnalysisOrBuilder>
        getFinancialAnalysesFieldBuilder() {
      if (financialAnalysesBuilder_ == null) {
        financialAnalysesBuilder_ =
            new com.google.protobuf.RepeatedFieldBuilderV3<
                com.google.maps.solar.v1.FinancialAnalysis,
                com.google.maps.solar.v1.FinancialAnalysis.Builder,
                com.google.maps.solar.v1.FinancialAnalysisOrBuilder>(
                financialAnalyses_,
                ((bitField0_ & 0x00002000) != 0),
                getParentForChildren(),
                isClean());
        financialAnalyses_ = null;
      }
      return financialAnalysesBuilder_;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.maps.solar.v1.SolarPotential)
  }

  // @@protoc_insertion_point(class_scope:google.maps.solar.v1.SolarPotential)
  private static final com.google.maps.solar.v1.SolarPotential DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.maps.solar.v1.SolarPotential();
  }

  public static com.google.maps.solar.v1.SolarPotential getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<SolarPotential> PARSER =
      new com.google.protobuf.AbstractParser<SolarPotential>() {
        @java.lang.Override
        public SolarPotential parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

  public static com.google.protobuf.Parser<SolarPotential> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<SolarPotential> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.maps.solar.v1.SolarPotential getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
